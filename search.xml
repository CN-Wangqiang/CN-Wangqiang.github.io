<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>在浏览器输入URL回车之后发生了什么</title>
      <link href="/2020/12/06/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL%E5%9B%9E%E8%BD%A6%E4%B9%8B%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/"/>
      <url>/2020/12/06/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL%E5%9B%9E%E8%BD%A6%E4%B9%8B%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>这个问题已经是老生常谈了，更是经常被作为面试的压轴题出现，网上也有很多文章，但最近闲的无聊，然后就自己做了一篇笔记，感觉比之前理解更透彻了。</p><p>这篇笔记是我这两天看了数十篇文章总结出来的，所以相对全面一点，但由于我是做前端的，所以会比较重点分析浏览器渲染页面那一部分，至于其他部分我会罗列出关键词，感兴趣的可以自行查阅，</p><blockquote><p>本文转自<a href="https://4ark.me/post/b6c7c0a2.html" target="_blank" rel="noopener">4ark</a></p></blockquote><p>**注意：**本文的步骤是建立在，请求的是一个简单的 HTTP 请求，没有 HTTPS、HTTP2、最简单的 DNS、没有代理、并且服务器没有任何问题的基础上，尽管这是不切实际的。</p><h2 id="大致流程"><a class="markdownIt-Anchor" href="#大致流程"></a> 大致流程</h2><ol><li>URL 解析</li><li>DNS 查询</li><li>TCP 连接</li><li>处理请求</li><li>接受响应</li><li>渲染页面</li></ol><h3 id="url-解析"><a class="markdownIt-Anchor" href="#url-解析"></a> URL 解析</h3><p><strong>地址解析：</strong></p><p>首先判断你输入的是一个合法的 URL 还是一个待搜索的关键词，并且根据你输入的内容进行自动完成、字符编码等操作。</p><p><strong>HSTS</strong></p><p>由于安全隐患，会使用 HSTS 强制客户端使用 HTTPS 访问页面。详见：<a href="https://www.barretlee.com/blog/2015/10/22/hsts-intro/" target="_blank" rel="noopener">你所不知道的 HSTS</a></p><p><strong>其他操作</strong></p><p>浏览器还会进行一些额外的操作，比如安全检查、访问限制（之前国产浏览器限制 996.icu）。</p><p><strong>检查缓存</strong></p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/img/WhathappenswhenyoutypeanURLinthebrowserandpressenter.png" alt="WhathappenswhenyoutypeanURLinthebrowserandpressenter" /></p><h3 id="dns-查询"><a class="markdownIt-Anchor" href="#dns-查询"></a> DNS 查询</h3><p><strong>基本步骤</strong></p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/img/asdappenswasdyoutssenterbaiscprocess0715.png" alt="asdappenswasdyoutssenterbaiscprocess0715" /></p><p><strong>浏览器缓存</strong></p><p>浏览器会先检查是否在缓存中，没有则调用系统库函数进行查询。</p><p><strong>操作系统缓存</strong></p><p>操作系统也有自己的 DNS 缓存，但在这之前，会向检查域名是否存在本地的 Hosts 文件里，没有则向 DNS 服务器发送查询请求。</p><p><strong>路由器缓存</strong></p><p>路由器也有自己的缓存。</p><p><strong>ISP DNS 缓存</strong></p><p>ISP DNS 就是在客户端电脑上设置的首选 DNS 服务器，它们在大多数情况下都会有缓存。</p><p><strong>根域名服务器查询</strong></p><p>在前面所有步骤没有缓存的情况下，本地 DNS 服务器会将请求转发到互联网上的根域，下面这个图很好的诠释了整个流程：</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/img/WhathappensURLinthebrowserandpressenterdns.png" alt="WhathappensURLinthebrowserandpressenterdns" /></p><blockquote><p>根域名服务器：<a href="">维基百科</a></p></blockquote><p>需要注意的点</p><ol><li>递归方式：一路查下去中间不返回，得到最终结果才返回信息（浏览器到本地 DNS 服务器的过程）</li><li>迭代方式，就是本地 DNS 服务器到根域名服务器查询的方式。</li><li>什么是 DNS 劫持</li><li>前端 dns-prefetch 优化</li></ol><h3 id="tcp-连接"><a class="markdownIt-Anchor" href="#tcp-连接"></a> TCP 连接</h3><p>TCP/IP 分为四层，在发送数据时，每层都要对数据进行封装：</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/img/whentha0717ebrowserandpressentertcp.png" alt="whentha0717ebrowserandpressentertcp" /></p><ol><li>应用层：发送 HTTP 请求</li></ol><p>在前面的步骤我们已经得到服务器的 IP 地址，浏览器会开始构造一个 HTTP 报文，其中包括：</p><p>请求报头（Request Header）：请求方法、目标地址、遵循的协议等等<br />请求主体（其他参数）<br />其中需要注意的点：</p><p>浏览器只能发送 GET、POST 方法，而打开网页使用的是 GET 方法</p><ol start="2"><li>传输层：TCP 传输报文</li></ol><p>传输层会发起一条到达服务器的 TCP 连接，为了方便传输，会对数据进行分割（以报文段为单位），并标记编号，方便服务器接受时能够準确地还原报文信息。</p><p>在建立连接前，会先进行 TCP 三次握手。</p><blockquote><p>关于 TCP/IP 三次握手，网上已经有很多段子和图片生动地描述了。</p><p>相关知识：SYN 泛洪攻击</p></blockquote><ol start="3"><li>网络层：IP 协议查询 Mac 地址</li></ol><p>将数据段打包，并加入源及目标的 IP 地址，并且负责寻找传输路线。</p><p>判断目标地址是否与当前地址处于同一网络中，是的话直接根据 Mac 地址发送，否则使用路由表查找下一跳地址，以及使用 ARP 协议查询它的 Mac 地址。</p><blockquote><p>注意：在 OSI 参考模型中 ARP 协议位于链路层，但在 TCP/IP 中，它位于网络层。</p></blockquote><ol start="4"><li>链路层：以太网协议</li></ol><p><strong>以太网协议</strong></p><p>根据以太网协议将数据分为以 “帧” 为单位的数据包，每一帧分为两个部分：</p><p>标头：数据包的发送者、接受者、数据类型<br />数据：数据包具体内容<br /><strong>Mac 地址</strong></p><p>以太网规定了连入网络的所有设备都必须具备 “网卡” 接口，数据包都是从一块网卡传递到另一块网卡，网卡的地址就是 Mac 地址。每一个 Mac 地址都是独一无二的，具备了一对一的能力。</p><p><strong>广播</strong></p><p>发送数据的方法很原始，直接把数据通过 ARP 协议，向本网络的所有机器发送，接收方根据标头信息与自身 Mac 地址比较，一致就接受，否则丢弃。</p><p>注意：接收方迴应是单播。</p><blockquote><p>相关知识：ARP攻击</p></blockquote><p>服务器接受请求</p><p>接受过程就是把以上步骤逆转过来，参见上图。</p><h3 id="服务器处理请求"><a class="markdownIt-Anchor" href="#服务器处理请求"></a> <strong>服务器处理请求</strong></h3><p>大致流程</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/img/What7897dasdandpressenteruiaasd.png" alt="What7897dasdandpressenteruiaasd" /></p><p><strong>HTTPD</strong></p><p>最常见的 HTTPD 有 Linux 上常用的 Apache 和 Nginx，以及 Windows 上的 IIS。</p><p>它会监听得到的请求，然后开启一个子进程去处理这个请求。</p><p><strong>处理请求</strong></p><p>接受 TCP 报文后，会对连接进行处理，对 HTTP 协议进行解析（请求方法、域名、路径等），并且进行一些验证：</p><ul><li>验证是否配置虚拟主机</li><li>验证虚拟主机是否接受此方法</li><li>验证该用户可以使用该方法（根据 IP 地址、身份信息等）</li></ul><p><strong>重定向</strong></p><p>假如服务器配置了 HTTP 重定向，就会返回一个 301 永久重定向响应，浏览器就会根据响应，重新发送 HTTP 请求（重新执行上面的过程）。</p><p><strong>URL 重写</strong></p><p>然后会查看 URL 重写规则，如果请求的文件是真实存在的，比如图片、html、css、js 文件等，则会直接把这个文件返回。</p><p>否则服务器会按照规则把请求重写到 一个 REST 风格的 URL 上。</p><p>然后根据动态语言的脚本，来决定调用什么类型的动态文件解释器来处理这个请求。</p><p>以 PHP 语言的 MVC 框架举例，它首先会初始化一些环境的参数，根据 URL 由上到下地去匹配路由，然后让路由所定义的方法去处理请求。</p><h3 id="服务器接受响应"><a class="markdownIt-Anchor" href="#服务器接受响应"></a> 服务器接受响应</h3><p>浏览器接收到来自服务器的响应资源后，会对资源进行分析。</p><p>首先查看 Response header，根据不同状态码做不同的事（比如上面提到的重定向）。</p><p>如果响应资源进行了压缩（比如 gzip），还需要进行解压。</p><p>然后，对响应资源做缓存。</p><p>接下来，根据响应资源里的 MIME 类型去解析响应内容（比如 HTML、Image 各有不同的解析方式）。</p><h3 id="渲染页面"><a class="markdownIt-Anchor" href="#渲染页面"></a> 渲染页面</h3><p><strong>浏览器内核</strong></p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/img/Wasasddhat45671URLssenasdterbroswerasda123.png" alt="Wasasddhat45671URLssenasdterbroswerasda123" /></p><p>不同的浏览器内核，渲染过程也不完全相同，但大致流程都差不多。</p><p><strong>基本流程</strong></p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/img/What4234anwserndpressenter123z.png" alt="What4234anwserndpressenter123z" /></p><p><strong>HTML 解析</strong></p><p>首先要知道浏览器解析是从上往下一行一行地解析的。</p><p>解析的过程可以分为四个步骤：</p><ol><li>解码（encoding）</li></ol><p>传输回来的其实都是一些二进制字节数据，浏览器需要根据文件指定编码（例如 UTF-8）转换成字符串，也就是 HTML 代码。</p><ol start="2"><li>预解析（pre-parsing）</li></ol><p>预解析做的事情是提前加载资源，减少处理时间，它会识别一些会请求资源的属性，比如 img 标籤的 src 属性，并将这个请求加到请求队列中。</p><ol start="3"><li>符号化（Tokenization）</li></ol><p>符号化是词法分析的过程，将输入解析成符号，HTML 符号包括，开始标籤、结束标籤、属性名和属性值。</p><p>它通过一个状态机去识别符号的状态，比如遇到 &lt;，&gt; 状态都会产生变化。</p><ol start="4"><li>构建树（tree construction）</li></ol><blockquote><p>注意：符号化和构建树是并行操作的，也就是説只要解析到一个开始标籤，就会创建一个 DOM 节点。</p></blockquote><p>在上一步符号化中，解析器获得这些标记，然后以合适的方法创建 DOM 对象并把这些符号插入到 DOM 对象中。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Web page parsing<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Web page parsing<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is an example Web page.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>浏览器容错进制</strong></p><p>你从来没有在浏览器看过类似” 语法无效” 的错误，这是因为浏览器去纠正错误的语法，然后继续工作。</p><p><strong>事件</strong></p><p>当整个解析的过程完成以后，浏览器会通过 DOMContentLoaded 事件来通知 DOM 解析完成。</p><p><strong>CSS 解析</strong></p><p>一旦浏览器下载了 CSS，CSS 解析器就会处理它遇到的任何 CSS，根据语法规範解析出所有的 CSS 并进行标记化，然后我们得到一个规则表。</p><p><strong>CSS 匹配规则</strong></p><p>在匹配一个节点对应的 CSS 规则时，是按照从右到左的顺序的，例如：div p { font-size :14px } 会先寻找所有的 p 标籤然后判断它的父元素是否为 div。</p><p>所以我们写 CSS 时，儘量用 id 和 class，千万不要过度层叠。</p><p><strong>渲染树</strong></p><p>其实这就是一个 DOM 树和 CSS 规则树合併的过程。</p><blockquote><p>注意：渲染树会忽略那些不需要渲染的节点，比如设置了 display:none 的节点。</p></blockquote><p><strong>计算</strong></p><p>通过计算让任何尺寸值都减少到三个可能之一：auto、百分比、px，比如把 rem 转化为 px。</p><p><strong>级联</strong></p><p>浏览器需要一种方法来确定哪些样式才真正需要应用到对应元素，所以它使用一个叫做 specificity 的公式，这个公式会通过：</p><ul><li>标籤名、class、id</li><li>是否内联样式</li><li>!important</li></ul><p>然后得出一个权重值，取最高的那个。</p><p><strong>渲染阻塞</strong></p><p>当遇到一个 script 标籤时，DOM 构建会被暂停，直至脚本完成执行，然后继续构建 DOM 树。</p><p>但如果 JS 依赖 CSS 样式，而它还没有被下载和构建时，浏览器就会延迟脚本执行，直至 CSS Rules 被构建。</p><p>所有我们知道：</p><ul><li>CSS 会阻塞 JS 执行</li><li>JS 会阻塞后面的 DOM 解析</li></ul><p>为了避免这种情况，应该以下原则：</p><ul><li>CSS 资源排在 JavaScript 资源前面</li><li>JS 放在 HTML 最底部，也就是 </body> 前</li></ul><p>另外，如果要改变阻塞模式，可以使用 defer 与 async，详见：<a href="https://github.com/xiaoyu2er/blog/issues/8" target="_blank" rel="noopener">这篇文章</a></p><p>###¥ 佈局与绘製</p><p>确定渲染树种所有节点的几何属性，比如：位置、大小等等，最后输入一个盒子模型，它能精準地捕获到每个元素在屏幕内的準确位置与大小。</p><p>然后遍歷渲染树，调用渲染器的 paint () 方法在屏幕上显示其内容。</p><p>###¥ 合併渲染层</p><p>把以上绘製的所有图片合併，最终输出一张图片。</p><p>###¥ 迴流与重绘</p><p><strong>迴流 (reflow)</strong></p><p>当浏览器发现某个部分发现变化影响了佈局时，需要倒回去重新渲染，会从 html 标籤开始递归往下，重新计算位置和大小。</p><p>reflow 基本是无法避免的，因为当你滑动一下鼠标、resize 窗口，页面就会产生变化。</p><p><strong>重绘 (repaint)</strong></p><p>改变了某个元素的背景色、文字颜色等等不会影响周围元素的位置变化时，就会发生重绘。</p><p>每次重绘后，浏览器还需要合併渲染层并输出到屏幕上。</p><p>迴流的成本要比重绘高很多，所以我们应该儘量避免产生迴流。</p><p>比如：</p><ul><li>display:none 会触发迴流，而 visibility:hidden 只会触发重绘。</li></ul><h4 id="javascript-编译执行"><a class="markdownIt-Anchor" href="#javascript-编译执行"></a> JavaScript 编译执行</h4><p>可以分为三个阶段：</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/img/W123hatnURLinthebr678678.png" alt="W123hatnURLinthebr678678" /></p><h5 id="词法分析"><a class="markdownIt-Anchor" href="#词法分析"></a> 词法分析</h5><p>JS 脚本加载完毕后，会首先进入语法分析阶段，它首先会分析代码块的语法是否正确，不正确则抛出 “语法错误”，停止执行。</p><p>几个步骤：</p><ul><li>分词，例如将 var a = 2，，分成 var、a、=、2 这样的词法单元。</li><li>解析，将词法单元转换成抽象语法树（AST）。</li><li>代码生成，将抽象语法树转换成机器指令。</li></ul><h5 id="预编译"><a class="markdownIt-Anchor" href="#预编译"></a> 预编译</h5><p>JS 有三种运行环境：</p><ul><li>全局环境</li><li>函数环境</li><li>eval</li></ul><p>每进入一个不同的运行环境都会创建一个对应的执行上下文，根据不同的上下文环境，形成一个函数调用栈，栈底永远是全局执行上下文，栈顶则永远是当前执行上下文。</p><p>创建执行上下文</p><p>创建执行上下文的过程中，主要做了以下三件事：</p><ul><li>创建变量对象<ul><li>参数、函数、变量</li></ul></li><li>建立作用域链<ul><li>确认当前执行环境是否能访问变量</li></ul></li><li>确定 This 指向</li></ul><h5 id="执行"><a class="markdownIt-Anchor" href="#执行"></a> 执行</h5><p><strong>JS 线程</strong></p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/img/Wzxc123nasdqwdsc.png" alt="Wzxc123nasdqwdsc" /></p><p>虽然 JS 是单线程的，但实际上参与工作的线程一共有四个：</p><blockquote><p>其中三个只是协助，只有 JS 引擎线程是真正执行的</p></blockquote><ul><li>JS 引擎线程：也叫 JS 内核，负责解析执行 JS 脚本程序的主线程，例如 V8 引擎</li><li>事件触发线程：属于浏览器内核线程，主要用于控制事件，例如鼠标、键盘等，当事件被触发时，就会把事件的处理函数推进事件队列，等待 JS 引擎线程执行</li><li>定时器触发线程：主要控制 setInterval 和 setTimeout，用来计时，计时完毕后，则把定时器的处理函数推进事件队列中，等待 JS 引擎线程。</li><li>HTTP 异步请求线程：通过 XMLHttpRequest 连接后，通过浏览器新开的一个线程，监控 readyState 状态变更时，如果设置了该状态的回调函数，则将该状态的处理函数推进事件队列中，等待 JS 引擎线程执行。</li></ul><p>注：浏览器对同一域名的併发连接数是有限的，通常为 6 个。</p><p><strong>宏任务</strong></p><p>分为：</p><ul><li>同步任务：按照顺序执行，只有前一个任务完成后，才能执行后一个任务</li><li>异步任务：不直接执行，只有满足触发条件时，相关的线程将该异步任务推进任务队列中，等待 JS 引擎主线程上的任务执行完毕时才开始执行，例如异步 Ajax、DOM 事件，setTimeout 等。</li></ul><p><strong>微任务</strong></p><p>微任务是 ES6 和 Node 环境下的，主要 API 有：Promise，process.nextTick。</p><p>微任务的执行在宏任务的同步任务之后，在异步任务之前。</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/img/Wzxc123nasdqwdsc.png" alt="Wzxc123nasdqwdsc" /></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>); <span class="comment">// 宏任务 同步</span></span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2'</span>); <span class="comment">// 宏任务 异步</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'3'</span>); <span class="comment">// 宏任务 同步</span></span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'4'</span>) <span class="comment">// 微任务</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'5'</span>) <span class="comment">// 宏任务 同步</span></span><br></pre></td></tr></table></figure><p>以上代码输出顺序为：1,3,5,4,2</p><h2 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h2><ul><li><a href="https://github.com/skyline75489/what-happens-when-zh_CN" target="_blank" rel="noopener">what-happens-when-zh_CN</a></li><li><a href="https://heyingye.github.io/2018/04/16/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/" target="_blank" rel="noopener">彻底理解浏览器的缓存机制</a></li><li><a href="https://blog.fundebug.com/2019/01/03/understand-browser-rendering/" target="_blank" rel="noopener">深入浅出浏览器渲染原理</a></li><li><a href="https://heyingye.github.io/2018/03/19/js%E5%BC%95%E6%93%8E%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/#%E9%A2%84%E7%BC%96%E8%AF%91%E9%98%B6%E6%AE%B5" target="_blank" rel="noopener">js 引擎的执行过程（一）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>静态代理+ JDK,CGLIB动态代理详解与实战</title>
      <link href="/2020/12/06/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86+%20JDK,CGLIB%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%AE%9E%E6%88%98/"/>
      <url>/2020/12/06/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86+%20JDK,CGLIB%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h2 id="代理模式"><a class="markdownIt-Anchor" href="#代理模式"></a> 代理模式</h2><p>代理模式是一种比较好的理解的设计模式。简单来说就是 <strong>我们使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。</strong></p><p><strong>代理模式的主要作用是扩展目标对象的功能，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作。</strong></p><p>举个例子：你的找了一小红来帮你问话，小红就看作是代理我的代理对象，代理的行为（方法）是问话。</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/img/20201206150121.png" alt="代理模式图解" /></p><p>代理模式有静态代理和动态代理两种实现方式，我们 先来看一下静态代理模式的实现。</p><h2 id="静态代理"><a class="markdownIt-Anchor" href="#静态代理"></a> 静态代理</h2><h3 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h3><p><strong>静态代理中，我们对目标对象的每个方法的增强都是手动完成的（*后面会具体演示代码_），非常不灵活（<em>比如接口一旦新增加方法，目标对象和代理对象都要进行修改</em>）且麻烦(_需要对每个目标类都单独写一个代理类*)。</strong> 实际应用场景非常非常少，日常开发几乎看不到使用静态代理的场景。</p><p>上面我们是从实现和应用角度来说的静态代理，从 JVM 层面来说， <strong>静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。</strong></p><h3 id="静态代理使用步骤"><a class="markdownIt-Anchor" href="#静态代理使用步骤"></a> 静态代理使用步骤</h3><ol><li>定义一个接口及其实现类；</li><li>创建一个代理类同样实现这个接口</li><li>将目标对象注注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。</li></ol><h3 id="代码示例"><a class="markdownIt-Anchor" href="#代码示例"></a> 代码示例</h3><p><strong>1.定义发送短信的接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SmsService</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">send</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.实现发送短信的接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsServiceImpl</span> <span class="keyword">implements</span> <span class="title">SmsService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">send</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"send message:"</span> + message);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.创建代理类并同样实现发送短信的接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsProxy</span> <span class="keyword">implements</span> <span class="title">SmsService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SmsService smsService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SmsProxy</span><span class="params">(SmsService smsService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.smsService = smsService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">send</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用方法之前，我们可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">"before method send()"</span>);</span><br><span class="line">        smsService.send(message);</span><br><span class="line">        <span class="comment">//调用方法之后，我们同样可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">"after method send()"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4.实际使用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SmsService smsService = <span class="keyword">new</span> SmsServiceImpl();</span><br><span class="line">        SmsProxy smsProxy = <span class="keyword">new</span> SmsProxy(smsService);</span><br><span class="line">        smsProxy.send(<span class="string">"java"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上述代码之后，控制台打印出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">before method send()</span><br><span class="line">send message:java</span><br><span class="line">after method send()</span><br></pre></td></tr></table></figure><p>可以输出结果看出，我们已经增加了 <code>SmsServiceImpl</code> 的<code>send()</code>方法。</p><h2 id="动态代理"><a class="markdownIt-Anchor" href="#动态代理"></a> 动态代理</h2><p>相比于静态代理来说，动态代理更加灵活。我们不需要针对每个目标类都单独创建一个代理类，并且也不需要我们必须实现接口，我们可以直接代理实现类( <em>CGLIB 动态代理机制</em>)。</p><p><strong>从 JVM 角度来说，动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</strong></p><p>说到动态代理，Spring AOP、RPC 框架应该是两个不得不的提的，它们的实现都依赖了动态代理。</p><p><strong>动态代理在我们日常开发中使用的相对较小，但是在框架中的几乎是必用的一门技术。学会了动态代理之后，对于我们理解和学习各种框架的原理也非常有帮助。</strong></p><p>就 Java 来说，动态代理的实现方式有很多种，比如 <strong>JDK 动态代理</strong>、<strong>CGLIB 动态代理</strong>等等。</p><h3 id="jdk-动态代理机制"><a class="markdownIt-Anchor" href="#jdk-动态代理机制"></a> JDK 动态代理机制</h3><h4 id="介绍-2"><a class="markdownIt-Anchor" href="#介绍-2"></a> 介绍</h4><p><strong>在 Java 动态代理机制中 <code>InvocationHandler</code> 接口和 <code>Proxy</code> 类是核心。</strong></p><p><code>Proxy</code> 类中使用频率最高的方法是：<code>newProxyInstance()</code> ，这个方法主要用来生成一个代理对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          InvocationHandler h)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个方法一共有 3 个参数：</p><ol><li><strong>loader</strong> :类加载器，用于加载代理对象。</li><li><strong>interfaces</strong> : 被代理类实现的一些接口；</li><li><strong>h</strong> : 实现了 <code>InvocationHandler</code> 接口的对象；</li></ol><p>要实现动态代理的话，还必须需要实现<code>InvocationHandler</code> 来自定义处理逻辑。 当我们的动态代理对象调用一个方法时候，这个方法的调用就会被转发到实现<code>InvocationHandler</code> 接口类的 <code>invoke</code> 方法来调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当你使用代理对象调用方法的时候实际会调用到这个方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>invoke()</code> 方法有下面三个参数：</p><ol><li><strong>proxy</strong> :动态生成的代理类</li><li><strong>method</strong> : 与代理类对象调用的方法相对应</li><li><strong>args</strong> : 当前 method 方法的参数</li></ol><p>也就是说：<strong>你通过<code>Proxy</code> 类的 <code>newProxyInstance()</code> 创建的代理对象在调用方法的时候，实际会调用到实现<code>InvocationHandler</code> 接口的类的 <code>invoke()</code>方法。</strong> 你可以在 <code>invoke()</code> 方法中自定义处理逻辑，比如在方法执行前后做什么事情。</p><h4 id="jdk-动态代理类使用步骤"><a class="markdownIt-Anchor" href="#jdk-动态代理类使用步骤"></a> JDK 动态代理类使用步骤</h4><ol><li>定义一个接口及其实现类；</li><li>自定义 <code>InvocationHandler</code> 并重写<code>invoke</code>方法，在 <code>invoke</code> 方法中我们会调用原生方法（被代理类的方法）并自定义一些处理逻辑；</li><li>通过 <code>Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</code> 方法创建代理对象；</li></ol><h4 id="代码示例-2"><a class="markdownIt-Anchor" href="#代码示例-2"></a> 代码示例</h4><p><strong>1.定义发送短信的接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SmsService</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">send</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.实现发送短信的接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsServiceImpl</span> <span class="keyword">implements</span> <span class="title">SmsService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">send</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"send message:"</span> + message);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.定义一个 JDK 动态代理类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shuang.kou</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createTime</span> 2020年05月11日 11:23:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DebugInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代理类中的真实对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DebugInvocationHandler</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class="line">        <span class="comment">//调用方法之前，我们可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">"before method "</span> + method.getName());</span><br><span class="line">        Object result = method.invoke(target, args);</span><br><span class="line">        <span class="comment">//调用方法之后，我们同样可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">"after method "</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>invoke()</code> 方法: 当我们的动态代理对象调用原生方法的时候，最终实际上调用到的是 <code>invoke()</code> 方法，然后 <code>invoke()</code> 方法代替我们去调用了被代理对象的原生方法。</p><p><strong>4.获取代理对象的工厂类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkProxyFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getProxy</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">                target.getClass().getClassLoader(), <span class="comment">// 目标类的类加载</span></span><br><span class="line">                target.getClass().getInterfaces(),  <span class="comment">// 代理需要实现的接口，可指定多个</span></span><br><span class="line">                <span class="keyword">new</span> DebugInvocationHandler(target)   <span class="comment">// 代理对象对应的自定义 InvocationHandler</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getProxy()</code> ：主要通过<code>Proxy.newProxyInstance（）</code>方法获取某个类的代理对象</p><p><strong>5.实际使用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SmsService smsService = (SmsService) JdkProxyFactory.getProxy(<span class="keyword">new</span> SmsServiceImpl());</span><br><span class="line">smsService.send(<span class="string">"java"</span>);</span><br></pre></td></tr></table></figure><p>运行上述代码之后，控制台打印出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">before method send</span><br><span class="line">send message:java</span><br><span class="line">after method send</span><br></pre></td></tr></table></figure><h3 id="cglib-动态代理机制"><a class="markdownIt-Anchor" href="#cglib-动态代理机制"></a> CGLIB 动态代理机制</h3><h4 id="介绍-3"><a class="markdownIt-Anchor" href="#介绍-3"></a> 介绍</h4><p><strong>JDK 动态代理有一个最致命的问题是其只能代理实现了接口的类。</strong></p><p><strong>为了解决这个问题，我们可以用 CGLIB 动态代理机制来避免。</strong></p><p><a href="https://github.com/cglib/cglib" target="_blank" rel="noopener">CGLIB</a>(<em>Code Generation Library</em>)是一个基于<a href="http://www.baeldung.com/java-asm" target="_blank" rel="noopener">ASM</a>的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB 通过继承方式实现代理。很多知名的开源框架都使用到了<a href="https://github.com/cglib/cglib" target="_blank" rel="noopener">CGLIB</a>， 例如 Spring 中的 AOP 模块中：如果目标对象实现了接口，则默认采用 JDK 动态代理，否则采用 CGLIB 动态代理。</p><p><strong>在 CGLIB 动态代理机制中 <code>MethodInterceptor</code> 接口和 <code>Enhancer</code> 类是核心。</strong></p><p>你需要自定义 <code>MethodInterceptor</code> 并重写 <code>intercept</code> 方法，<code>intercept</code> 用于拦截增强被代理类的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodInterceptor</span></span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">Callback</span></span>&#123;</span><br><span class="line">    <span class="comment">// 拦截被代理类中的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, java.lang.reflect.Method method, Object[] args,</span></span></span><br><span class="line"><span class="function"><span class="params">                               MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>obj</strong> :被代理的对象（需要增强的对象）</li><li><strong>method</strong> :被拦截的方法（需要增强的方法）</li><li><strong>args</strong> :方法入参</li><li><strong>methodProxy</strong> :用于调用原始方法</li></ol><p>你可以通过 <code>Enhancer</code>类来动态获取被代理类，当代理类调用方法的时候，实际调用的是 <code>MethodInterceptor</code>中的 <code>intercept</code> 方法。</p><h4 id="cglib-动态代理类使用步骤"><a class="markdownIt-Anchor" href="#cglib-动态代理类使用步骤"></a> CGLIB 动态代理类使用步骤</h4><ol><li>定义一个类；</li><li>自定义 <code>MethodInterceptor</code> 并重写 <code>intercept</code> 方法，<code>intercept</code> 用于拦截增强被代理类的方法，和 JDK 动态代理中的 <code>invoke</code> 方法类似；</li><li>通过 <code>Enhancer</code> 类的 <code>create()</code>创建代理类；</li></ol><h4 id="代码示例-3"><a class="markdownIt-Anchor" href="#代码示例-3"></a> 代码示例</h4><p>不同于 JDK 动态代理不需要额外的依赖。<a href="https://github.com/cglib/cglib" target="_blank" rel="noopener">CGLIB</a>(<em>Code Generation Library</em>) 实际是属于一个开源项目，如果你要使用它的话，需要手动添加相关依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>1.实现一个使用阿里云发送短信的类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> github.javaguide.dynamicProxy.cglibDynamicProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AliSmsService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">send</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"send message:"</span> + message);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.自定义 <code>MethodInterceptor</code>（方法拦截器）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义MethodInterceptor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DebugMethodInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o           被代理的对象（需要增强的对象）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method      被拦截的方法（需要增强的方法）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args        方法入参</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodProxy 用于调用原始方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//调用方法之前，我们可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">"before method "</span> + method.getName());</span><br><span class="line">        Object object = methodProxy.invokeSuper(o, args);</span><br><span class="line">        <span class="comment">//调用方法之后，我们同样可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">"after method "</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.获取代理类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxyFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getProxy</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建动态代理增强类</span></span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">// 设置类加载器</span></span><br><span class="line">        enhancer.setClassLoader(clazz.getClassLoader());</span><br><span class="line">        <span class="comment">// 设置被代理类</span></span><br><span class="line">        enhancer.setSuperclass(clazz);</span><br><span class="line">        <span class="comment">// 设置方法拦截器</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> DebugMethodInterceptor());</span><br><span class="line">        <span class="comment">// 创建代理类</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4.实际使用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AliSmsService aliSmsService = (AliSmsService) CglibProxyFactory.getProxy(AliSmsService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">aliSmsService.send(<span class="string">"java"</span>);</span><br></pre></td></tr></table></figure><p>运行上述代码之后，控制台打印出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">before method send</span><br><span class="line">send message:java</span><br><span class="line">after method send</span><br></pre></td></tr></table></figure><h3 id="jdk-动态代理和-cglib-动态代理对比"><a class="markdownIt-Anchor" href="#jdk-动态代理和-cglib-动态代理对比"></a> JDK 动态代理和 CGLIB 动态代理对比</h3><ol><li><strong>JDK 动态代理只能只能代理实现了接口的类，而 CGLIB 可以代理未实现任何接口的类。</strong> 另外， CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。</li><li>就二者的效率来说，大部分情况都是 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势更加明显。</li></ol><h2 id="静态代理和动态代理的对比"><a class="markdownIt-Anchor" href="#静态代理和动态代理的对比"></a> 静态代理和动态代理的对比</h2><ol><li><strong>灵活性</strong> ：动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。另外，静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的！</li><li><strong>JVM 层面</strong> ：静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</li></ol><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>这篇文章中主要介绍了代理模式的两种实现：静态代理以及动态代理。涵盖了静态代理和动态代理实战、静态代理和动态代理的区别、JDK 动态代理和 Cglib 动态代理区别等内容。</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代理模式 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka消息中间件到底会不会丢消息</title>
      <link href="/2020/12/04/Kafka%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%88%B0%E5%BA%95%E4%BC%9A%E4%B8%8D%E4%BC%9A%E4%B8%A2%E6%B6%88%E6%81%AF/"/>
      <url>/2020/12/04/Kafka%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%88%B0%E5%BA%95%E4%BC%9A%E4%B8%8D%E4%BC%9A%E4%B8%A2%E6%B6%88%E6%81%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="kafka消息中间件到底会不会丢消息"><a class="markdownIt-Anchor" href="#kafka消息中间件到底会不会丢消息"></a> Kafka消息中间件到底会不会丢消息</h2><p>大型互联网公司一般都会要求消息传递最大限度的不丢失，比如用户服务给代金券服务发送一个消息，如果消息丢失会造成用户未收到应得的代金券，最终用户会投诉。</p><p>为避免上面类似情况的发生，除了做好补偿措施，更应该在系设计的时候充分考虑各种异常，设计一个稳定、高可用的消息系统。</p><h2 id="认识kafka"><a class="markdownIt-Anchor" href="#认识kafka"></a> 认识Kafka</h2><p>看一下维基百科的定义</p><blockquote><p>Kafka是分布式发布-订阅消息系统。它最初由LinkedIn公司开发，之后成为Apache项目的一部分。</p><p>Kafka是一个分布式的，可划分的，冗余备份的持久性的日志服务。它主要用于处理活跃的流式数据。</p></blockquote><p><strong>kafka架构</strong></p><p>Kafka的整体架构非常简单，是显式分布式架构，主要由producer、broker（kafka）和consumer组成。</p><p><img src= "/img/loading.gif" data-src="https://gitee.com/ID_wangqiang/MyImage/raw/master/img//20201118144939.png" alt="" /></p><p><strong>Producer</strong>（生产者）可以将数据发布到所选择的topic（主题）中。生产者负责将记录分配到topic的哪一个 partition（分区）中。可以使用循环的方式来简单地实现负载均衡，也可以根据某些语义分区函数(如记录中的key)来完成。</p><p><strong>Consumer</strong>（消费者）使用一个consumer group（消费组）名称来进行标识，发布到topic中的每条记录被分配给订阅消费组中的一个消费者实例。消费者实例可以分布在多个进程中或者多个机器上。</p><h2 id="kafka到底会不会丢失消息"><a class="markdownIt-Anchor" href="#kafka到底会不会丢失消息"></a> Kafka到底会不会丢失消息？</h2><p>在讨论kafka是否丢消息前先来了解一下什么是<strong>消息传递语义</strong>。</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/img/20201118145540.png" alt="" /></p><p>message delivery semantic 也就是消息传递语义，简单说就是消息传递过程中消息传递的保证性。主要分为三种：</p><ul><li><strong>at most once</strong>：最多一次。消息可能丢失也可能被处理，但最多只会被处理一次。</li><li><strong>at least once</strong>：至少一次。消息不会丢失，但可能被处理多次。可能重复，不会丢失。</li><li><strong>exactly once</strong>：精确传递一次。消息被处理且只会被处理一次。不丢失不重复就一次。</li></ul><p>理想情况下肯定是希望系统的消息传递是严格exactly once，也就是保证不丢失、只会被处理一次，但是很难做到。</p><p>回到主角Kafka，Kafka有三次消息传递的过程：</p><ol><li>生产者发消息给Kafka Broker。</li><li>Kafka Broker 消息同步和持久化</li><li>Kafka Broker 将消息传递给消费者。</li></ol><p>在这三步中每一步都有可能会丢失消息，下面详细分析为什么会丢消息，如何最大限度避免丢失消息。</p><h2 id="生产者丢失消息"><a class="markdownIt-Anchor" href="#生产者丢失消息"></a> 生产者丢失消息</h2><p>先介绍一下生产者发送消息的一般流程（部分流程与具体配置项强相关，这里先忽略）：</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/img/20201118145821.png" alt="" /></p><ol><li>生产者是与leader直接交互，所以先从集群获取topic对应分区的leader元数据；</li><li>获取到leader分区元数据后直接将消息发给过去；</li><li>Kafka Broker对应的leader分区收到消息后写入文件持久化；</li><li>Follower拉取Leader消息与Leader的数据保持一致；</li><li>Follower消息拉取完毕需要给Leader回复ACK确认消息；</li><li>Kafka Leader和Follower分区同步完，Leader分区会给生产者回复ACK确认消息。</li></ol><p>生产者采用push模式将数据发布到broker，每条消息追加到分区中，顺序写入磁盘。消息写入Leader后，Follower是主动与Leader进行同步。</p><p>Kafka消息发送有两种方式：同步（sync）和异步（async），默认是同步方式，可通过producer.type属性进行配置。</p><p>Kafka通过配置request.required.acks属性来确认消息的生产：</p><ul><li>0表示不进行消息接收是否成功的确认；不能保证消息是否发送成功，生成环境基本不会用。</li><li>1表示当Leader接收成功时确认；只要Leader存活就可以保证不丢失，保证了吞吐量。</li><li>-1或者all表示Leader和Follower都接收成功时确认；可以最大限度保证消息不丢失，但是吞吐量低。</li></ul><p>kafka producer 的参数acks 的默认值为1，所以默认的producer级别是at least once，并不能exactly once。</p><p><strong>敲黑板了，这里可能会丢消息的！</strong></p><ul><li>如果acks配置为0，发生网络抖动消息丢了，生产者不校验ACK自然就不知道丢了。</li><li>如果acks配置为1保证leader不丢，但是如果leader挂了，恰好选了一个没有ACK的follower，那也丢了。</li><li>all：保证leader和follower不丢，但是如果网络拥塞，没有收到ACK，会有重复发的问题。</li></ul><h2 id="kafka-broker丢失消息"><a class="markdownIt-Anchor" href="#kafka-broker丢失消息"></a> Kafka Broker丢失消息</h2><p>Kafka Broker 接收到数据后会将数据进行持久化存储，你以为是下面这样的：</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/img/20201118150608.png" alt="消息持久化，无cache" /></p><p>没想到是这样的：</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/img/20201118150656.png" alt="消息持久化，有cache" /></p><p>操作系统本身有一层缓存，叫做 Page Cache，当往磁盘文件写入的时候，系统会先将数据流写入缓存中，至于什么时候将缓存的数据写入文件中是由操作系统自行决定。</p><p>Kafka提供了一个参数 producer.type 来控制是不是主动flush，如果Kafka写入到mmap之后就立即 flush 然后再返回 Producer 叫同步 (sync)；写入mmap之后立即返回 Producer 不调用 flush 叫异步 (async)。</p><p><strong>敲黑板了，这里可能会丢消息的！</strong></p><p>Kafka通过多分区多副本机制中已经能最大限度保证数据不会丢失，如果数据已经写入系统 cache 中但是还没来得及刷入磁盘，此时突然机器宕机或者掉电那就丢了，当然这种情况很极端。</p><h2 id="消费者丢失消息"><a class="markdownIt-Anchor" href="#消费者丢失消息"></a> 消费者丢失消息</h2><p>消费者通过pull模式主动的去 kafka 集群拉取消息，与producer相同的是，消费者在拉取消息的时候也是找leader分区去拉取。</p><p>多个消费者可以组成一个消费者组（consumer group），每个消费者组都有一个组id。同一个消费组者的消费者可以消费同一topic下不同分区的数据，但是不会出现多个消费者消费同一分区的数据。</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/img/20201118150844.png" alt="消费者群组消费消息" /></p><p>消费者消费的进度通过offset保存在kafka集群的__consumer_offsets这个topic中。</p><p>消费消息的时候主要分为两个阶段：</p><p>1、标识消息已被消费，commit offset坐标；</p><p>2、处理消息。</p><p><strong>敲黑板了，这里可能会丢消息的！</strong></p><p>场景一：先commit再处理消息。如果在处理消息的时候异常了，但是offset 已经提交了，这条消息对于该消费者来说就是丢失了，再也不会消费到了。</p><p>场景二：先处理消息再commit。如果在commit之前发生异常，下次还会消费到该消息，重复消费的问题可以通过业务保证消息幂等性来解决。</p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>那么问题来了，kafka到底会不会丢消息？答案是：会！</p><p>Kafka可能会在三个阶段丢失消息：</p><p>（1）生产者发送数据；</p><p>（2）Kafka Broker 存储数据；</p><p>（3）消费者消费数据；</p><p>在生产环境中严格做到exactly once其实是难的，同时也会牺牲效率和吞吐量，最佳实践是业务侧做好补偿机制，万一出现消息丢失可以兜底。</p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kafka </tag>
            
            <tag> 消息中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka 如何做到支持百万级 TPS ？</title>
      <link href="/2020/11/30/Kafka%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E6%94%AF%E6%8C%81%E7%99%BE%E4%B8%87%E7%BA%A7TPS%EF%BC%9F/"/>
      <url>/2020/11/30/Kafka%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E6%94%AF%E6%8C%81%E7%99%BE%E4%B8%87%E7%BA%A7TPS%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="kafka-如何做到支持百万级-tps"><a class="markdownIt-Anchor" href="#kafka-如何做到支持百万级-tps"></a> Kafka 如何做到支持百万级 TPS ？</h2><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImheg@master/img/20201205112006.webp" alt="Kafka" /></p><p>谈到大数据传输都会想到 Kafka，Kafka 号称大数据的杀手锏，在业界有很多成熟的应用场景并且被主流公司认可。这款为大数据而生的消息中间件，以其百万级TPS的吞吐量名声大噪，迅速成为大数据领域的宠儿，在数据采集、传输、存储的过程中发挥着举足轻重的作用。</p><p>在业界已经有很多成熟的消息中间件如：RabbitMQ, RocketMQ, ActiveMQ, ZeroMQ，为什么 Kafka 在众多的敌手中依然能有一席之地，当然靠的是其强悍的吞吐量。下面带领大家来揭秘。</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/img/20201205112104.png" alt="Kafka 支持百万TPS的秘密" /></p><h3 id="顺序读写磁盘"><a class="markdownIt-Anchor" href="#顺序读写磁盘"></a> 顺序读写磁盘</h3><p>生产者写入数据和消费者读取数据都是<strong>顺序读写</strong>的，先来一张图直观感受一下顺序读写和随机读写的速度</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/img/20201205112153.png" alt="顺序读写 VS 随机读写" /></p><p>从图中可以看出传统硬盘或者SSD的顺序读写甚至超过了内存的随机读写，当然与内存的顺序读写对比差距还是很大。</p><p>所以Kafka选择顺序读写磁盘也不足为奇了。</p><p>下面以传统机械磁盘为例详细介绍一下什么是顺序读写和随机读写。</p><p><strong>盘片</strong>和<strong>盘面</strong>：一块硬盘一般有多块盘片，盘片分为上下两面，其中有效面称为盘面，一般上下都有效，也就是说：<strong>盘面数 = 盘片数 * 2。</strong></p><p><strong>磁头</strong>：磁头切换磁道读写数据时是通过机械设备实现的，一般速度较慢；而磁头切换盘面读写数据是通过电子设备实现的，一般速度较快，因此磁头一般是先读写完柱面后才开始寻道的(不用切换磁道)，这样磁盘读写效率更快。</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/img/20201205112235.png" alt="传统机械磁盘" /></p><p><strong>磁道</strong>：磁道就是以中间轴为圆心的圆环，一个盘面有多个磁道，磁道之间有间隙，磁道也就是磁盘存储数据的介质。磁道上布有一层磁介质，通过磁头可以使磁介质的极性转换为数据信号，即磁盘的读，磁盘写刚好与之相反。</p><p><strong>柱面</strong>：磁盘中不同盘面中半径相同的磁道组成的，也就是说柱面总数 = 某个盘面的磁道数。</p><p><strong>扇区</strong>：单个磁道就是多个弧形扇区组成的，盘面上的每个磁道拥有的扇区数量是相等。扇区是最小存储单元，一般扇区大小为512bytes。</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/img/20201205112313.png" alt="单盘片示意图" /></p><p>如果系统每次只读取一个扇区，那恐怕效率太低了，所以出现了block（块）的概念。文件读取的最小单位是block，根据不同操作系统一个block一般由多个扇区组成。</p><p>有了磁盘的背景知识我们就可以很容易理解顺序读写和随机读写了。</p><blockquote><p>维基百科定义：</p><p><strong>顺序读写</strong>：是一种按记录的逻辑顺序进行读、写操作的存取方法 ，即按照信息在存储器中的实际位置所决定的顺序使用信息。</p><p><strong>随机读写</strong>：指的是当存储器中的消息被读取或写入时，所需要的时间与这段信息所在的位置无关。</p></blockquote><p>当读取第一个block时，要经历寻道、旋转延迟、传输三个步骤才能读取完这个block的数据。而对于下一个block，如果它在磁盘的其他任意位置，访问它会同样经历寻道、旋转、延时、传输才能读取完这个block的数据，我们把这种方式叫做<strong>随机读写</strong>。但是如果这个block的起始扇区刚好在刚才访问的block的后面，磁头就能立刻遇到，不需等待直接传输，这种就叫<strong>顺序读写</strong>。</p><p>好，我们再回到 Kafka，详细介绍Kafka如何实现顺序读写入数据。</p><p>Kafka 写入数据是顺序的，下面每一个Partition 都可以当做一个文件，每次接收到新数据后Kafka会把数据插入到文件末尾，虚框部分代表文件尾。</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/img/20201205112435.png" alt="顺序写" /></p><p>这种方法有一个问题就是删除数据不方便，所以 Kafka 一般会把所有的数据都保留下来，每个消费者（Consumer）对每个Topic都有一个 offset 用来记录读取进度或者叫坐标。</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/img/20201205112519.png" alt="顺序读" /></p><h3 id="memory-mapped-filesmmap"><a class="markdownIt-Anchor" href="#memory-mapped-filesmmap"></a> Memory Mapped Files(MMAP)</h3><p>在文章开头我们看到硬盘的顺序读写基本能与内存随机读写速度媲美，但是与内存顺序读写相比还是太慢了，那 Kafka 如果有追求想进一步提升效率怎么办？可以使用现代操作系统分页存储来充分利用内存提高I/O效率，这也是下面要介绍的 MMAP 技术。</p><p><strong>MMAP</strong>也就是<strong>内存映射文件</strong>，在64位操作系统中一般可以表示 20G 的数据文件，它的工作原理是直接利用操作系统的 Page 来实现文件到物理内存的直接映射，完成映射之后对物理内存的操作会被同步到硬盘上。</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/img/20201205112628.png" alt="MMAP原理" /></p><p>通过<strong>MMAP</strong>技术进程可以像读写硬盘一样读写内存（逻辑内存），不必关心内存的大小，因为有虚拟内存兜底。这种方式可以获取很大的I/O提升，省去了用户空间到内核空间复制的开销。</p><p>也有一个很明显的缺陷，写到<strong>MMAP</strong>中的数据并没有被真正的写到硬盘，操作系统会在程序主动调用 flush 的时候才把数据真正的写到硬盘。</p><p>Kafka提供了一个参数：producer.type 来控制是不是主动 flush，如果Kafka写入到MMAP之后就立即flush然后再返回Producer叫同步(sync)；写入MMAP之后立即返回Producer不调用flush叫异步(async)。</p><h3 id="zero-copy零拷贝"><a class="markdownIt-Anchor" href="#zero-copy零拷贝"></a> Zero Copy（零拷贝）</h3><p>Kafka 另外一个黑技术就是使用了零拷贝，要想深刻理解零拷贝必须得知道什么是DMA。</p><p><strong>什么是DMA?</strong></p><p>众所周知 CPU 的速度与磁盘 IO 的速度比起来相差几个数量级，可以用乌龟和火箭做比喻。</p><p>一般来说 IO 操作都是由 CPU 发出指令，然后等待 IO 设备完成操作后返回，那CPU会有大量的时间都在等待IO操作。</p><p>但是CPU 的等待在很多时候并没有太多的实际意义，我们对于 I/O 设备的大量操作其实都只是把内存里面的数据传输到 I/O 设备而已。比如进行大文件复制，如果所有数据都要经过 CPU，实在是有点儿太浪费时间了。</p><p>基于此就有了DMA技术，翻译过来也就是直接内存访问（Direct Memory Access），有了这个可以减少 CPU 的等待时间。</p><p><strong>Kafka 零拷贝原理</strong></p><p>如果不使用零拷贝技术，消费者（consumer）从Kafka消费数据，Kafka从磁盘读数据然后发送到网络上去，数据一共发生了四次传输的过程。其中两次是 DMA 的传输，另外两次，则是通过 CPU 控制的传输。</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/img/20201205112747.png" alt="四次传输过程" /></p><p><strong>第一次传输</strong>：从硬盘上将数据读到操作系统内核的缓冲区里，这个传输是通过 DMA 搬运的。</p><p><strong>第二次传输</strong>：从内核缓冲区里面的数据复制到分配的内存里面，这个传输是通过 CPU 搬运的。</p><p><strong>第三次传输</strong>：从分配的内存里面再写到操作系统的 Socket 的缓冲区里面去，这个传输是由 CPU 搬运的。</p><p><strong>第四次传输</strong>：从 Socket 的缓冲区里面写到网卡的缓冲区里面去，这个传输是通过 DMA 搬运的。</p><p>实际上在kafka中只进行了两次数据传输，如下图：</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/img/20201205112840.png" alt="两次传输，零拷贝技术" /></p><p><strong>第一次传输</strong>：通过 DMA从硬盘直接读到操作系统内核的读缓冲区里面。</p><p><strong>第二次传输</strong>：根据 Socket 的描述符信息直接从读缓冲区里面写入到网卡的缓冲区里面。</p><p>我们可以看到同一份数据的传输次数从四次变成了两次，并且没有通过 CPU 来进行数据搬运，所有的数据都是通过 DMA 来进行传输的。没有在内存层面去复制（Copy）数据，这个方法称之为<strong>零拷贝（Zero-Copy）。</strong></p><p>无论传输数据量的大小，传输同样的数据使用了零拷贝能够缩短 65% 的时间，大幅度提升了机器传输数据的吞吐量，这也是Kafka能够支持百万TPS的一个重要原因。</p><h3 id="batch-data数据批量处理"><a class="markdownIt-Anchor" href="#batch-data数据批量处理"></a> Batch Data（数据批量处理）</h3><p>当消费者（consumer）需要消费数据时，首先想到的是消费者需要一条，kafka发送一条，消费者再要一条kafka再发送一条。但实际上 Kafka 不是这样做的，Kafka 耍小聪明了。</p><p>Kafka 把所有的消息都存放在一个一个的文件中，当消费者需要数据的时候 Kafka 直接把文件发送给消费者。比如说100万条消息放在一个文件中可能是10M的数据量，如果消费者和Kafka之间网络良好，10MB大概1秒就能发送完，既100万TPS，Kafka每秒处理了10万条消息。</p><p>看到这里你可以有疑问了，消费者只需要一条消息啊，kafka把整个文件都发送过来了，文件里面剩余的消息怎么办？不要忘了消费者可以通过offset记录消费进度。</p><p>发送文件还有一个好处就是可以对文件进行批量压缩，减少网络IO损耗。</p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>最后再总结一下 Kafka 支持百万级 TPS 的秘密：</p><p>（1）顺序写入数据，在 Partition 末尾追加，所以速度最优。</p><p>（2）使用 MMAP 技术将磁盘文件与内存映射，Kafka 可以像操作磁盘一样操作内存。</p><p>（3）通过 DMA 技术实现零拷贝，减少数据传输次数。</p><p>（4）读取数据时配合sendfile直接暴力输出，批量压缩把所有消息变成一个批量文件，合理减少网络IO损耗。</p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kafka </tag>
            
            <tag> 消息中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 30. 包含min函数的栈</title>
      <link href="/2020/09/08/%E5%89%91%E6%8C%87-Offer-30-%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/"/>
      <url>/2020/09/08/%E5%89%91%E6%8C%87-Offer-30-%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h3 id="题目信息"><a class="markdownIt-Anchor" href="#题目信息"></a> 题目信息</h3><ul><li><p>题目：剑指 Offer 30. 包含min函数的栈</p></li><li><p>时间： 2020-09-08</p></li><li><p>题目链接：<a href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/" target="_blank" rel="noopener">Leetcode</a></p></li><li><p>tag：栈</p></li><li><p>难易程度：简单</p></li><li><p>题目描述：</p><p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p></li></ul><p><strong>示例:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MinStack minStack = new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.min();   --&gt; 返回 -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 0.</span><br><span class="line">minStack.min();   --&gt; 返回 -2.</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><blockquote><p>本题难点</p></blockquote><p>普通栈的 push() 和 pop() 函数的复杂度为 O(1)；而获取栈最小值 min() 函数需要遍历整个栈，复杂度为 O(N)。</p><blockquote><p>具体思路</p></blockquote><p>将 min() 函数复杂度降为 O(1) ，可通过建立辅助栈实现；</p><ul><li><p>数据栈dataStack ： 栈 dataStack用于存储所有元素，保证入栈 push() 函数、出栈 pop() 函数、获取栈顶 top() 函数的正常逻辑。</p></li><li><p>辅助栈 minStack： 栈 minStack 中存储栈 dataStack 中所有 非严格降序 的元素，则栈 dataStack 中的最小元素始终对应栈 minStack 的栈顶元素，即 min() 函数只需返回栈minStack 的栈顶元素即可。</p></li><li><p>因此，只需设法维护好栈 minStack 的元素，使其保持非严格降序，即可实现 <code>min()</code> 函数的 O(1)复杂度。</p></li></ul><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; dataStack,minStack;</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dataStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        minStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        dataStack.push(x);</span><br><span class="line">       <span class="comment">//如果辅助栈为空 或者 辅助栈的栈顶元素小于当前元素 </span></span><br><span class="line">        <span class="keyword">if</span>(minStack.empty() || minStack.peek() &gt;= x)&#123;</span><br><span class="line">           <span class="comment">//将当前元素压入辅助栈中，保持辅助栈栈顶元素为最小值</span></span><br><span class="line">            minStack.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//Java 中， Stack 中存储的是 int 的包装类 Integer ，需要使用 equals() 代替 == 来比较值是否相等。</span></span><br><span class="line">         <span class="keyword">if</span>(dataStack.pop().equals(minStack.peek()))</span><br><span class="line">            minStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dataStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(1) ： push(), pop(), top(), min() 四个函数的时间复杂度均为常数级别。</li><li>空间复杂度 O(N) ： 当共有 N 个待入栈元素时，辅助栈 minStack 最差情况下存储 N 个元素，使用 O(N) 额外空间。</li></ul><h3 id="其他优秀解答"><a class="markdownIt-Anchor" href="#其他优秀解答"></a> 其他优秀解答</h3><blockquote><p>解题思路</p></blockquote><p>如果当前压入的值比当前最小值，则压入一个当前最小值，再压入当前的值！</p><blockquote><p>代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先压先前最小值</span></span><br><span class="line">        <span class="comment">//再压一个当前最小值，保证最小值一直存在</span></span><br><span class="line">        <span class="keyword">if</span>(x &lt;= min)&#123;</span><br><span class="line">            stack.push(min);</span><br><span class="line">            min = x;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack.pop() == min)&#123;</span><br><span class="line">            min = stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 31. 栈的压入、弹出序列</title>
      <link href="/2020/09/08/%E5%89%91%E6%8C%87-Offer-31-%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/"/>
      <url>/2020/09/08/%E5%89%91%E6%8C%87-Offer-31-%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h3 id="题目信息"><a class="markdownIt-Anchor" href="#题目信息"></a> 题目信息</h3><ul><li><p>题目；剑指 Offer 31. 栈的压入、弹出序列</p></li><li><p>时间： 2020-09-08</p></li><li><p>题目链接：<a href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/" target="_blank" rel="noopener">Leetcode</a></p></li><li><p>tag：栈</p></li><li><p>难易程度：中等</p></li><li><p>题目描述：</p><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p></li></ul><p><strong>示例1:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]</span><br><span class="line">输出：true</span><br><span class="line">解释：我们可以按以下顺序执行：</span><br><span class="line">push(1), push(2), push(3), push(4), pop() -&gt; 4,</span><br><span class="line">push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1</span><br></pre></td></tr></table></figure><p><strong>示例2:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]</span><br><span class="line">输出：false</span><br><span class="line">解释：1 不能在 2 之前弹出。</span><br></pre></td></tr></table></figure><blockquote><p>提示</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 0 &lt;= pushed.length == popped.length &lt;= 1000</span><br><span class="line">2. 0 &lt;= pushed[i], popped[i] &lt; 1000</span><br><span class="line">3. pushed 是 popped 的排列。</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><blockquote><p>本题难点</p></blockquote><p>栈的数据操作具有 <strong>先入后出</strong> 的特性，因此某些弹出序列是无法实现的。</p><blockquote><p>具体思路</p></blockquote><p>给定一个压入序列 pushed 和弹出序列 popped ，则压入 / 弹出操作的顺序（即排列）是 唯一确定 的。</p><p>考虑借用一个辅助栈 stack ，模拟 压入 / 弹出操作的排列。根据是否模拟成功，即可得到结果。</p><ul><li><strong>入栈操作</strong>： 按照压栈序列的顺序执行。</li><li><strong>出栈操作</strong>： 每次入栈后，循环判断 “栈顶元素 == 弹出序列的当前元素” 是否成立，将符合弹出序列顺序的栈顶元素全部弹出。</li></ul><blockquote><p>由于题目规定 栈的所有数字均不相等 ，因此在循环入栈中，每个元素出栈的位置的可能性是唯一的（若有重复数字，则具有多个可出栈的位置）。因而，在遇到 “栈顶元素 == 弹出序列的当前元素” 就应立即执行出栈。</p></blockquote><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validateStackSequences</span><span class="params">(<span class="keyword">int</span>[] pushed, <span class="keyword">int</span>[] popped)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pushed == <span class="keyword">null</span> || popped == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//辅助栈stack</span></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">      <span class="comment">//弹出序列的索引 i</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">//遍历压栈序列： 各元素记为nums </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> nums : pushed)&#123;</span><br><span class="line">          <span class="comment">//元素nums入栈 </span></span><br><span class="line">            stack.push(nums);</span><br><span class="line">          <span class="comment">//循环出栈：若stack 的栈顶元素 == 弹出序列元素popped[i] ，则执行出栈与i++ ；</span></span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; popped[i] == stack.peek())&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//若stack 为空，则此弹出序列合法</span></span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(N) ： 其中 <em>N</em> 为列表 pushed 的长度；每个元素最多入栈与出栈一次，即最多共 2<em>N</em> 次出入栈操作。</li><li>空间复杂度 O(N) ： 辅助栈 stack 最多同时存储 <em>N</em> 个元素。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 32 - I. 从上到下打印二叉树</title>
      <link href="/2020/09/08/%E5%89%91%E6%8C%87-Offer-32-I-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2020/09/08/%E5%89%91%E6%8C%87-Offer-32-I-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h3 id="题目信息"><a class="markdownIt-Anchor" href="#题目信息"></a> 题目信息</h3><ul><li><p>题目：剑指 Offer 32 - I. 从上到下打印二叉树</p></li><li><p>时间： 2020-09-08</p></li><li><p>题目链接：<a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/" target="_blank" rel="noopener">Leetcode</a></p></li><li><p>tag：BFS（广度优先搜索） 队列</p></li><li><p>难易程度：中等</p></li><li><p>题目描述：</p><p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p></li></ul><p><strong>示例1:</strong></p><p>给定二叉树: [3,9,20,null,null,15,7],</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回：[3,9,20,15,7]</p><blockquote><p>提示</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.节点数量 <span class="tag">&lt;<span class="name">=</span> <span class="attr">1000</span></span></span><br></pre></td></tr></table></figure><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><blockquote><p>本题难点</p></blockquote><p>二叉树的 <strong>从上至下</strong> 打印（即按层打印），又称为二叉树的 <strong>广度优先搜索</strong>（BFS）。</p><blockquote><p>具体思路</p></blockquote><p>BFS 通常借助 <strong>队列</strong> 的先入先出特性来实现。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] levelOrder(TreeNode root) &#123;</span><br><span class="line">      <span class="comment">//当树的根节点为空，则直接返回空列表 [] </span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//包含根节点的队列 queue = [root] </span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">      queue.add(root);</span><br><span class="line">      <span class="comment">//包含答案的ans列表</span></span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      <span class="comment">//BFS 循环： 当队列 queue 为空时跳出</span></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">          <span class="comment">//出队： 队首元素出队，记为 t；</span></span><br><span class="line">            TreeNode t = queue.poll();</span><br><span class="line">          <span class="comment">//打印： 将 t.val 添加至列表 ans 尾部；</span></span><br><span class="line">            ans.add(t.val);</span><br><span class="line">          <span class="comment">//添加子节点： 若t的左（右）子节点不为空，则将左（右）子节点加入队列 queue ；</span></span><br><span class="line">            <span class="keyword">if</span>(t.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                queue.add(t.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(t.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                queue.add(t.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//打印结果数组 res = []</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[ans.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.size(); i++)&#123;</span><br><span class="line">            res[i] = ans.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//返回打印结果数组 res </span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(N) ： <em>N</em> 为二叉树的节点数量，即 BFS 需循环 <em>N</em> 次。</li><li>空间复杂度 O(N) ： 最差情况下，即当树为平衡二叉树时，最多有 N/2 个树节点同时在 queue中，使用 O(N) 大小的额外空间。</li></ul><h3 id="其他优秀解答"><a class="markdownIt-Anchor" href="#其他优秀解答"></a> 其他优秀解答</h3><blockquote><p>解题思路</p></blockquote><p>一般在树相关的题目中都可以考虑递归解法</p><blockquote><p>代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//新建一个临时列表 level ，用于存储所有层的列表</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; level = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="comment">//打印答案列表 res = []</span></span><br><span class="line">    List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] levelOrder(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归调用函数，从第0层开始</span></span><br><span class="line">        recur(root,<span class="number">0</span>); </span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历每层的列表</span></span><br><span class="line">        <span class="keyword">for</span>(List&lt;Integer&gt; levels : level)&#123;</span><br><span class="line">            <span class="comment">//遍历每层的元素</span></span><br><span class="line">            <span class="keyword">for</span>(Integer x : levels)&#123;</span><br><span class="line">                <span class="comment">//将元素添加到答案列表res中</span></span><br><span class="line">                ans.add(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打印结果数组 res = []</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[ans.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.size(); i++)&#123;</span><br><span class="line">            res[i] = ans.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recur</span><span class="params">(TreeNode root,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//如果列表层数小于二叉树的层数，新增当前层的列表</span></span><br><span class="line">            <span class="keyword">if</span>(level.size() &lt;= k)&#123;</span><br><span class="line">                level.add(<span class="keyword">new</span> ArrayList());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将当前层的元素添加到当前层列表中     </span></span><br><span class="line">            level.get(k).add(root.val);</span><br><span class="line">            <span class="comment">//递归调用二叉树的左子树，层数+1</span></span><br><span class="line">            recur(root.left,k+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//递归调用二叉树的右子树，层数+1</span></span><br><span class="line">            recur(root.right,k+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 队列 </tag>
            
            <tag> 广度优先搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 32 - II. 从上到下打印二叉树 II</title>
      <link href="/2020/09/08/%E5%89%91%E6%8C%87-Offer-32-II-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91-II/"/>
      <url>/2020/09/08/%E5%89%91%E6%8C%87-Offer-32-II-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91-II/</url>
      
        <content type="html"><![CDATA[<h3 id="题目信息"><a class="markdownIt-Anchor" href="#题目信息"></a> 题目信息</h3><ul><li><p>题目：剑指 Offer 32 - II. 从上到下打印二叉树 II</p></li><li><p>时间： 2020-09-08</p></li><li><p>题目链接：<a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/" target="_blank" rel="noopener">Leetcode</a></p></li><li><p>tag：  队列  BFS</p></li><li><p>难易程度：简单</p></li><li><p>题目描述：</p><p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p></li></ul><p><strong>示例1:</strong></p><p>给定二叉树: <code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回其层次遍历结果：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><blockquote><p>提示</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.节点总数 <span class="tag">&lt;<span class="name">=</span> <span class="attr">1000</span></span></span><br></pre></td></tr></table></figure><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><blockquote><p>本题难点</p></blockquote><p>题目要求的二叉树的 <strong>从上至下</strong> 打印（即按层打印），又称为二叉树的 <strong>广度优先搜索</strong>（BFS）</p><blockquote><p>具体思路</p></blockquote><p>BFS 通常借助 <strong>队列</strong> 的先入先出特性来实现。</p><ul><li><strong>每层打印到一行</strong>：将本层全部节点打印到一行，并将下一层全部节点加入队列，以此类推，即可分为多行打印。</li></ul><blockquote></blockquote><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">      <span class="comment">//当根节点为空，则返回空列表 [] </span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//打印结果列表 res = []</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      <span class="comment">//包含根节点的队列 queue = [root]</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">      <span class="comment">//BFS 循环： 当队列 queue 为空时跳出</span></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">          <span class="comment">//新建一个临时列表 ans ，用于存储当前层打印结果</span></span><br><span class="line">            List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">          <span class="comment">//当前层打印循环： 循环次数为当前层节点数（即队列 queue 长度）；</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = queue.size(); i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">              <span class="comment">//出队： 队首元素出队，记为 t</span></span><br><span class="line">                TreeNode t = queue.poll();</span><br><span class="line">              <span class="comment">//打印： 将 t.val 添加至 ans 尾部</span></span><br><span class="line">                ans.add(t.val);</span><br><span class="line">              <span class="comment">//添加子节点： 若 node 的左（右）子节点不为空，则将左（右）子节点加入队列 queue </span></span><br><span class="line">                <span class="keyword">if</span>(t.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.add(t.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(t.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.add(t.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">//将当前层结果 tmp 添加入 res </span></span><br><span class="line">            res.add(ans);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//返回打印结果列表 res 即可</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(<em>N</em>) ：<em>N</em> 为二叉树的节点数量，即 BFS 需循环 <em>N</em> 次。</li><li>空间复杂度 O(<em>N</em>) ： 最差情况下，即当树为平衡二叉树时，最多有 <em>N</em>/2 个树节点同时在 队列queue 中，使用 O(<em>N</em>) 大小的额外空间。</li></ul><h3 id="其他优秀解答"><a class="markdownIt-Anchor" href="#其他优秀解答"></a> 其他优秀解答</h3><blockquote><p>解题思路</p></blockquote><p>一般在树相关的题目中都可以考虑递归解法</p><blockquote><p>代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="comment">//输出结果列表res ，用于存储所有层的列表</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root)&#123;</span><br><span class="line">        <span class="comment">//递归调用函数，从第0层开始</span></span><br><span class="line">      recur(root,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recur</span><span class="params">(TreeNode root,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">          <span class="comment">//如果列表层数小于二叉树的层数，新增当前层的列表</span></span><br><span class="line">            <span class="keyword">if</span>(res.size() &lt;= k)&#123;</span><br><span class="line">              res.add(<span class="keyword">new</span> ArrayList());</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">//将当前层的元素添加到当前层列表中   </span></span><br><span class="line">            res.get(k).add(root.val);</span><br><span class="line">          <span class="comment">//递归调用二叉树的左子树，层数+1</span></span><br><span class="line">            recur(root.left,k+<span class="number">1</span>);</span><br><span class="line">          <span class="comment">//递归调用二叉树的右子树，层数+1</span></span><br><span class="line">            recur(root.right,k+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 队列 </tag>
            
            <tag> 广度优先搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 32 - III. 从上到下打印二叉树 III</title>
      <link href="/2020/09/08/%E5%89%91%E6%8C%87-Offer-32-III-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91-III/"/>
      <url>/2020/09/08/%E5%89%91%E6%8C%87-Offer-32-III-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91-III/</url>
      
        <content type="html"><![CDATA[<h3 id="题目信息"><a class="markdownIt-Anchor" href="#题目信息"></a> 题目信息</h3><ul><li><p>题目：剑指 Offer 32 - III. 从上到下打印二叉树 III</p></li><li><p>时间： 2020-09-08</p></li><li><p>题目链接：<a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/" target="_blank" rel="noopener">Leetcode</a></p></li><li><p>tag：双端队列 队列</p></li><li><p>难易程度：中等</p></li><li><p>题目描述：</p><p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p></li></ul><p><strong>示例1:</strong></p><p>给定二叉树: <code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回其层次遍历结果：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [20,9],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><blockquote><p>提示</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.节点总数 <span class="tag">&lt;<span class="name">=</span> <span class="attr">1000</span></span></span><br></pre></td></tr></table></figure><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><blockquote><p>本题难点</p></blockquote><p>二叉树层序遍历，每层遍历顺序都发生变化，奇数层逆序</p><blockquote><p>具体思路</p></blockquote><p>层序遍历 + 双端队列</p><ul><li><strong>操作</strong>：利用双端队列的两端皆可添加元素的特性，设打印列表（双端队列） <code>level</code> ，并规定<ul><li>奇数层 则添加至 <code>level</code> <strong>尾部</strong></li><li>偶数层 则添加至 <code>level</code> <strong>头部</strong></li></ul></li></ul><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">      <span class="comment">//当树的根节点为空，则直接返回空列表 []</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//打印结果空列表 res</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      <span class="comment">//包含根节点的双端队列 queue </span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">      <span class="comment">//BFS 循环： 当 queue 为空时跳出；</span></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">          <span class="comment">//新建列表 level ，用于临时存储当前层打印结果；</span></span><br><span class="line">            LinkedList&lt;Integer&gt; level = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">          <span class="comment">//当前层打印循环： 循环次数为当前层节点数（即 queue 长度）</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = queue.size(); i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">              <span class="comment">//出队： 队首元素出队，记为 node</span></span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">              <span class="comment">//打印： 若为奇数层，将 node.val 添加至 level 尾部；否则，添加至 level 头部；</span></span><br><span class="line">                <span class="keyword">if</span>(res.size() % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                    level.addLast(node.val);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    level.addFirst(node.val);</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="comment">//添加子节点： 若 node 的左（右）子节点不为空，则加入队列queue；</span></span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.add(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.add(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">//将当前层结果列表level 并添加入结果列表 res中</span></span><br><span class="line">            res.add(level);   </span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//返回打印结果列表 res 即可</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(<em>N</em>) ： N 为二叉树的节点数量，BFS 需循环 <em>N</em> 次，占用 O(<em>N</em>) ；双端队列的队首和队尾的添加和删除操作的时间复杂度均为 O(1) 。</li><li>空间复杂度 O(<em>N</em>) ： 最差情况下，即当树为满二叉树时，最多有 <em>N</em>/2 个树节点 <strong>同时</strong> 在 <code>queue</code> 中，使用 O(<em>N</em>)大小的额外空间。</li></ul><h3 id="其他优秀解答"><a class="markdownIt-Anchor" href="#其他优秀解答"></a> 其他优秀解答</h3><blockquote><p>解题思路</p></blockquote><p>一般在树相关的题目中都可以考虑递归解法</p><blockquote><p>代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//新建一个临时列表 level ，用于存储所有层的列表</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        <span class="comment">//当根节点为空，则返回空列表 [] </span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归调用函数，从第0层开始</span></span><br><span class="line">        recur(root,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recur</span><span class="params">(TreeNode root,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//如果列表层数小于二叉树的层数，新增当前层的列表</span></span><br><span class="line">            <span class="keyword">if</span>(res.size() &lt;= k)&#123;</span><br><span class="line">                res.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将当前层的元素添加到当前层列表中,层数为奇数时采用逆序</span></span><br><span class="line">            <span class="keyword">if</span>((k &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">                res.get(k).add(<span class="number">0</span>,root.val);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res.get(k).add(root.val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//递归调用二叉树的左子树，层数+1</span></span><br><span class="line">            recur(root.left,k+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//递归调用二叉树的右子树，层数+1</span></span><br><span class="line">            recur(root.right,k+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 队列 </tag>
            
            <tag> 双端队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 33. 二叉搜索树的后序遍历序列</title>
      <link href="/2020/09/08/%E5%89%91%E6%8C%87-Offer-33-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/"/>
      <url>/2020/09/08/%E5%89%91%E6%8C%87-Offer-33-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h3 id="题目信息"><a class="markdownIt-Anchor" href="#题目信息"></a> 题目信息</h3><ul><li><p>题目：剑指 Offer 33. 二叉搜索树的后序遍历序列</p></li><li><p>时间： 2020-09-08</p></li><li><p>题目链接：<a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/" target="_blank" rel="noopener">Leetcode</a></p></li><li><p>tag：分治算法 递归</p></li><li><p>难易程度：中等</p></li><li><p>题目描述：</p><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 <code>true</code>，否则返回 <code>false</code>。假设输入的数组的任意两个数字都互不相同。</p></li></ul><p><strong>参考如下:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  2   6</span><br><span class="line"> / \</span><br><span class="line">1   3</span><br></pre></td></tr></table></figure><p><strong>示例1:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,6,3,2,5]</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>示例2:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,2,6,5]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><blockquote><p>提示</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.数组长度<span class="tag">&lt;<span class="name">=1000</span></span></span><br></pre></td></tr></table></figure><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><blockquote><p>本题难点</p></blockquote><ul><li><strong>后序遍历定义</strong>： [ 左子树 | 右子树 | 根节点 ] ，即遍历顺序为 “左、右、根” 。</li><li><strong>二叉搜索树定义</strong>： 左子树中所有节点的值&lt; 根节点的值；右子树中所有节点的值 &lt;根节点的值；其左、右子树也分别为二叉搜索树。</li></ul><blockquote><p>具体思路</p></blockquote><p>根据二叉搜索树的定义，可以通过递归，判断所有子树的 <strong>正确性</strong> （即其后序遍历是否满足二叉搜索树的定义） ，若所有子树都正确，则此序列为二叉搜索树的后序遍历。</p><ul><li><p><strong>终止条件</strong>：当 <em>i</em>≥<em>j</em> ，说明此子树节点数量 ≤1 ，无需判别正确性，因此直接返回 true ；</p></li><li><p><strong>递推工作</strong>：</p><ul><li><p><strong>划分左右子树</strong>:遍历后序遍历的 [i,j] 区间元素，寻找 第一个大于根节点 的节点，索引记为<br />m。此时，可划分出左子树区间[i,m−1] 、右子树区间[m,j−1] 、根节点索引 j</p></li><li><p><strong>判断是否为二叉搜索树</strong></p><p><strong>左子树区间</strong>[i,m−1] 内的所有节点都应 &lt;postorder[j] 。而第 1.划分左右子树 步骤已经保证左子树区间的正确性，因此只需要判断右子树区间即可。</p><p><strong>右子树区间</strong>[m,j−1] 内的所有节点都应postorder&gt;[j] 。实现方式为遍历，当遇到 ≤postorder[j] 的节点则跳出；则可通过p=j 判断是否为二叉搜索树。</p></li></ul></li></ul><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verifyPostorder</span><span class="params">(<span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> recur(postorder,<span class="number">0</span>,postorder.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">recur</span><span class="params">(<span class="keyword">int</span>[] postorder,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">      <span class="comment">//当 i≥j ，说明此子树节点数量 ≤1 ，无需判别正确性，因此直接返回 true</span></span><br><span class="line">        <span class="keyword">if</span>(left &gt; right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//划分左右子树</span></span><br><span class="line">        <span class="keyword">int</span> p = left;</span><br><span class="line">      <span class="comment">//划分出左子树区间[i,m−1] </span></span><br><span class="line">        <span class="keyword">while</span>(postorder[p] &lt; postorder[right])&#123;</span><br><span class="line">            p++;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//寻找第一个大于根节点的节点，索引记为 m</span></span><br><span class="line">        <span class="keyword">int</span> m = p;</span><br><span class="line">      <span class="comment">//右子树区间[m,j−1] </span></span><br><span class="line">        <span class="keyword">while</span>(postorder[p] &gt; postorder[right])&#123;</span><br><span class="line">            p++;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//左子树区间[i,m−1] 内的所有节点都应 &lt;postorder[j] </span></span><br><span class="line">      <span class="comment">//右子树区间[m,j−1] 内的所有节点都应postorder[j] </span></span><br><span class="line">        <span class="keyword">return</span> p == right &amp;&amp; recur(postorder,left,m-<span class="number">1</span>) &amp;&amp; recur(postorder,m,right-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(<em>N^2</em>) ： 每次调用 recur(i,j) 减去一个根节点，因此递归占用 O(N) ；最差情况下（即当树退化为链表），每轮递归都需遍历树所有节点，占用 O(N) 。</li><li>空间复杂度 O(<em>N</em>) ： 最差情况下（即当树退化为链表），递归深度将达到 <em>N</em> 。</li></ul><h3 id="其他优秀解答"><a class="markdownIt-Anchor" href="#其他优秀解答"></a> 其他优秀解答</h3><blockquote><p>解题思路</p></blockquote><p>辅助单调栈，后序遍历倒序： [ 根节点 | 右子树 | 左子树 ] 。类似 先序遍历的镜像 ，即先序遍历为 “根、左、右” 的顺序，而后序遍历的倒序为 “根、右、左” 顺序。</p><ul><li><p>为什么要用单调栈呢，因为往右子树遍历的过程，value是越来越大的，一旦出现了value小于栈顶元素value的时候，就表示要开始进入左子树了。</p></li><li><p>单调栈帮我们记录了这些节点，只要栈顶元素还比当前节点大，就表示还是右子树，要移除，因为我们要找到这个左孩子节点直接连接的父节点，也就是找到这个子树的根，只要栈顶元素还大于当前节点，就要一直弹出，直到栈顶元素小于节点，或者栈为空。栈顶的上一个元素就是子树节点的根。</p></li><li><p>接下来，数组继续往前遍历，之后的左子树的每个节点，都要比子树的根要小，才能满足二叉搜索树，否则就不是二叉搜索树。</p></li></ul><blockquote><p>代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verifyPostorder</span><span class="params">(<span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 单调栈使用，单调递增的单调栈</span></span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 表示上一个根节点的元素，这里可以把postorder的最后一个元素root看成无穷大节点的左孩子</span></span><br><span class="line">        <span class="keyword">int</span> pervElem = Integer.MAX_VALUE;</span><br><span class="line">        <span class="comment">// 逆向遍历，就是翻转的先序遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = postorder.length - <span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="comment">// 左子树元素必须要小于递增栈被peek访问的元素，否则就不是二叉搜索树</span></span><br><span class="line">            <span class="keyword">if</span> (postorder[i] &gt; pervElem)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; postorder[i] &lt; stack.peek())&#123;</span><br><span class="line">                <span class="comment">// 数组元素小于单调栈的元素了，表示往左子树走了，记录下上个根节点</span></span><br><span class="line">                <span class="comment">// 找到这个左子树对应的根节点，之前右子树全部弹出，不再记录，因为不可能在往根节点的右子树走了</span></span><br><span class="line">                pervElem = stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 这个新元素入栈</span></span><br><span class="line">            stack.push(postorder[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分治法 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 34. 二叉树中和为某一值的路径</title>
      <link href="/2020/09/07/%E5%89%91%E6%8C%87-Offer-34-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
      <url>/2020/09/07/%E5%89%91%E6%8C%87-Offer-34-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<h3 id="题目信息"><a class="markdownIt-Anchor" href="#题目信息"></a> 题目信息</h3><ul><li><p>题目：剑指 Offer 34. 二叉树中和为某一值的路径</p></li><li><p>时间： 2020-09-07</p></li><li><p>题目链接：<a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/" target="_blank" rel="noopener">Leetcode</a></p></li><li><p>tag：深度优先搜索 回溯法</p></li><li><p>难易程度：中等</p></li><li><p>题目描述：</p><p>输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。</p></li></ul><p><strong>示例:</strong></p><p>给定如下二叉树，以及目标和 <code>sum = 22</code>，</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      5</span><br><span class="line">     / \</span><br><span class="line">    4   8</span><br><span class="line">   /   / \</span><br><span class="line">  11  13  4</span><br><span class="line"> /  \    / \</span><br><span class="line">7    2  5   1</span><br></pre></td></tr></table></figure><p>返回：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">   [5,4,11,2],</span><br><span class="line">   [5,8,4,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><blockquote><p>提示</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.节点总数<span class="tag">&lt;<span class="name">=10000</span></span></span><br></pre></td></tr></table></figure><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><blockquote><p>本题难点</p></blockquote><p>本问题是典型的二叉树方案搜索问题，使用回溯法解决，其包含 <strong>先序遍历 + 路径记录</strong> 两部分。</p><blockquote><p>具体思路</p></blockquote><ul><li><strong>先序遍历</strong>：按照 “根、左、右” 的顺序，遍历树的所有节点。</li><li><strong>路径记录</strong>： 在先序遍历中，记录从根节点到当前节点的路径。当路径为 ① 根节点到叶节点形成的路径 <strong>且</strong> ② 各节点值的和等于目标值 <code>sum</code> 时，将此路径加入结果列表。</li></ul><blockquote><p>值得注意的是，记录路径时若直接执行 res.append(path) ，则是将 path 对象加入了 res ；后续 path 改变时， res 中的 path 对象也会随之改变。</p></blockquote><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="comment">//结果列表 res</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  <span class="comment">//路径列表 path</span></span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;(); </span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">        recur(root,sum);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recur</span><span class="params">(TreeNode root,<span class="keyword">int</span> tar)</span></span>&#123;</span><br><span class="line">      <span class="comment">//终止条件： 若节点 root 为空，则直接返回。</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//路径更新： 将当前节点值 root.val 加入路径 path </span></span><br><span class="line">        path.add(root.val);</span><br><span class="line">      <span class="comment">//目标值更新： tar = tar - root.val（即目标值 tar 从 sum 减至 0 ）；</span></span><br><span class="line">        tar -= root.val;</span><br><span class="line">      <span class="comment">//路径记录： 当 ① root 为叶节点 且 ② 路径和等于目标值 ，则将此路径 path 加入 res 。</span></span><br><span class="line">        <span class="keyword">if</span>(tar == <span class="number">0</span> &amp;&amp; root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> LinkedList(path));</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//先序遍历： 递归左 / 右子节点。</span></span><br><span class="line">        recur(root.left,tar);</span><br><span class="line">        recur(root.right,tar);</span><br><span class="line">      <span class="comment">//路径恢复： 向上回溯前，需要将当前节点从路径 path 中删除，即执行 path.removeLast() 。</span></span><br><span class="line">        path.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(<em>N</em>) ： <em>N</em> 为二叉树的节点数，先序遍历需要遍历所有节点。</li><li>空间复杂度 O(<em>N</em>) ： 最差情况下，即树退化为链表时，<code>path</code> 存储所有树节点，使用 O(<em>N</em>) 额外空间。</li></ul><h3 id=""><a class="markdownIt-Anchor" href="#"></a> </h3>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯法 </tag>
            
            <tag> 深度优先搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 35. 复杂链表的复制</title>
      <link href="/2020/09/06/%E5%89%91%E6%8C%87-Offer-35-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/"/>
      <url>/2020/09/06/%E5%89%91%E6%8C%87-Offer-35-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="题目信息"><a class="markdownIt-Anchor" href="#题目信息"></a> 题目信息</h3><ul><li><p>题目：剑指 Offer 35. 复杂链表的复制</p></li><li><p>时间： 2020-09-06</p></li><li><p>题目链接：<a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/" target="_blank" rel="noopener">Leetcode</a></p></li><li><p>tag： 链表</p></li><li><p>难易程度：中等</p></li><li><p>题目描述：</p><p>请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。</p></li></ul><p><strong>示例1:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br><span class="line">输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br></pre></td></tr></table></figure><p><strong>示例2:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [[1,1],[2,1]]</span><br><span class="line">输出：[[1,1],[2,1]]</span><br></pre></td></tr></table></figure><blockquote><p>提示</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.-10000 &lt;= Node.val &lt;= 10000</span><br><span class="line">2.Node.random为null或指向链表中的节点</span><br><span class="line">3.节点数目不超过1000</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><blockquote><p>本题难点</p></blockquote><p>本题的意思是复制一个链表并返回，这个链表与一般链表不同的是多了一个 <code>random</code> 指针。</p><blockquote><p>具体思路</p></blockquote><p>这个复制过程可以分成两步：第一步是复制原始链表上的每个节点，并用next指针相连; 第二步是设置每个节点的random指针。</p><ul><li><strong>复制节点</strong>：将原始链表的任意节点 N复制为新节点N’,再把N’连接到 N的后面。即如果原始链表为A-&gt;B-&gt;C-&gt;D 则复制过后为A-&gt;A’-&gt;B-&gt;B’-&gt;C-&gt;C’-&gt;D-&gt;D’</li><li><strong>建立random连接</strong>： 如果原始链表上的节点 N 的random指针指向节点S,则它对应的复制节点N’的random指针指向节点S的复制节点S’,也就是当前节点S的下一个节点。</li><li><strong>拆分链表</strong>：把这个长链表拆分成两个链表,把奇数位置的节点连接起来就是原始链表,把偶数位置的节点连接起来就是复制出来的链表。</li></ul><blockquote></blockquote><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node next;</span></span><br><span class="line"><span class="comment">    Node random;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">        this.next = null;</span></span><br><span class="line"><span class="comment">        this.random = null;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//插入新节点</span></span><br><span class="line">        Node cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            Node clone = <span class="keyword">new</span> Node(cur.val);</span><br><span class="line">            clone.next = cur.next;</span><br><span class="line">            cur.next = clone;</span><br><span class="line">            cur = clone.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//建立random链接</span></span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            Node clone = cur.next;</span><br><span class="line">            <span class="keyword">if</span>(cur.random != <span class="keyword">null</span>)&#123;</span><br><span class="line">                clone.random = cur.random.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = clone.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//拆分</span></span><br><span class="line">        cur = head;</span><br><span class="line">        Node cloneHead = head.next;</span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            Node next = cur.next;</span><br><span class="line">            cur.next = next.next;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cloneHead;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(<em>N</em>) ： 链表长度为N，遍历所需时间。</li><li>空间复杂度 O(1) ：没有使用额外的空间保存已保存的节点。</li></ul><h3 id="其他优秀解答"><a class="markdownIt-Anchor" href="#其他优秀解答"></a> 其他优秀解答</h3><blockquote><p>解题思路</p></blockquote><p>1.创建HashMap<br />2.复制结点值<br />3.复制指向（next,random）</p><blockquote><p>代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node next;</span></span><br><span class="line"><span class="comment">    Node random;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">        this.next = null;</span></span><br><span class="line"><span class="comment">        this.random = null;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123; <span class="comment">//HashMap实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Node,Node&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">//创建HashMap集合</span></span><br><span class="line">        Node cur=head;</span><br><span class="line">        <span class="comment">//复制结点值</span></span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//存储put:&lt;key,value1&gt;</span></span><br><span class="line">            map.put(cur,<span class="keyword">new</span> Node(cur.val)); <span class="comment">//顺序遍历，存储老结点和新结点(先存储新创建的结点值)</span></span><br><span class="line">            cur=cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//复制结点指向</span></span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//得到get:&lt;key&gt;.value2,3</span></span><br><span class="line">            map.get(cur).next = map.get(cur.next); <span class="comment">//新结点next指向同旧结点的next指向</span></span><br><span class="line">            map.get(cur).random = map.get(cur.random); <span class="comment">//新结点random指向同旧结点的random指向</span></span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回复制的链表</span></span><br><span class="line">        <span class="keyword">return</span> map.get(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 36. 二叉搜索树与双向链表</title>
      <link href="/2020/09/05/%E5%89%91%E6%8C%87-Offer-36-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
      <url>/2020/09/05/%E5%89%91%E6%8C%87-Offer-36-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="题目信息"><a class="markdownIt-Anchor" href="#题目信息"></a> 题目信息</h3><ul><li><p>题目：剑指 Offer 36. 二叉搜索树与双向链表</p></li><li><p>时间： 2020-09-05</p></li><li><p>题目链接：<a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/" target="_blank" rel="noopener">Leetcode</a></p></li><li><p>tag：  二叉搜索树 中序遍历 递归 深度优先搜索</p></li><li><p>难易程度：中等</p></li><li><p>题目描述：</p><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</p></li></ul><p><strong>示例:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    4</span><br><span class="line">   / \</span><br><span class="line">  2   5</span><br><span class="line"> / \   </span><br><span class="line">1  3</span><br></pre></td></tr></table></figure><p>我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。</p><blockquote><p>提示</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><blockquote><p>本题难点</p></blockquote><p>二叉搜索树 转换成一个 “排序的循环双向链表” ，其中包含三个要素：</p><ul><li><p><strong>排序链表</strong>： 节点应从小到大排序，因此应使用 <strong>中序遍历</strong> “从小到大”访问树的节点；</p></li><li><p><strong>双向链表</strong>： 在构建相邻节点（设前驱节点 pre ，当前节点 cur ）关系时，不仅应 pre.right=cur ，也应 cur.left=pre 。</p></li><li><p><strong>循环链表</strong>： 设链表头节点 head 和尾节点 tail ，则应构建 head.left=tail 和 tail.right=head 。</p></li></ul><blockquote><p>具体思路</p></blockquote><p>二叉搜索树的中序遍历为 <strong>递增序列</strong> 。</p><ul><li><p><strong>中序遍历</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    dfs(root.left); <span class="comment">// 左</span></span><br><span class="line">    System.out.println(root.val); <span class="comment">// 根</span></span><br><span class="line">    dfs(root.right); <span class="comment">// 右</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>根据以上分析，考虑使用中序遍历访问树的各节点 cur ；并在访问每个节点时构建 cur 和前驱节点 pre 的引用指向；中序遍历完成后，最后构建头节点和尾节点的引用指向即可。</p></blockquote><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public Node left;</span></span><br><span class="line"><span class="comment">    public Node right;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val,Node _left,Node _right) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        left = _left;</span></span><br><span class="line"><span class="comment">        right = _right;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//pre本来是前序节点，随着中序遍历，最终会成为中序遍历的尾节点</span></span><br><span class="line">    <span class="comment">//head指向中序遍历的头节点</span></span><br><span class="line">    Node pre,head;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">treeToDoublyList</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//深度优先搜索二叉搜索树</span></span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="comment">//将头节点head的左指针指向尾节点pre</span></span><br><span class="line">        head.left = pre;</span><br><span class="line">        <span class="comment">//将尾节点pre的左指针指向头节点head</span></span><br><span class="line">        pre.right = head;</span><br><span class="line">        <span class="comment">//返回结果</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node cur)</span></span>&#123;</span><br><span class="line">      <span class="comment">//终止条件： 当节点 cur 为空，代表越过叶节点，直接返回；</span></span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归遍历左子树</span></span><br><span class="line">        dfs(cur.left);</span><br><span class="line">        <span class="comment">//当前节点cur不存在左子树时，此时cur无前驱节点，即前驱节点pre==null，cur为中序遍历的第一个节点</span></span><br><span class="line">        <span class="keyword">if</span>(pre == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//将中序遍历的头节点cur赋予双向链表的头节点head</span></span><br><span class="line">            head = cur;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//当前节点cur存在前置节点pre,将pre的右指针指向cur</span></span><br><span class="line">            pre.right = cur;</span><br><span class="line">            <span class="comment">//当前节点cur存在前驱节点pre,将cur的左指针指向pre，形成双向链表</span></span><br><span class="line">        cur.left = pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将前驱节点pre后移，保存当前节点cur</span></span><br><span class="line">        pre = cur;</span><br><span class="line">        <span class="comment">//递归遍历右子树</span></span><br><span class="line">        dfs(cur.right); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(<em>N</em>) ：  <em>N</em> 为二叉树的节点数，中序遍历需要访问所有节点。</li><li>空间复杂度 O(<em>N</em>) ：  最差情况下，即树退化为链表时，递归深度达到 <em>N</em>，系统使用 O(<em>N</em>) 栈空间。</li></ul><h3 id="其他优秀解答"><a class="markdownIt-Anchor" href="#其他优秀解答"></a> 其他优秀解答</h3><blockquote><p>解题思路</p></blockquote><p>中序遍历的非递归，使用栈的<strong>先进后出</strong>特性。</p><blockquote><p>代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">treeToDoublyList</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">  <span class="comment">//用栈实现</span></span><br><span class="line">         Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">         Node current = root;</span><br><span class="line">         Node pre = <span class="keyword">null</span>, head = <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">while</span>(!stack.isEmpty() || current != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">//内层循环将当前数据入栈</span></span><br><span class="line">             <span class="keyword">while</span>(current != <span class="keyword">null</span>) &#123;</span><br><span class="line">                 stack.push(current);</span><br><span class="line">                 current = current.left;</span><br><span class="line">             &#125;</span><br><span class="line">           <span class="comment">//出栈并将该元素放入到链表中</span></span><br><span class="line">             current = stack.pop();</span><br><span class="line">             <span class="keyword">if</span>(pre == <span class="keyword">null</span>) &#123;<span class="comment">//处理头结点</span></span><br><span class="line">                 head = current;</span><br><span class="line">             &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                 pre.right = current;</span><br><span class="line">                 current.left = pre;</span><br><span class="line">             &#125;</span><br><span class="line">            pre = current;</span><br><span class="line">           <span class="comment">////将cur指向栈顶元素的右孩子</span></span><br><span class="line">            current = current.right;</span><br><span class="line">         &#125;</span><br><span class="line">         pre.right = head;</span><br><span class="line">         head.left = pre;</span><br><span class="line">         <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 深度优先搜索 </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 二叉搜索树 </tag>
            
            <tag> 中序遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 37. 序列化二叉树</title>
      <link href="/2020/09/04/%E5%89%91%E6%8C%87-Offer-37-%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2020/09/04/%E5%89%91%E6%8C%87-Offer-37-%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h3 id="题目信息"><a class="markdownIt-Anchor" href="#题目信息"></a> 题目信息</h3><ul><li><p>题目： 剑指 Offer 37. 序列化二叉树</p></li><li><p>时间： 2020-09-04</p></li><li><p>题目链接：<a href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/" target="_blank" rel="noopener">Leetcode</a></p></li><li><p>tag：序列化  二叉树  队列</p></li><li><p>难易程度：中等</p></li><li><p>题目描述：</p><p>请实现两个函数，分别用来序列化和反序列化二叉树。</p></li></ul><p><strong>示例:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2   3</span><br><span class="line">   / \</span><br><span class="line">  4   5</span><br></pre></td></tr></table></figure><p>序列化为 “[1,2,3,null,null,4,5]”</p><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><blockquote><p>本题难点</p></blockquote><p>题目要求的 “序列化” 和 “反序列化” 是 <strong>可逆</strong> 操作。因此，序列化的字符串应携带 “完整的” 二叉树信息，即拥有单独表示二叉树的能力。</p><blockquote><p>具体思路</p></blockquote><p>序列化的字符串实际上是二叉树的 “层序遍历”（BFS）结果。为使反序列化可行，考虑将越过叶节点后的 null 也看作是节点。</p><ul><li>**序列化 serialize **：借助队列，对二叉树做层序遍历，并将越过叶节点的 null 也打印出来。</li><li>**反序列化 deserialize **：利用队列按层构建二叉树，借助一个指针 i 指向节点 node 的左、右子节点，每构建一个 node 的左、右子节点，指针 i 就向右移动 1 位。</li></ul><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//若 root 为空，则直接返回空列表 "[]" ；</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"[]"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//队列 queue （包含根节点 root ）</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">      <span class="comment">//序列化列表 res </span></span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder(<span class="string">"["</span>);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">          <span class="comment">//节点出队，记为 node ；</span></span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            <span class="keyword">if</span>(node != <span class="keyword">null</span>)&#123;<span class="comment">//若 node 不为空：打印字符串 node.val ，</span></span><br><span class="line">                res.append(node.val).append(<span class="string">","</span>);</span><br><span class="line">              <span class="comment">//将左、右子节点加入 queue </span></span><br><span class="line">                queue.add(node.left);</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//否则（若 node 为空）：打印字符串 "null"</span></span><br><span class="line">                res.append(<span class="string">"null"</span>).append(<span class="string">","</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//拼接列表（去除最后一个节点后的 ',' 隔开，首尾添加中括号）</span></span><br><span class="line">        res.deleteCharAt(res.length() - <span class="number">1</span>);</span><br><span class="line">        res.append(<span class="string">"]"</span>);</span><br><span class="line">      <span class="comment">//返回序列化结果</span></span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 若 data 为空，直接返回 null ；</span></span><br><span class="line">        <span class="keyword">if</span>(data == <span class="string">"[]"</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//序列化列表 value （先去掉首尾中括号，再用逗号隔开）</span></span><br><span class="line">        String[] value = data.substring(<span class="number">1</span>,data.length() - <span class="number">1</span>).split(<span class="string">","</span>);</span><br><span class="line">      <span class="comment">//根节点 root （值为 vals[0] ）</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(Integer.parseInt(value[<span class="number">0</span>]));</span><br><span class="line">      <span class="comment">//队列 queue（包含 root ）</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">      <span class="comment">//指针i</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">          <span class="comment">//节点出队，记为 node ；</span></span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">          <span class="comment">//构建 node 的左子节点：node.left 的值为 value[i] ，并将 node.left 入队；</span></span><br><span class="line">            <span class="keyword">if</span>(!value[i].equals(<span class="string">"null"</span>))&#123;</span><br><span class="line">                node.left = <span class="keyword">new</span> TreeNode(Integer.parseInt(value[i])); </span><br><span class="line">                queue.add(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">//指针加一，找下一个节点</span></span><br><span class="line">            i++;</span><br><span class="line">          <span class="comment">//构建 node 的右子节点：node.left 的值为 value[i] ，并将 node.left 入队；</span></span><br><span class="line">            <span class="keyword">if</span>(!value[i].equals(<span class="string">"null"</span>))&#123;</span><br><span class="line">                node.right = <span class="keyword">new</span> TreeNode(Integer.parseInt(value[i])); </span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">//指针加一，找下一个节点</span></span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//返回根节点root</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(<em>N</em>) ： N 为二叉树的节点数，层序遍历需要访问所有节点，最差情况下需要访问 N+1 个 null ，总体复杂度为 O(2N+1)=O(N) 。</li><li>空间复杂度 O(<em>N</em>) ： 最差情况下，队列 queue 同时存储 N+1/2个节点（或 N+1 个 null ），使用 O(N) ；列表 res 使用 O(N) 。</li></ul><h3 id="其他优秀解答"><a class="markdownIt-Anchor" href="#其他优秀解答"></a> 其他优秀解答</h3><blockquote><p>解题思路</p></blockquote><p>我们可以根据前序遍历的顺序来序列化二叉树,因为前序遍历是从根节点开始的。在遍历二叉树碰到 null时,将其序列化为一个特殊的字符(如’$’)，节点的数值之间要用一个特殊字符(如’,’)隔开,因为节点的值位数不定且正负不定。</p><blockquote><p>代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">int</span> start=<span class="number">0</span>;<span class="comment">//注意这里必须是全局变量，否则后面的迭代过程中start无法正确变化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="string">"$"</span>;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        recur(root,res);</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recur</span><span class="params">(TreeNode root,StringBuilder res)</span></span>&#123;<span class="comment">//前序遍历</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123; </span><br><span class="line">            res.append(<span class="string">"$,"</span>);<span class="comment">//可以append string</span></span><br><span class="line">            <span class="keyword">return</span>;&#125;</span><br><span class="line">        res.append(root.val);<span class="comment">//append int 由于int位数不定，且可正可负，因此各元素间必须用,分割</span></span><br><span class="line">        res.append(<span class="string">','</span>);<span class="comment">//append char</span></span><br><span class="line">        recur(root.left,res);</span><br><span class="line">        recur(root.right,res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data.equals(<span class="string">"$"</span>)) <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//Sting值相等的判别不能用==</span></span><br><span class="line">        String inputs[] = data.split(<span class="string">","</span>);</span><br><span class="line">        <span class="comment">//虽然data中以,结尾，但是上述分割后会默认最后一个,不存在  不会使最后一个分割元素为空</span></span><br><span class="line">        <span class="keyword">return</span> build(inputs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">build</span><span class="params">(String[] inputs)</span></span>&#123;</span><br><span class="line">        TreeNode res;</span><br><span class="line">        <span class="keyword">if</span>(inputs[start].equals(<span class="string">"$"</span>))&#123; </span><br><span class="line">            start++;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//这里说明当前节点为null，自然不存在左右节点了，直接返回</span></span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="keyword">new</span> TreeNode(Integer.parseInt(inputs[start]));</span><br><span class="line">        start++;</span><br><span class="line">        <span class="comment">//注意：start不能以形参的形式引入build方法中，build(inputs,start);如果是这样</span></span><br><span class="line">        <span class="comment">//下面res.left = build(inputs,start); res.right = build(inputs,start+1);由于处于同一级迭代中start值连续</span></span><br><span class="line">        <span class="comment">//但实际上res.right中应该是上面res.left迭代完成后才会执行的，start不连续，因此把start作为全局变量较为合适</span></span><br><span class="line">        res.left = build(inputs);</span><br><span class="line">        res.right = build(inputs);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯法 </tag>
            
            <tag> 深度优先搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 38. 字符串的排列</title>
      <link href="/2020/09/03/%E5%89%91%E6%8C%87-Offer-38-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/"/>
      <url>/2020/09/03/%E5%89%91%E6%8C%87-Offer-38-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h3 id="题目信息"><a class="markdownIt-Anchor" href="#题目信息"></a> 题目信息</h3><ul><li><p>题目：剑指 Offer 38. 字符串的排列</p></li><li><p>时间： 2020-09-03</p></li><li><p>题目链接：<a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/" target="_blank" rel="noopener">Leetcode</a></p></li><li><p>tag：深度优先搜索  回溯法</p></li><li><p>难易程度：中等</p></li><li><p>题目描述：</p><p>输入一个字符串，打印出该字符串中字符的所有排列。</p><p>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p></li></ul><p><strong>示例:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = "abc"</span><br><span class="line">输出：["abc","acb","bac","bca","cab","cba"]</span><br></pre></td></tr></table></figure><blockquote><p>提示</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= s.length() &lt;= 8</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><blockquote><p>本题难点</p></blockquote><p>对于一个长度为 n 的字符串（假设字符互不重复），其排列共有 n×(n−1)×(n−2)…×2×1 种方案。要求返回的结果又不能有重复元素。</p><p>回溯法 ：一种通过探索所有可能的候选解来找出所有的解的算法。如果候选解被确认不是一个解的话（或者至少不是最后一个解），回溯算法会通过在上一步进行一些变化抛弃该解，即回溯并且再次尝试。</p><blockquote><p>具体思路</p></blockquote><p>这个问题可以看作有 n 个排列成一行的空格，我们需要从左往右依此填入题目给定的 n 个字符，每个字符只能使用一次。</p><p>定义chars[]为输入字符串的字符数组，递归函数 backtracking表示从左往右填到第 i 个位置，当前字符串排列为 s。 那么整个递归函数分为两个情况：</p><ul><li>如果 s.length()==chars.length，说明我们已经填完了 n 个位置（注意下标从 0 开始），找到了一个可行的解，我们将 s 放入答案数组中，递归结束。</li><li>如果 s.length()&lt;chars.length，我们要考虑这第 i 个位置我们要填哪个字符。根据题目要求我们肯定不能填已经填过的字符，因此很容易想到的一个处理手段是我们定义一个标记数组 hasUsed[] 来标记已经填过的数，那么在填第 i 个数的时候我们遍历题目给定的 n 个字符。</li><li>如果这个数没有被标记过，我们就尝试填入，并将其标记，继续尝试填下一个位置，即调用函数backtrack。搜索回溯的时候要撤销这一个位置填的数以及标记，并继续尝试其他没被标记过的数。</li></ul><blockquote><p>在一定会产生重复结果集的地方剪枝。</p></blockquote><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String[] permutation(String s) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 转换成字符数组</span></span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">      <span class="comment">// 排序是为了去重方便</span></span><br><span class="line">        Arrays.sort(chars);</span><br><span class="line">      <span class="comment">// 由于操作的都是字符，使用 StringBuilder</span></span><br><span class="line">      StringBuilder path = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">      <span class="comment">//标记数组。通过标记才能让递归后的代码知道之前用过哪些数据，就可以舍去这些数字（剪枝）。</span></span><br><span class="line">      <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[chars.length];</span><br><span class="line">      <span class="comment">// 回溯法</span></span><br><span class="line">        backtracking(chars,used,path);</span><br><span class="line">      <span class="comment">// 记得转成字符串数组</span></span><br><span class="line">        <span class="keyword">return</span> ret.toArray(<span class="keyword">new</span> String[ret.size()]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">char</span>[] chars,<span class="keyword">boolean</span>[] hasUsed,StringBuilder s)</span></span>&#123;</span><br><span class="line">      <span class="comment">// 恰好生成了新的字符对象</span></span><br><span class="line">        <span class="keyword">if</span>(s.length() == chars.length)&#123;</span><br><span class="line">            ret.add(s.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hasUsed[i])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">//去重，写 !hasUsed[i - 1] 是因为 chars[i - 1] 在深度优先遍历的过程中刚刚被撤销选择</span></span><br><span class="line">            <span class="keyword">if</span>(i != <span class="number">0</span> &amp;&amp; chars[i] == chars[i -<span class="number">1</span>] &amp;&amp; !hasUsed[i - <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">//当前字符是否使用</span></span><br><span class="line">            hasUsed[i] = <span class="keyword">true</span>;</span><br><span class="line">          <span class="comment">//将当前字符添加到StringBuilder中</span></span><br><span class="line">            s.append(chars[i]);</span><br><span class="line">          <span class="comment">//深度优先搜索</span></span><br><span class="line">            backtracking(chars,hasUsed,s);</span><br><span class="line">          <span class="comment">// 注意：这里是状态重置，是从深层结点回到浅层结点的过程，代码在形式上和递归之前是对称的</span></span><br><span class="line">          <span class="comment">// 递归完成以后，需要撤销选择，递归方法执行之前做了什么，递归方法执行以后就需要做相应的逆向操作</span></span><br><span class="line">            s.deleteCharAt(s.length() -<span class="number">1</span>);</span><br><span class="line">            hasUsed[i] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(<em>N</em>!) ： N 为字符串 s 的长度；时间复杂度和字符串排列的方案数成线性关系，方案数为 N×(N−1)×(N−2)…×2×1 ，因此复杂度为 O(N!) 。</li><li>空间复杂度 O(<em>N</em>) ： 其中 n 为序列的长度。除答案数组以外，递归函数在递归过程中需要为每一层递归函数分配栈空间，所以这里需要额外的空间且该空间取决于递归的深度，这里可知递归调用深度为 O(n)。</li></ul><h3 id="其他优秀解答"><a class="markdownIt-Anchor" href="#其他优秀解答"></a> 其他优秀解答</h3><blockquote><p>解题思路</p></blockquote><ul><li><p><strong>排列方案的生成方法</strong>：根据字符串排列的特点，考虑深度优先搜索所有排列方案。即通过字符交换，先固定第 1 位字符（ n 种情况）、再固定第 2 位字符（ n−1 种情况）、… 、最后固定第 n 位字符（ 1 种情况）。</p></li><li><p><strong>重复方案与剪枝</strong>：</p><p>当字符串存在重复字符时，排列方案中也存在重复方案。为排除重复方案，需在固定某位字符时，保证 “每种字符只在此位固定一次” ，即遇到重复字符时不交换，直接跳过。从 DFS 角度看，此操作称为 “剪枝” 。</p></li></ul><blockquote><p>代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exam38_permutation</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//为了让递归函数添加结果方便，定义到函数之外，这样无需带到递归函数的参数列表中</span></span><br><span class="line">    <span class="keyword">char</span>[] c;</span><br><span class="line">    <span class="comment">//同；但是其赋值依赖c，定义声明分开</span></span><br><span class="line">    <span class="keyword">public</span> String[] permutation(String s) &#123;</span><br><span class="line">        c = s.toCharArray();</span><br><span class="line">        <span class="comment">//从第一层开始递归</span></span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> list.toArray(<span class="keyword">new</span> String[list.size()]);</span><br><span class="line">        <span class="comment">//将字符串数组ArrayList转化为String类型数组</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当递归函数到达第三层，就返回，因为此时第二第三个位置已经发生了交换</span></span><br><span class="line">        <span class="keyword">if</span> (x == c.length - <span class="number">1</span>) &#123;</span><br><span class="line">            list.add(String.valueOf(c));<span class="comment">//将字符数组转换为字符串</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//为了防止同一层递归出现重复元素</span></span><br><span class="line">        HashSet&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="comment">//这里就很巧妙了,第一层可以是a,b,c那么就有三种情况，这里i = x,正巧dfs(0)，正好i = 0开始</span></span><br><span class="line">        <span class="comment">// 当第二层只有两种情况，dfs(1）i = 1开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt; c.length; i++)&#123;</span><br><span class="line">            <span class="comment">//发生剪枝，当包含这个元素的时候，直接跳过</span></span><br><span class="line">            <span class="keyword">if</span> (set.contains(c[i]))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(c[i]);</span><br><span class="line">            <span class="comment">//交换元素，这里很是巧妙，当在第二层dfs(1),x = 1,那么i = 1或者 2， 要不是交换1和1，要不交换1和2</span></span><br><span class="line">            swap(i,x);</span><br><span class="line">            <span class="comment">//进入下一层递归</span></span><br><span class="line">            dfs(x + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//返回时交换回来，这样保证到达第1层的时候，一直都是abc。这里捋顺一下，开始一直都是abc，那么第一位置总共就3个位置</span></span><br><span class="line">            <span class="comment">//分别是a与a交换，这个就相当于 x = 0, i = 0;</span></span><br><span class="line">            <span class="comment">//     a与b交换            x = 0, i = 1;</span></span><br><span class="line">            <span class="comment">//     a与c交换            x = 0, i = 2;</span></span><br><span class="line">            <span class="comment">//就相当于上图中开始的三条路径</span></span><br><span class="line">            <span class="comment">//第一个元素固定后，每个引出两条路径,</span></span><br><span class="line">            <span class="comment">//     b与b交换            x = 1, i = 1;</span></span><br><span class="line">            <span class="comment">//     b与c交换            x = 1, i = 2;</span></span><br><span class="line">            <span class="comment">//所以，结合上图，在每条路径上标注上i的值，就会非常容易好理解了</span></span><br><span class="line">            swap(i,x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> temp = c[i];</span><br><span class="line">        c[i] = c[x];</span><br><span class="line">        c[x] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯法 </tag>
            
            <tag> 深度优先搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 39. 数组中出现次数超过一半的数字</title>
      <link href="/2020/09/02/%E5%89%91%E6%8C%87-Offer-39-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/"/>
      <url>/2020/09/02/%E5%89%91%E6%8C%87-Offer-39-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h3 id="题目信息"><a class="markdownIt-Anchor" href="#题目信息"></a> 题目信息</h3><ul><li><p>题目；剑指 Offer 39. 数组中出现次数超过一半的数字</p></li><li><p>时间： 2020-09-02</p></li><li><p>题目链接：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/" target="_blank" rel="noopener">Leetcode</a></p></li><li><p>tag：  数组  哈希表</p></li><li><p>难易程度：简单</p></li><li><p>题目描述：</p><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p><p>假设数组是非空的，并且给定的数组总是存在多数元素。</p></li></ul><p><strong>示例:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><blockquote><p>提示</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= 数组长度 &lt;= 50000</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><blockquote><p>本题难点</p></blockquote><p>如何实现查找数组中的众数的最优解，时间复杂度和空间复杂度最小。</p><blockquote><p>具体思路</p></blockquote><p>摩尔投票法：</p><ul><li><strong>票数和</strong>：由于众数出现的次数超过数组长度的一半；若记 <strong>众数</strong> 的票数为 +1 ，<strong>非众数</strong> 的票数为 −1 ，则一定有所有数字的<strong>票数和</strong> &gt; 0。</li><li><strong>票数正负抵消</strong>： 设数组 <code>nums</code> 中的众数为 <em>x</em> ，数组长度为 <em>n</em> 。若 nums 的前 a 个数字的 票数和 =0 ，则 数组后 (n−a) 个数字的 票数和一定仍 &gt; 0 （即后 (n−a) 个数字的 众数仍为 x ）。</li></ul><p>为构建正负抵消，假设数组首个元素 为众数，遍历统计票数，当发生正负抵消时，剩余数组的众数一定不变 ，这是因为（设真正的众数为 x ）：</p><ul><li>当 n1=x ： 抵消的所有数字中，有一半是众数 x 。</li><li>当 n1≠x ： 抵消的所有数字中，少于或等于一半是众数 x 。</li></ul><p>利用此特性，每轮假设都可以 <strong>缩小剩余数组区间</strong> 。当遍历完成时，最后一轮假设的数字即为众数（由于众数超过一半，最后一轮的票数和必为正数）。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//票数统计 count=0</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">//众数 x</span></span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">//遍历数组 nums 中的每个数字 num </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num :nums)&#123;</span><br><span class="line">          <span class="comment">//当 票数 count 等于 0 ，则假设 当前数字 num 为 众数 x ；</span></span><br><span class="line">            <span class="keyword">if</span>(count == <span class="number">0</span>)&#123;</span><br><span class="line">                x = num;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">//当 num=x 时，票数 count 自增 1 ；否则，票数 count 自减 1</span></span><br><span class="line">            <span class="keyword">if</span>(num == x)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(<em>N</em>) ：数组长度为<em>N</em> ，遍历数组花费的时间。</li><li>空间复杂度 O(<em>1</em>) ： 只开辟了一个空间用于保存众数。</li></ul><h3 id="其他优秀解答"><a class="markdownIt-Anchor" href="#其他优秀解答"></a> 其他优秀解答</h3><blockquote><p>解题思路</p></blockquote><p>哈希表统计法：遍历数组 nums，用 HashMap 统计各数字的数量，最终超过数组长度一半的数字则为众数。此方法时间和空间复杂度均为 O(N)。</p><blockquote><p>代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">            map.put(num,map.getOrDefault(num,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(map.get(num)&gt;(nums.length/<span class="number">2</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 40. 最小的k个数</title>
      <link href="/2020/09/01/%E5%89%91%E6%8C%87-Offer-40-%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/"/>
      <url>/2020/09/01/%E5%89%91%E6%8C%87-Offer-40-%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="题目信息"><a class="markdownIt-Anchor" href="#题目信息"></a> 题目信息</h3><ul><li><p>题目：剑指 Offer 40. 最小的k个数</p></li><li><p>时间： 2020-09-01</p></li><li><p>题目链接：<a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/" target="_blank" rel="noopener">Leetcode</a></p></li><li><p>tag： 快速排序</p></li><li><p>难易程度：中等</p></li><li><p>题目描述：</p><p>输入整数数组 <code>arr</code> ，找出其中最小的 <code>k</code> 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p></li></ul><p><strong>示例1:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [3,2,1], k = 2</span><br><span class="line">输出：[1,2] 或者 [2,1]</span><br></pre></td></tr></table></figure><p><strong>示例2:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [0,1,2,1], k = 1</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><blockquote><p>提示</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.0 &lt;= k &lt;= arr.length &lt;= 10000</span><br><span class="line">2.0 &lt;= arr[i] &lt;= 10000</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><blockquote><p>本题难点</p></blockquote><p>多种解题方案，快排，大根堆，二叉搜索树，计数排序</p><blockquote><p>具体思路</p></blockquote><p>快速排序的思想。快排的划分函数每次执行完后都能将数组分成两个部分，小于等于分界值 pivot 的元素的都会被放到数组的左边，大于的都会被放到数组的右边，然后返回分界值的下标。</p><p>我们的目的是寻找最小的 k 个数。假设经过一次 partition 操作，分界值 pivot元素位于下标 j，也就是说，左侧的数组有 j 个元素，是原数组中最小的 j 个数。那么：</p><ul><li><strong>k = j</strong>： 我们就找到了最小的 k 个数，就是左侧的数组；：</li><li><strong>k &lt; j</strong>： 则最小的 k 个数一定都在左侧数组中，我们只需要对左侧数组递归地 parition 即可；</li><li><strong>k &gt; j</strong>：则左侧数组中的 j 个数都属于最小的 k 个数，我们还需要在右侧数组中寻找最小的 k−j 个数，对右侧数组递归地 partition 即可。</li></ul><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr.length == <span class="number">0</span> || k == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//快排查找前k个数，第k个数的数组下标为k-1</span></span><br><span class="line">        <span class="keyword">return</span> findKthSmallest(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>,k-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findKthSmallest(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> l ,<span class="keyword">int</span> h , <span class="keyword">int</span> k)&#123;</span><br><span class="line">      <span class="comment">// 每快排切分1次，找到排序后下标为j的元素，如果j恰好等于k就返回j以及j左边所有的数；</span></span><br><span class="line">        <span class="keyword">int</span> j = partition(arr,l,h);</span><br><span class="line">        <span class="keyword">if</span>(j == k)&#123;</span><br><span class="line">            <span class="keyword">return</span> Arrays.copyOf(arr, j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 否则根据下标j与k的大小关系来决定继续切分左段还是右段。</span></span><br><span class="line">        <span class="keyword">return</span> j &gt; k ? findKthSmallest(arr,l,j-<span class="number">1</span>,k):findKthSmallest(arr,j+<span class="number">1</span>,h,k);        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 快排切分，返回下标j，使得比nums[j]小的数都在j的左边，比nums[j]大的数都在j的右边。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> l,<span class="keyword">int</span> h)</span></span>&#123;</span><br><span class="line">        <span class="comment">//切分元素</span></span><br><span class="line">        <span class="keyword">int</span> privot = arr[l];</span><br><span class="line">        <span class="keyword">int</span> i = l,j = h + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i != h &amp;&amp; arr[++i] &lt; privot);</span><br><span class="line">            <span class="keyword">while</span>(j != l &amp;&amp; arr[--j] &gt; privot);</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= j)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(arr,i,j);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr,l,j);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(<em>N</em>) ： 找下标为k的元素，第一次切分的时候需要遍历整个数组 (0 ~ n) 找到了下标是 j 的元素，假如 k 比 j 小的话，那么我们下次切分只要遍历数组 (0~k-1)的元素就行啦，总之可以看作每次调用 partition 遍历的元素数目都是上一次遍历的 1/2，因此时间复杂度是 N + N/2 + N/4 + … + N/N = 2N, 因此时间复杂度是 O(<em>N</em>)。</li><li>空间复杂度 O(<em>logN</em>) ： 递归调用的期望深度为O(<em>logN</em>)，每层需要的空间为 O(<em>1</em>)，只有常数个变量。</li></ul><h3 id="其他优秀解答"><a class="markdownIt-Anchor" href="#其他优秀解答"></a> 其他优秀解答</h3><blockquote><p>解题思路</p></blockquote><p>本题是求前 K 小，因此用一个容量为 K 的大根堆，每次 poll 出最大的数，那堆中保留的就是前 K 小啦（注意不是小根堆！小根堆的话需要把全部的元素都入堆，那是 O(NlogN)，就不是 O(NlogK)）这个方法比快排慢。</p><blockquote><p>代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保持堆的大小为K，然后遍历数组中的数字，遍历的时候做如下判断：</span></span><br><span class="line"><span class="comment">// 1. 若目前堆的大小小于K，将当前数字放入堆中。</span></span><br><span class="line"><span class="comment">// 2. 否则判断当前数字与大根堆堆顶元素的大小关系，如果当前数字比大根堆堆顶还大，这个数就直接跳过；</span></span><br><span class="line"><span class="comment">//    反之如果当前数字比大根堆堆顶小，先poll掉堆顶，再将该数字放入堆中。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 默认是小根堆，实现大根堆需要重写一下比较器。</span></span><br><span class="line">        Queue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((v1, v2) -&gt; v2 - v1);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pq.size() &lt; k) &#123;</span><br><span class="line">                pq.offer(num);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &lt; pq.peek()) &#123;</span><br><span class="line">                pq.poll();</span><br><span class="line">                pq.offer(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回堆中的元素</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[pq.size()];</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num: pq) &#123;</span><br><span class="line">            res[idx++] = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>解题思路</p></blockquote><p>BST 相对于前两种方法没那么常见，但是也很简单，和大根堆的思路差不多，与前两种方法相比，BST 有一个好处是求得的前K大的数字是有序的。</p><blockquote><p>代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// TreeMap的key是数字, value是该数字的个数。</span></span><br><span class="line">        <span class="comment">// cnt表示当前map总共存了多少个数字。</span></span><br><span class="line">        TreeMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: arr) &#123;</span><br><span class="line">            <span class="comment">// 1. 遍历数组，若当前map中的数字个数小于k，则map中当前数字对应个数+1</span></span><br><span class="line">            <span class="keyword">if</span> (cnt &lt; k) &#123;</span><br><span class="line">                map.put(num, map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">                cnt++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">// 2. 否则，取出map中最大的Key（即最大的数字), 判断当前数字与map中最大数字的大小关系：</span></span><br><span class="line">            <span class="comment">//    若当前数字比map中最大的数字还大，就直接忽略；</span></span><br><span class="line">            <span class="comment">//    若当前数字比map中最大的数字小，则将当前数字加入map中，并将map中的最大数字的个数-1。</span></span><br><span class="line">            Map.Entry&lt;Integer, Integer&gt; entry = map.lastEntry();</span><br><span class="line">            <span class="keyword">if</span> (entry.getKey() &gt; num) &#123;</span><br><span class="line">                map.put(num, map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (entry.getValue() == <span class="number">1</span>) &#123;</span><br><span class="line">                    map.pollLastEntry();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    map.put(entry.getKey(), entry.getValue() - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最后返回map中的元素</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry: map.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">int</span> freq = entry.getValue();</span><br><span class="line">            <span class="keyword">while</span> (freq-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                res[idx++] = entry.getKey();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>解题思路</p></blockquote><p>数据范围有限时直接计数排序就行了：O(<em>N)</em></p><blockquote><p>代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 统计每个数字出现的次数</span></span><br><span class="line">        <span class="keyword">int</span>[] counter = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10001</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: arr) &#123;</span><br><span class="line">            counter[num]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据counter数组从头找出k个数作为返回结果</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num = <span class="number">0</span>; num &lt; counter.length; num++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (counter[num]-- &gt; <span class="number">0</span> &amp;&amp; idx &lt; k) &#123;</span><br><span class="line">                res[idx++] = num;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (idx == k) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 快速排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 41. 数据流中的中位数</title>
      <link href="/2020/08/31/%E5%89%91%E6%8C%87-Offer-41-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
      <url>/2020/08/31/%E5%89%91%E6%8C%87-Offer-41-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="题目信息"><a class="markdownIt-Anchor" href="#题目信息"></a> 题目信息</h3><ul><li><p>题目：剑指 Offer 41. 数据流中的中位数</p></li><li><p>时间： 2020-08-31</p></li><li><p>题目链接：<a href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/" target="_blank" rel="noopener">Leetcode</a></p></li><li><p>tag：  大根堆 小根堆</p></li><li><p>难易程度：中等</p></li><li><p>题目描述：</p><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p><p>设计一个支持以下两种操作的数据结构：</p><ul><li>void addNum(int num) - 从数据流中添加一个整数到数据结构中。</li><li>double findMedian() - 返回目前所有元素的中位数。</li></ul></li></ul><p><strong>示例1:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">["MedianFinder","addNum","addNum","findMedian","addNum","findMedian"]</span><br><span class="line">[[],[1],[2],[],[3],[]]</span><br><span class="line">输出：[null,null,null,1.50000,null,2.00000]</span><br></pre></td></tr></table></figure><p><strong>示例2:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">["MedianFinder","addNum","findMedian","addNum","findMedian"]</span><br><span class="line">[[],[2],[],[3],[]]</span><br><span class="line">输出：[null,null,2.00000,null,2.50000]</span><br></pre></td></tr></table></figure><blockquote><p>提示</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最多会对 addNum、findMedia进行 50000 次调用。</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><blockquote><p>本题难点</p></blockquote><p>给定一长度为 N 的无序数组，其中位数的计算方法：首先对数组执行排序（使用 O(NlogN) 时间），然后返回中间元素即可（使用 O(1) 时间）。如何更好的优化时间复杂度</p><blockquote><p>具体思路</p></blockquote><p>建立一个 <strong>大根堆</strong> Left和<strong>小顶堆</strong> Right   ，各保存列表的一半元素，且规定：</p><ul><li>Left 保存 <strong>较小</strong> 的一半，长度为 N/2（ <em>N</em> 为偶数）或 N+1/2 (<em>N</em> 为奇数）；</li><li>Right保存 <strong>较大</strong> 的一半，长度为 N/2（ <em>N</em> 为偶数）或 N+1/2 (<em>N</em> 为奇数）；</li></ul><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> </span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; left;</span><br><span class="line">    Queue&lt;Integer&gt; right;</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MedianFinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//大根堆，堆顶元素最大，存较小的数</span></span><br><span class="line">        left = <span class="keyword">new</span> PriorityQueue&lt;&gt;((x,y) -&gt; (y - x));</span><br><span class="line">        <span class="comment">//小根堆，堆顶元素最小，存较大的数</span></span><br><span class="line">        right = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保证右边的小根堆数全部大于左边的大根堆的数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当前数据流中元素的个数为偶数时，即左半边大小和右半边大小相等时，</span></span><br><span class="line">        <span class="comment">//新添加的元素要插入到右半边的小根堆中，添加后数据流元素个数为奇数，方便后面取中位数</span></span><br><span class="line">        <span class="comment">//因为左半边的大根堆元素都要小于右半边，新插入的元素不一定比左半边元素原来的大</span></span><br><span class="line">        <span class="comment">//利用左半边大根堆的特点，先将元素插入左半边，取出堆顶元素即为最大值再插入右半边的小根堆</span></span><br><span class="line">        <span class="keyword">if</span>(left.size() == right.size())&#123;</span><br><span class="line">            left.add(num);</span><br><span class="line">            right.add(left.poll());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            right.add(num);</span><br><span class="line">            left.add(right.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当数据流中的个数为奇数时，中位数为右半边小根堆的最小值</span></span><br><span class="line">        <span class="comment">//当数据流中的个数为偶数时，中位数位左半边大根堆的最大值和右半边小根堆的最小值的平均</span></span><br><span class="line">        <span class="keyword">return</span> left.size() == right.size() ? (left.peek() + right.peek()) / <span class="number">2.0</span> : right.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MedianFinder object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MedianFinder obj = new MedianFinder();</span></span><br><span class="line"><span class="comment"> * obj.addNum(num);</span></span><br><span class="line"><span class="comment"> * double param_2 = obj.findMedian();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(<em>1</em>) ： 获取堆顶元素使用 O(1) 时间；</li><li>空间复杂度 O(<em>logN</em>) ： 堆的插入和弹出操作使用 O(<em>logN</em>) 时间。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大根堆 </tag>
            
            <tag> 小根堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 42. 连续子数组的最大和</title>
      <link href="/2020/08/30/%E5%89%91%E6%8C%87-Offer-42-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/"/>
      <url>/2020/08/30/%E5%89%91%E6%8C%87-Offer-42-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h3 id="题目信息"><a class="markdownIt-Anchor" href="#题目信息"></a> 题目信息</h3><ul><li><p>题目：剑指 Offer 42. 连续子数组的最大和</p></li><li><p>时间： 2020-08-30</p></li><li><p>题目链接：<a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/" target="_blank" rel="noopener">Leetcode</a></p></li><li><p>tag：  动态规划</p></li><li><p>难易程度：简单</p></li><li><p>题目描述：</p><p>输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p><p>要求时间复杂度为O(n)。</p></li></ul><p><strong>示例:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure><blockquote><p>提示</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 1 &lt;= arr.length &lt;= 10^5</span><br><span class="line">2. -100 &lt;= arr[i] &lt;= 100</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><blockquote><p>本题难点</p></blockquote><table><thead><tr><th style="text-align:center">常见解法</th><th style="text-align:center">时间复杂度</th><th style="text-align:center">空间复杂度</th></tr></thead><tbody><tr><td style="text-align:center">暴力搜索</td><td style="text-align:center">O(N^2)</td><td style="text-align:center">O(1)</td></tr><tr><td style="text-align:center">分治思想</td><td style="text-align:center">O(NlogN)</td><td style="text-align:center">O(logN)</td></tr><tr><td style="text-align:center">动态规划</td><td style="text-align:center">O(N)</td><td style="text-align:center">O(1)</td></tr></tbody></table><blockquote><p>具体思路</p></blockquote><p>动态规划</p><ul><li><strong>状态定义</strong>：设动态规划列表 dp ，dp[i]]代表以元素 nums[i] 为结尾的连续子数组最大和。</li><li><strong>转移方程</strong>： 若 dp[i−1]≤0 ，说明 dp[i−1] 对 dp[i] 产生负贡献，即 dp[i−1]+nums[i] 还不如 nums[i] 本身大。<ul><li>当dp[i-1]&gt;0时，执行dp[i]=dp[i-1] + nums[i]</li><li>当dp[i-1]&lt;0时，执行dp[i]=nums[i]</li></ul></li><li>**初始状态：**dp[0] = nums[0]</li></ul><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> former = <span class="number">0</span>;<span class="comment">//用于记录dp[i-1]的值，对于dp[0]而言，其前面的dp[-1]=0</span></span><br><span class="line">        <span class="keyword">int</span> cur= nums[<span class="number">0</span>];<span class="comment">//用于记录dp[i]的值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num: nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(former &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                cur = num;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(former &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                cur = former + num;</span><br><span class="line">            &#125;<span class="comment">//这两句话等同于 cur = Math.max(former,0) + num;                </span></span><br><span class="line">            former = cur;</span><br><span class="line">            sum = Math.max(sum,cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(<em>N</em>) ： 线性遍历数组 nums 即可获得结果，使用 O(<em>N</em>) 时间。</li><li>空间复杂度 O(<em>1</em>) ： 使用常数大小的额外空间。</li></ul><h3 id="其他优秀解答"><a class="markdownIt-Anchor" href="#其他优秀解答"></a> 其他优秀解答</h3><blockquote><p>解题思路</p></blockquote><p>分治法，我们把数组nums以中间位置（mid)分为左（left)右(right)两部分. 那么有，<br />left = nums[0]…nums[m - 1] 和 right = nums[m + 1]…nums[n-1]</p><p>最大子序列和的位置有以下三种情况：</p><ul><li>考虑中间元素<code>nums[m]</code>, 跨越左右两部分，这里从中间元素开始，往左求出后缀最大，往右求出前缀最大, 保持连续性。</li><li>不考虑中间元素，最大子序列和出现在左半部分，递归求解左边部分最大子序列和</li><li>不考虑中间元素，最大子序列和出现在右半部分，递归求解右边部分最大子序列和</li></ul><blockquote><p>代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaximumSubarrayDivideConquer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArrayDividConquer</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">return</span> helper(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">      <span class="keyword">int</span> mid = (l + r) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">int</span> left = helper(nums, l, mid - <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">int</span> right = helper(nums, mid + <span class="number">1</span>, r);</span><br><span class="line">      <span class="keyword">int</span> leftMaxSum = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// left surfix maxSum start from index mid - 1 to l</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = mid - <span class="number">1</span>; i &gt;= l; i--) &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        leftMaxSum = Math.max(leftMaxSum, sum);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> rightMaxSum = <span class="number">0</span>;</span><br><span class="line">      sum = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// right prefix maxSum start from index mid + 1 to r</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = mid + <span class="number">1</span>; i &lt;= r; i++) &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        rightMaxSum = Math.max(sum, rightMaxSum);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// max(left, right, crossSum)</span></span><br><span class="line">      <span class="keyword">return</span> Math.max(leftMaxSum + rightMaxSum + nums[mid], Math.max(left, right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 43. 1～n整数中1出现的次数</title>
      <link href="/2020/08/29/%E5%89%91%E6%8C%87-Offer-43-1%EF%BD%9En%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/"/>
      <url>/2020/08/29/%E5%89%91%E6%8C%87-Offer-43-1%EF%BD%9En%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="题目信息"><a class="markdownIt-Anchor" href="#题目信息"></a> 题目信息</h3><ul><li><p>题目：剑指 Offer 43. 1～n整数中1出现的次数</p></li><li><p>时间： 2020-08-29</p></li><li><p>题目链接：<a href="https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/" target="_blank" rel="noopener">Leetcode</a></p></li><li><p>tag： 整除 取余 规律 递归</p></li><li><p>难易程度：中等</p></li><li><p>题目描述：</p><p>输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。</p><p>例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。</p></li></ul><p><strong>示例1:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 12</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure><p><strong>示例2:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 13</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure><blockquote><p>提示</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. 1 &lt;= n &lt; 2^31</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><blockquote><p>本题难点</p></blockquote><p>数字 n 是个 x 位数，记 n 的第 i 位为 n i ，则可将 n 写为 nx nx−1⋯n2 n1，n的位数都可能为1。</p><blockquote><p>具体思路</p></blockquote><p>将 1 ~ <em>n</em> 的个位、十位、百位、…的 1 出现次数相加，即为 1 出现的总次数。</p><p>某位中 11出现次数的计算方法：</p><p>根据当前位 cur 值的不同，分为以下三种情况：</p><ul><li><strong>cur=0</strong>：此位 1的出现次数只由高位 high决定，high×digit</li><li><strong>cur=1</strong>： 此位 1的出现次数只由高位 high和地位low决定，high×digit+low+1</li><li><strong>cur !=1</strong>：此位 1的出现次数只由高位 high决定，(high+1)×digit</li></ul><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countDigitOne</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//设计按照 “个位、十位、...” 的顺序计算</span></span><br><span class="line">        <span class="keyword">int</span> digit = <span class="number">1</span>,res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = n / <span class="number">10</span> ,cur  = n% <span class="number">10</span>,low = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">//当 high 和 cur 同时为 0 时，说明已经越过最高位，因此跳出</span></span><br><span class="line">        <span class="keyword">while</span>(high != <span class="number">0</span> || cur != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur == <span class="number">0</span>)&#123;</span><br><span class="line">                res += high * digit;                </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur == <span class="number">1</span>)&#123;</span><br><span class="line">                res += high * digit + low + <span class="number">1</span>;                </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res += (high + <span class="number">1</span>) * digit;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">//将 cur 加入 low ，组成下轮 low</span></span><br><span class="line">            low += cur * digit;</span><br><span class="line">          <span class="comment">//下轮 cur 是本轮 high 的最低位</span></span><br><span class="line">            cur = high % <span class="number">10</span>;</span><br><span class="line">          <span class="comment">//将本轮 high 最低位删除，得到下轮 high</span></span><br><span class="line">            high /= <span class="number">10</span>;</span><br><span class="line">          <span class="comment">//位因子每轮 × 10</span></span><br><span class="line">            digit *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(logn) ： 循环内的计算操作使用 O(1) 时间；循环次数为数字 n 的位数，即 log n ，因此循环使用 O(logn) 时间。</li><li>空间复杂度 O(1) ： 几个变量使用常数大小的额外空间。</li></ul><h3 id="其他优秀解答"><a class="markdownIt-Anchor" href="#其他优秀解答"></a> 其他优秀解答</h3><blockquote><p>解题思路</p></blockquote><p>f(n))函数的意思是1～n这n个整数的十进制表示中1出现的次数，将n拆分为两部分，最高一位的数字high和其他位的数字last，分别判断情况后将结果相加。</p><p><strong>示例1:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">例子如n=1234，high=1, pow=1000, last=234</span><br><span class="line"></span><br><span class="line">可以将数字范围分成两部分1~999和1000~1234</span><br><span class="line"></span><br><span class="line">1~999这个范围1的个数是f(pow-1)</span><br><span class="line">1000~1234这个范围1的个数需要分为两部分：</span><br><span class="line">千分位是1的个数：千分位为1的个数刚好就是234+1(last+1)，注意，这儿只看千分位，不看其他位</span><br><span class="line">其他位是1的个数：即是234中出现1的个数，为f(last)</span><br><span class="line">所以全部加起来是f(pow-1) + last + 1 + f(last);</span><br></pre></td></tr></table></figure><p><strong>示例2:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">例子如3234，high=3, pow=1000, last=234</span><br><span class="line"></span><br><span class="line">可以将数字范围分成两部分1~999，1000~1999，2000~2999和3000~3234</span><br><span class="line"></span><br><span class="line">1~999这个范围1的个数是f(pow-1)</span><br><span class="line">1000~1999这个范围1的个数需要分为两部分：</span><br><span class="line">千分位是1的个数：千分位为1的个数刚好就是pow，注意，这儿只看千分位，不看其他位</span><br><span class="line">其他位是1的个数：即是999中出现1的个数，为f(pow-1)</span><br><span class="line">2000~2999这个范围1的个数是f(pow-1)</span><br><span class="line">3000~3234这个范围1的个数是f(last)</span><br><span class="line">所以全部加起来是pow + high*f(pow-1) + f(last);</span><br></pre></td></tr></table></figure><blockquote><p>代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countDigitOne</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> f(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        String s = String.valueOf(n);</span><br><span class="line">        <span class="keyword">int</span> high = s.charAt(<span class="number">0</span>) - <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">int</span> pow = (<span class="keyword">int</span>) Math.pow(<span class="number">10</span>, s.length()-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> last = n - high*pow;</span><br><span class="line">        <span class="keyword">if</span> (high == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> f(pow-<span class="number">1</span>) + last + <span class="number">1</span> + f(last);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> pow + high*f(pow-<span class="number">1</span>) + f(last);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 规律 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 44. 数字序列中某一位的数字</title>
      <link href="/2020/08/28/%E5%89%91%E6%8C%87-Offer-44-%E6%95%B0%E5%AD%97%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9F%90%E4%B8%80%E4%BD%8D%E7%9A%84%E6%95%B0%E5%AD%97/"/>
      <url>/2020/08/28/%E5%89%91%E6%8C%87-Offer-44-%E6%95%B0%E5%AD%97%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9F%90%E4%B8%80%E4%BD%8D%E7%9A%84%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h3 id="题目信息"><a class="markdownIt-Anchor" href="#题目信息"></a> 题目信息</h3><ul><li><p>题目：剑指 Offer 44. 数字序列中某一位的数字</p></li><li><p>时间： 2020-08-28</p></li><li><p>题目链接：<a href="https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/" target="_blank" rel="noopener">Leetcode</a></p></li><li><p>tag： 规律</p></li><li><p>难易程度：中等</p></li><li><p>题目描述：</p><p>数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。</p><p>请写一个函数，求任意第n位对应的数字。</p></li></ul><p><strong>示例1:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><strong>示例2:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 11</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><blockquote><p>提示</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. 0 &lt;= n &lt; 2^31</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><blockquote><p>本题难点</p></blockquote><p>0&lt;n&lt;9时，第n位对应的数字为n。n&gt;9时，需要确定n对应的数字的位数，再确定n对应的数字，最后确定n对应数字的哪一位上。</p><blockquote><p>具体思路</p></blockquote><ol><li><p>将 101112⋯ 中的每一位称为 <strong>数位</strong> ，记为 n；</p></li><li><p>将 10,11,12,⋯ 称为 <strong>数字</strong> ，记为 num ；</p></li><li><p>数字 10是一个两位数，称此数字的 <strong>位数</strong> 为 2 ，记为 digit；</p></li><li><p>每 digit 位数的起始数字（即：1,10,100,⋯），记为 start 。</p><table><thead><tr><th style="text-align:center">数字范围</th><th style="text-align:center">位数</th><th style="text-align:center">数字数量</th><th style="text-align:center">数位数量</th></tr></thead><tbody><tr><td style="text-align:center">1～9</td><td style="text-align:center">1</td><td style="text-align:center">9</td><td style="text-align:center">9</td></tr><tr><td style="text-align:center">10～99</td><td style="text-align:center">2</td><td style="text-align:center">90</td><td style="text-align:center">180</td></tr><tr><td style="text-align:center">100～999</td><td style="text-align:center">3</td><td style="text-align:center">900</td><td style="text-align:center">2700</td></tr><tr><td style="text-align:center">…</td><td style="text-align:center">…</td><td style="text-align:center">…</td><td style="text-align:center">…</td></tr><tr><td style="text-align:center">start~end</td><td style="text-align:center">digit</td><td style="text-align:center">9*start</td><td style="text-align:center">9* start * digit</td></tr></tbody></table></li></ol><p>求解步骤：</p><ul><li>确定 n所在 <strong>数字</strong> 的 <strong>位数</strong> ，记为 digit ；</li><li>确定 n所在的 <strong>数字</strong> ，记为 num ；</li><li>确定 n是 num中的哪一数位，并返回结果。</li></ul><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findNthDigit</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> digit = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> start =<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> count = <span class="number">9</span>;</span><br><span class="line">      <span class="comment">//确定所求数位的所在数字的位数</span></span><br><span class="line">        <span class="keyword">while</span>(n &gt; count)&#123;</span><br><span class="line">            n -= count;</span><br><span class="line">            digit += <span class="number">1</span>;</span><br><span class="line">            start *= <span class="number">10</span>;</span><br><span class="line">            count = digit * start * <span class="number">9</span>; </span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 确定所求数位所在的数字</span></span><br><span class="line">        <span class="keyword">long</span> num = start + (n -<span class="number">1</span>) / digit;</span><br><span class="line">      <span class="comment">//确定所求数位在 num 的哪一数位</span></span><br><span class="line">        <span class="keyword">return</span> Long.toString(num).charAt((n-<span class="number">1</span>)%digit) - <span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(logn) ： 所求数位 n 对应数字 num 的位数 digit 最大为 O(logn) ；第一步最多循环 O(logn) 次；第三步中将 num 转化为字符串使用 O(logn) 时间；因此总体为 O(logn) 。</li><li>空间复杂度 O(logn) ： 将数字 num 转化为字符串 <code>str(num)</code> ，占用 O(log⁡n)的额外空间。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 规律 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 45. 把数组排成最小的数</title>
      <link href="/2020/08/27/%E5%89%91%E6%8C%87-Offer-45-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/"/>
      <url>/2020/08/27/%E5%89%91%E6%8C%87-Offer-45-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="题目信息"><a class="markdownIt-Anchor" href="#题目信息"></a> 题目信息</h3><ul><li><p>题目：剑指 Offer 45. 把数组排成最小的数</p></li><li><p>时间： 2020-08-27</p></li><li><p>题目链接：<a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/" target="_blank" rel="noopener">Leetcode</a></p></li><li><p>tag：  快速排序</p></li><li><p>难易程度：中等</p></li><li><p>题目描述：</p><p>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p></li></ul><p><strong>示例1:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [10,2]</span><br><span class="line">输出: "102"</span><br></pre></td></tr></table></figure><p><strong>示例2:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,30,34,5,9]</span><br><span class="line">输出: "3033459"</span><br></pre></td></tr></table></figure><blockquote><p>提示</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. 0 &lt; nums.length &lt;= 100</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><blockquote><p>本题难点</p></blockquote><p>此题求拼接起来的 “最小数字” ，本质上是一个排序问题。</p><blockquote><p>具体思路</p></blockquote><p>字符串 xy &lt; yx , yz &lt; zy ，需证明 xz &lt; zx 一定成立。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        String[] strs = <span class="keyword">new</span> String[nums.length];</span><br><span class="line">      <span class="comment">//初始化： 字符串列表 strs ，保存各数字的字符串格式；</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            strs[i] = String.valueOf(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//列表排序： 应用以上 “排序判断规则” ，对 strs 执行排序；</span></span><br><span class="line">        quickSort(strs,<span class="number">0</span>,strs.length - <span class="number">1</span>);</span><br><span class="line">      <span class="comment">//返回值： 拼接 strs 中的所有字符串，并返回。</span></span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(String s : strs)&#123;</span><br><span class="line">            res.append(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(String[] strs,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt;= r)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = l;</span><br><span class="line">        <span class="keyword">int</span> j = r;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">          <span class="comment">//若 右边+左边组合字符串大于 左边+右边组合字符串参数，则右边指针向左移</span></span><br><span class="line">            <span class="keyword">while</span>((strs[j] + strs[l]).compareTo(strs[l] + strs[j]) &gt;= <span class="number">0</span> &amp;&amp; i &lt; j)&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">//若 左边+右边组合字符串大于 右边+左边组合字符串参数，则左边指针向左移</span></span><br><span class="line">            <span class="keyword">while</span>((strs[i] + strs[l]).compareTo(strs[l] + strs[i]) &lt;= <span class="number">0</span> &amp;&amp; i &lt; j)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">//两字符串交换位置</span></span><br><span class="line">            swap(strs,i,j);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//将第一个字符串交换到最终位置，左边字符串小于，右边字符串大于</span></span><br><span class="line">        swap(strs,l,i);</span><br><span class="line">      <span class="comment">//递归排序左边字符串数组</span></span><br><span class="line">        quickSort(strs,l,j-<span class="number">1</span>);</span><br><span class="line">      <span class="comment">//递归排序右边字符串数组</span></span><br><span class="line">        quickSort(strs,j+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(String[] strs,<span class="keyword">int</span> i ,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        String temp = strs[i];</span><br><span class="line">        strs[i] = strs[j];</span><br><span class="line">        strs[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(NlogN) ：N 为最终返回值的字符数量（ strs 列表的长度 ≤N ）；使用快排或内置函数的平均时间复杂度为 O(NlogN) ，最差为 O(N ^2 ) 。</li><li>空间复杂度 O(<em>N</em>) ： 字符串列表 strs占用线性大小的额外空间。</li></ul><h3 id="其他优秀解答"><a class="markdownIt-Anchor" href="#其他优秀解答"></a> 其他优秀解答</h3><blockquote><p>解题思路</p></blockquote><p>Java 内置数组排序函数： <code>(x, y) -&gt; (x + y).compareTo(y + x)</code></p><blockquote><p>代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        String[] strs = <span class="keyword">new</span> String[nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) </span><br><span class="line">            strs[i] = String.valueOf(nums[i]);</span><br><span class="line">        Arrays.sort(strs, (x, y) -&gt; (x + y).compareTo(y + x));</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(String s : strs)</span><br><span class="line">            res.append(s);</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 快速排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 46. 把数字翻译成字符串</title>
      <link href="/2020/08/26/%E5%89%91%E6%8C%87-Offer-46-%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2020/08/26/%E5%89%91%E6%8C%87-Offer-46-%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h3 id="题目信息"><a class="markdownIt-Anchor" href="#题目信息"></a> 题目信息</h3><ul><li><p>题目：剑指 Offer 46. 把数字翻译成字符串</p></li><li><p>时间： 2020-08-26</p></li><li><p>题目链接：<a href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/" target="_blank" rel="noopener">Leetcode</a></p></li><li><p>tag：  动态规划</p></li><li><p>难易程度：中等</p></li><li><p>题目描述：</p><p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p></li></ul><p><strong>示例:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 12258</span><br><span class="line">输出: 5</span><br><span class="line">解释: 12258有5种不同的翻译，分别是"bccfi", "bwfi", "bczi", "mcfi"和"mzi"</span><br></pre></td></tr></table></figure><blockquote><p>提示</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. 0 &lt;= num &lt; 2^31</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><blockquote><p>本题难点</p></blockquote><p>当数字中包含两位数时，存在两种不同的组合情况。</p><blockquote><p>具体思路</p></blockquote><p>动态规划：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable rowspacing="0.15999999999999992em" columnalign="left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext> num </mtext><mo>=</mo><msub><mi>x</mi><mn>1</mn></msub><msub><mi>x</mi><mn>2</mn></msub><mo>…</mo><msub><mi>x</mi><mrow><mi>i</mi><mo>−</mo><mn>2</mn></mrow></msub><msub><mi>x</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><msub><mi>x</mi><mi>i</mi></msub><mo>…</mo><msub><mi>x</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><msub><mi>x</mi><mi>n</mi></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext> (例如 </mtext><mrow><mo>:</mo><mspace width="1em"/><mn>12258</mn><mo>=</mo><msub><mi>x</mi><mn>1</mn></msub><msub><mi>x</mi><mn>2</mn></msub><msub><mi>x</mi><mn>3</mn></msub><msub><mi>x</mi><mn>4</mn></msub><msub><mi>x</mi><mn>5</mn></msub><mo fence="true">)</mo></mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnalign="left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext> 设 </mtext><msub><mi>x</mi><mn>1</mn></msub><msub><mi>x</mi><mn>2</mn></msub><mo>…</mo><msub><mi>x</mi><mrow><mi>i</mi><mo>−</mo><mn>2</mn></mrow></msub><mtext> 的翻译方案数量为 </mtext><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext> 设 </mtext><msub><mi>x</mi><mn>1</mn></msub><msub><mi>x</mi><mn>2</mn></msub><mo>…</mo><msub><mi>x</mi><mrow><mi>i</mi><mo>−</mo><mn>2</mn></mrow></msub><msub><mi>x</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mtext> 的翻译方案数量为 </mtext><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{array}{l}\text { num }=x_{1} x_{2} \ldots x_{i-2} x_{i-1} x_{i} \ldots x_{n-1} x_{n} \\\text { (例如 }\left.: \quad 12258=x_{1} x_{2} x_{3} x_{4} x_{5}\right) \\\\{\left[\begin{array}{l}\text { 设 } x_{1} x_{2} \ldots x_{i-2} \text { 的翻译方案数量为 } f(i-2) \\\text { 设 } x_{1} x_{2} \ldots x_{i-2} x_{i-1} \text { 的翻译方案数量为 } f(i-1)\end{array}\right.}\end{array}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:6.000030000000001em;vertical-align:-2.7500150000000003em;"></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.250015em;"><span style="top:-5.860015em;"><span class="pstrut" style="height:3.45em;"></span><span class="mord"><span class="mord text"><span class="mord"> num </span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-4.6600150000000005em;"><span class="pstrut" style="height:3.45em;"></span><span class="mord"><span class="mord text"><span class="mord"> (</span><span class="mord cjk_fallback">例如</span><span class="mord"> </span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen nulldelimiter"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:1em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mord">2</span><span class="mord">5</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">5</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span><span style="top:-3.4600149999999994em;"><span class="pstrut" style="height:3.45em;"></span><span class="mord"></span></span><span style="top:-1.6500149999999998em;"><span class="pstrut" style="height:3.45em;"></span><span class="mord"><span class="mord"><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord"> </span><span class="mord cjk_fallback">设</span><span class="mord"> </span></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mord text"><span class="mord"> </span><span class="mord cjk_fallback">的翻译方案数量为</span><span class="mord"> </span></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord"> </span><span class="mord cjk_fallback">设</span><span class="mord"> </span></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mord text"><span class="mord"> </span><span class="mord cjk_fallback">的翻译方案数量为</span><span class="mord"> </span></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.7500150000000003em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">{</mo><mtable rowspacing="0.15999999999999992em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext> 当整体翻译 </mtext><msub><mi>x</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><msub><mi>x</mi><mi>i</mi></msub><mtext> 时, </mtext></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>x</mi><mn>1</mn></msub><msub><mi>x</mi><mn>2</mn></msub><mo>…</mo><msub><mi>x</mi><mrow><mi>i</mi><mo>−</mo><mn>2</mn></mrow></msub><msub><mi>x</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><msub><mi>x</mi><mi>i</mi></msub><mtext> 的方案数为 </mtext><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext> 当单独翻译 </mtext><msub><mi>x</mi><mi>i</mi></msub><mtext> 时, </mtext></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>x</mi><mn>1</mn></msub><msub><mi>x</mi><mn>2</mn></msub><mo>…</mo><msub><mi>x</mi><mrow><mi>i</mi><mo>−</mo><mn>2</mn></mrow></msub><msub><mi>x</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><msub><mi>x</mi><mi>i</mi></msub><mtext> 的方案数为 </mtext><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\left\{\begin{array}{ll}\text { 当整体翻译 } x_{i-1} x_{i} \text { 时, } &amp; x_{1} x_{2} \ldots x_{i-2} x_{i-1} x_{i} \text { 的方案数为 } f(i-2) \\\text { 当单独翻译 } x_{i} \text { 时, } &amp; x_{1} x_{2} \ldots x_{i-2} x_{i-1} x_{i} \text { 的方案数为 } f(i-1)\end{array}\right.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">{</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord"> </span><span class="mord cjk_fallback">当整体翻译</span><span class="mord"> </span></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord text"><span class="mord"> </span><span class="mord cjk_fallback">时</span><span class="mord">, </span></span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord"> </span><span class="mord cjk_fallback">当单独翻译</span><span class="mord"> </span></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord text"><span class="mord"> </span><span class="mord cjk_fallback">时</span><span class="mord">, </span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord text"><span class="mord"> </span><span class="mord cjk_fallback">的方案数为</span><span class="mord"> </span></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord text"><span class="mord"> </span><span class="mord cjk_fallback">的方案数为</span><span class="mord"> </span></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/04/NzK1dH.png" alt="NzK1dH.png" /></p><p>递推关系：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.15999999999999992em" columnalign="center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo separator="true">,</mo><mtext> 若数字 </mtext><msub><mi>x</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><msub><mi>x</mi><mi>i</mi></msub><mtext> 可被翻译 </mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo separator="true">,</mo><mtext> 若数字 </mtext><msub><mi>x</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><msub><mi>x</mi><mi>i</mi></msub><mtext> 不可被翻译 </mtext></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">f(i)=\left\{\begin{array}{cc}f(i-2)+f(i-1) &amp; , \text { 若数字 } x_{i-1} x_{i} \text { 可被翻译 } \\f(i-1) &amp; , \text { 若数字 } x_{i-1} x_{i} \text { 不可被翻译 }\end{array}\right.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">{</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class="mord"> </span><span class="mord cjk_fallback">若数字</span><span class="mord"> </span></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord text"><span class="mord"> </span><span class="mord cjk_fallback">可被翻译</span><span class="mord"> </span></span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class="mord"> </span><span class="mord cjk_fallback">若数字</span><span class="mord"> </span></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord text"><span class="mord"> </span><span class="mord cjk_fallback">不可被翻译</span><span class="mord"> </span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.15999999999999992em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>+</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>2</mn><mo stretchy="false">]</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo separator="true">,</mo><mn>10</mn><msub><mi>x</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>x</mi><mi>i</mi></msub><mo>∈</mo><mo stretchy="false">[</mo><mn>10</mn><mo separator="true">,</mo><mn>25</mn><mo stretchy="false">]</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo separator="true">,</mo><mn>10</mn><msub><mi>x</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>x</mi><mi>i</mi></msub><mo>∈</mo><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>10</mn><mo stretchy="false">)</mo><mo>∪</mo><mo stretchy="false">(</mo><mn>25</mn><mo separator="true">,</mo><mn>99</mn><mo stretchy="false">]</mo></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">d p[i]=\left\{\begin{array}{ll}d p[i-1]+d p[i-2] &amp; , 10 x_{i-1}+x_{i} \in[10,25] \\d p[i-1] &amp; , 10 x_{i-1}+x_{i} \in[0,10) \cup(25,99]\end{array}\right.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">{</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span><span class="mclose">]</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">5</span><span class="mclose">]</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">9</span><span class="mord">9</span><span class="mclose">]</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/04/NzMptA.png" alt="NzMptA.png" /></p><blockquote><p>注意：dp[0]=dp[1]=1 ，即 “无数字” 和 “第 1 位数字” 的翻译方法数量均为 1</p></blockquote><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">translateNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        String s = String.valueOf(num);</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span> ,b = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= s.length(); i++)&#123;</span><br><span class="line">            String tmp = s.substring(i - <span class="number">2</span>, i);</span><br><span class="line">            <span class="keyword">int</span> c = tmp.compareTo(<span class="string">"10"</span>) &gt;= <span class="number">0</span> &amp;&amp; tmp.compareTo(<span class="string">"25"</span>) &lt;= <span class="number">0</span> ? a+b:a;</span><br><span class="line">            b = a;</span><br><span class="line">            a = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(<em>N</em>) ： <em>N</em> 为字符串 s的长度（即数字 num 的位数 log⁡(num)），其决定了循环次数。</li><li>空间复杂度 O(<em>N</em>) ：  字符串 s使用 O(N) 大小的额外空间。</li></ul><h3 id="其他优秀解答"><a class="markdownIt-Anchor" href="#其他优秀解答"></a> 其他优秀解答</h3><blockquote><p>解题思路</p></blockquote><p>利用求余运算 num%10 和求整运算 num/10 ，可获取数字 num 的各位数字（获取顺序为个位、十位、百位…）。因此，可通过 <strong>求余</strong> 和 <strong>求整</strong> 运算实现 <strong>从右向左</strong> 的遍历计算。动态规划 “对称性” ，可知从右向左的计算是正确的。</p><blockquote><p>代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">translateNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>, x, y = num % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">while</span>(num != <span class="number">0</span>) &#123;</span><br><span class="line">            num /= <span class="number">10</span>;</span><br><span class="line">            x = num % <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">int</span> tmp = <span class="number">10</span> * x + y;</span><br><span class="line">            <span class="keyword">int</span> c = (tmp &gt;= <span class="number">10</span> &amp;&amp; tmp &lt;= <span class="number">25</span>) ? a + b : a;</span><br><span class="line">            b = a;</span><br><span class="line">            a = c;</span><br><span class="line">            y = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 47. 礼物的最大价值</title>
      <link href="/2020/08/25/%E5%89%91%E6%8C%87-Offer-47-%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/"/>
      <url>/2020/08/25/%E5%89%91%E6%8C%87-Offer-47-%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h3 id="题目信息"><a class="markdownIt-Anchor" href="#题目信息"></a> 题目信息</h3><ul><li><p>题目：剑指 Offer 47. 礼物的最大价值</p></li><li><p>时间： 2020-08-25</p></li><li><p>题目链接：<a href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/" target="_blank" rel="noopener">Leetcode</a></p></li><li><p>tag：动态规划</p></li><li><p>难易程度：中等</p></li><li><p>题目描述：</p><p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p></li></ul><p><strong>示例:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[</span><br><span class="line">  [1,3,1],</span><br><span class="line">  [1,5,1],</span><br><span class="line">  [4,2,1]</span><br><span class="line">]</span><br><span class="line">输出: 12</span><br><span class="line">解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物</span><br></pre></td></tr></table></figure><blockquote><p>注意</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 0 &lt; grid.length &lt;= 200</span><br><span class="line">2. 0 &lt; grid[0].length &lt;= 200</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><blockquote><p>本题难点</p></blockquote><p>根据题目说明，某单元格可能从上边单元格或左边单元格到达。</p><blockquote><p>具体思路</p></blockquote><p>动态规划解决此问题，转移方程f(i,j)=max[f(i,j−1),f(i−1,j)]+grid(i,j)</p><p>设动态规划矩阵 dp(i,j) 代表从棋盘的左上角开始，到达单元格 (i,j) 时能拿到礼物的最大累计价值。</p><ul><li>当 i = 0 且 j = 0时，起始元素。</li><li>当 i = 0 且 j != 0时，为矩阵第一行元素，只可从左边到达；</li><li>当 i != 0 且 j = 0时，为矩阵第一列元素，只可从上边到达；</li><li>当 i != 0 且 j != 0时，可从左边或上边到达；</li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.15999999999999992em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>g</mi><mi>r</mi><mi>i</mi><mi>d</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo separator="true">,</mo><mi>i</mi><mo>=</mo><mn>0</mn><mo separator="true">,</mo><mi>j</mi><mo>=</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi mathvariant="normal">grid</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo><mo>+</mo><mi>d</mi><mi>p</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo separator="true">,</mo><mi>i</mi><mo>=</mo><mn>0</mn><mo separator="true">,</mo><mi>j</mi><mi mathvariant="normal">≠</mi><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi mathvariant="normal">grid</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo><mo>+</mo><mi>d</mi><mi>p</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo separator="true">,</mo><mi>i</mi><mi mathvariant="normal">≠</mi><mn>0</mn><mo separator="true">,</mo><mi>j</mi><mo>=</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi mathvariant="normal">grid</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo><mo>+</mo><mi>max</mi><mo>⁡</mo><mo stretchy="false">[</mo><mi>d</mi><mi>p</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo separator="true">,</mo><mi>i</mi><mi mathvariant="normal">≠</mi><mn>0</mn><mo separator="true">,</mo><mi>j</mi><mi mathvariant="normal">≠</mi><mn>0</mn></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">d p(i, j)=\left\{\begin{array}{ll}g r i d(i, j) &amp; , i=0, j=0 \\\operatorname{grid}(i, j)+d p(i, j-1) &amp; , i=0, j \neq 0 \\\operatorname{grid}(i, j)+d p(i-1, j) &amp; , i \neq 0, j=0 \\\operatorname{grid}(i, j)+\max [d p(i-1, j), d p(i, j-1)] &amp; , i \neq 0, j \neq 0\end{array}\right.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:4.80004em;vertical-align:-2.15002em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65002em;"><span style="top:-1.8999899999999998em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-1.8999899999999998em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-2.1999899999999997em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-3.15001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.30001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.60001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.90002em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop"><span class="mord mathrm" style="margin-right:0.01389em;">g</span><span class="mord mathrm">r</span><span class="mord mathrm">i</span><span class="mord mathrm">d</span></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop"><span class="mord mathrm" style="margin-right:0.01389em;">g</span><span class="mord mathrm">r</span><span class="mord mathrm">i</span><span class="mord mathrm">d</span></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop"><span class="mord mathrm" style="margin-right:0.01389em;">g</span><span class="mord mathrm">r</span><span class="mord mathrm">i</span><span class="mord mathrm">d</span></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mop">max</span><span class="mopen">[</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mclose">]</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/04/NzKKsO.png" alt="NzKKsO.png" /></p><blockquote><p>注意：由于 dp[i] [j] 只与 dp[i−1] [j] , dp[i] [j−1] , grid[ i ] [ j ]有关系，因此可以将原矩阵 grid 用作 dp 矩阵，即直接在 grid 上修改即可。</p></blockquote><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">              <span class="comment">// dp[0][0]=grid[0][0]</span></span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>) grid[i][j] += grid[i][j - <span class="number">1</span>] ;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">0</span>) grid[i][j] += grid[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">else</span> grid[i][j] += Math.max(grid[i][j - <span class="number">1</span>], grid[i - <span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//dp[m−1][n−1] ，m,n 分别为矩阵的行高和列宽，即返回 dp 矩阵右下角元素</span></span><br><span class="line">        <span class="keyword">return</span> grid[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(MN) ： M，N分别为矩阵行高、列宽；动态规划需遍历整个 grid 矩阵。</li><li>空间复杂度 O(1) ：  原地修改使用常数大小的额外空间。</li></ul><h3 id="其他优秀解答"><a class="markdownIt-Anchor" href="#其他优秀解答"></a> 其他优秀解答</h3><blockquote><p>解题思路</p></blockquote><p>多开辟一个二维数组的空间，节省边界值的判断。</p><blockquote><p>代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = grid.length;</span><br><span class="line">        <span class="keyword">int</span> col = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[row+<span class="number">1</span>][col+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= row;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= col; j++)&#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]) + grid[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[row][col];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 48. 最长不含重复字符的子字符串</title>
      <link href="/2020/08/24/%E5%89%91%E6%8C%87-Offer-48-%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2020/08/24/%E5%89%91%E6%8C%87-Offer-48-%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h3 id="题目信息"><a class="markdownIt-Anchor" href="#题目信息"></a> 题目信息</h3><ul><li><p>题目：剑指 Offer 48. 最长不含重复字符的子字符串</p></li><li><p>时间： 2020-08-24</p></li><li><p>题目链接：<a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/" target="_blank" rel="noopener">Leetcode</a></p></li><li><p>tag：  动态规划 哈希表</p></li><li><p>难易程度：中等</p></li><li><p>题目描述：</p><p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p></li></ul><p><strong>示例1:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: "abcabcbb"</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。</span><br></pre></td></tr></table></figure><p><strong>示例2:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: "bbbbb"</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。</span><br></pre></td></tr></table></figure><p><strong>示例3:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: "pwwkew"</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><blockquote><p>注意</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. s.length <span class="tag">&lt;<span class="name">=</span> <span class="attr">40000</span></span></span><br></pre></td></tr></table></figure><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><blockquote><p>本题难点</p></blockquote><p>长度为 N 的字符串共有 (1+N)N/2 个子字符串（复杂度为 O(N^2 ) ），判断长度为 N 的字符串是否有重复字符的复杂度为 O(N) ，使用暴力法解决的复杂度为 O(N^3) 。</p><blockquote><p>具体思路</p></blockquote><p>考虑使用动态规划降低时间复杂度。</p><ul><li><strong>状态定义</strong>：设动态规划列表 dp ，dp[j] 代表以字符 s[j 为结尾的 “最长不重复子字符串” 的长度。</li><li><strong>转移方程</strong>：固定右边界 j ，设字符 s[j] 左边距离最近的相同字符为 s[i] ，即 s[i]=s[j] 。<ul><li>当 i&lt;0时，即 s[j] 左边无相同字符，则 dp[j]=dp[j−1]+1 ；</li><li>当 dp[j−1] &lt; j−i 时，说明字符 s[i] 在子字符串 dp[j−1] 区间之外 ，则 dp[j]=dp[j−1]+1 ；</li><li>当 dp[j−1] &gt; j−i 时，说明字符 s[i] 在子字符串 dp[j−1] 区间之中 ，则 dp[j] 的左边界由 s[i] 决定，即 dp[j]=j−i ；</li></ul></li></ul><blockquote><p>注意:当 i&lt;0 时，由于 dp[j−1]≤j 恒成立，因而 dp[j−1]&lt;j−i 恒成立，因此分支 1. 和 2. 可被合并。</p></blockquote><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.15999999999999992em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>+</mo><mn>1</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>&lt;</mo><mi>j</mi><mo>−</mo><mi>i</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>j</mi><mo>−</mo><mi>i</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>≥</mo><mi>j</mi><mo>−</mo><mi>i</mi></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">d p[j]=\left\{\begin{array}{ll}d p[j-1]+1 &amp; , d p[j-1]&lt;j-i \\j-i &amp; , d p[j-1] \geq j-i\end{array}\right.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">{</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">i</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/04/NzKmz6.png" alt="NzKmz6.png" /></p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; dic = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s.length(); j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = dic.getOrDefault(s.charAt(j), -<span class="number">1</span>); <span class="comment">// 获取索引 i</span></span><br><span class="line">            dic.put(s.charAt(j), j); <span class="comment">// 更新哈希表</span></span><br><span class="line">            tmp = tmp &lt; j - i ? tmp + <span class="number">1</span> : j - i; <span class="comment">// dp[j - 1] -&gt; dp[j]</span></span><br><span class="line">            res = Math.max(res, tmp); <span class="comment">// max(dp[j - 1], dp[j])</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(N) ：其中 N为字符串长度，动态规划需遍历计算 dp列表。</li><li>空间复杂度 O(1) ：   字符的 ASCII 码范围为 0 ~ 127 ，哈希表 dic 最多使用 O(128)=O(1) 大小的额外空间。</li></ul><h3 id="其他优秀解答"><a class="markdownIt-Anchor" href="#其他优秀解答"></a> 其他优秀解答</h3><blockquote><p>解题思路</p></blockquote><p>双指针 + 哈希表</p><p><strong>哈希表 dic统计：</strong> 指针 j遍历字符 s，哈希表统计字符 s[j]<strong>最后一次出现的索引</strong> 。</p><p><strong>更新左指针 i ：</strong> 根据上轮左指针 i 和 dic[s[j]] ，每轮更新左边界 i ，保证区间 [i+1,j] 内无重复字符且最大</p><p><strong>更新结果 res ：</strong> 取上轮 res 和本轮双指针区间 [i+1,j] 的宽度（即 j−i ）中的最大值。</p><blockquote><p>代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character,Integer&gt; dic = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = -<span class="number">1</span>,res = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">//遍历字符串 s </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s.length();j++)&#123;</span><br><span class="line">          <span class="comment">//遍历到 s[j] 时，可通过访问哈希表 dic[s[j]] 获取最近的相同字符的索引 i</span></span><br><span class="line">            <span class="keyword">if</span>(dic.containsKey(s.charAt(j)))&#123;</span><br><span class="line">              <span class="comment">//取最大值因为防止abba的情况出现</span></span><br><span class="line">                i  = Math.max(i,dic.get(s.charAt(j)));</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">//使用哈希表统计 各字符最后一次出现的索引位置 </span></span><br><span class="line">            dic.put(s.charAt(j),j);</span><br><span class="line">            res = Math.max(res,j-i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 49. 丑数</title>
      <link href="/2020/08/23/%E5%89%91%E6%8C%87-Offer-49-%E4%B8%91%E6%95%B0/"/>
      <url>/2020/08/23/%E5%89%91%E6%8C%87-Offer-49-%E4%B8%91%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="题目信息"><a class="markdownIt-Anchor" href="#题目信息"></a> 题目信息</h3><ul><li><p>题目：剑指 Offer 49. 丑数</p></li><li><p>时间： 2020-08-23</p></li><li><p>题目链接：<a href="https://leetcode-cn.com/problems/chou-shu-lcof/" target="_blank" rel="noopener">Leetcode</a></p></li><li><p>tag：动态规划 小根堆</p></li><li><p>难易程度：中等</p></li><li><p>题目描述：</p><p>我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。</p></li></ul><p><strong>示例:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: n = 10</span><br><span class="line">输出: 12</span><br><span class="line">解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。</span><br></pre></td></tr></table></figure><blockquote><p>注意</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 1是丑数</span><br><span class="line">2. n <span class="tag">&lt; <span class="attr">1690</span></span></span><br></pre></td></tr></table></figure><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><blockquote><p>本题难点</p></blockquote><p>丑数的定义以及查找的方式</p><blockquote><p>具体思路</p></blockquote><p>丑数只包含因子 2,3,5 ，因此有 “丑数 = 某较小丑数 × 某因子” （例如：10=5×2）</p><p>设已知长度为 n 的丑数序列 x1,x2,⋯,xn ，求第 n+1 个丑数 xn+1 。根根据递推性质，丑数 x n+1 只可能是以下三种情况其中之一（索引 a,b,c 为未知数）：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.15999999999999992em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>x</mi><mi>a</mi></msub><mo>×</mo><mn>2</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo separator="true">,</mo><mi>a</mi><mo>∈</mo><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">]</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>x</mi><mi>b</mi></msub><mo>×</mo><mn>3</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo separator="true">,</mo><mi>b</mi><mo>∈</mo><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">]</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>x</mi><mi>c</mi></msub><mo>×</mo><mn>5</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo separator="true">,</mo><mi>c</mi><mo>∈</mo><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">]</mo></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">x_{n+1}=\left\{\begin{array}{ll}x_{a} \times 2 &amp; , a \in[1, n] \\x_{b} \times 3 &amp; , b \in[1, n] \\x_{c} \times 5 &amp; , c \in[1, n]\end{array}\right.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.60004em;vertical-align:-1.55002em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.49999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-3.15001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.30002em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">3</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">c</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">]</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">]</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">]</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/04/NzutrF.png" alt="NzutrF.png" /></p><p>由于 x n+1 是 <strong>最接近</strong> x n的丑数，因此索引 a,b,c 需满足以下条件：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">{</mo><mtable rowspacing="0.15999999999999992em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>x</mi><mi>a</mi></msub><mo>×</mo><mn>2</mn><mo>&gt;</mo><msub><mi>x</mi><mi>n</mi></msub><mo>≥</mo><msub><mi>x</mi><mrow><mi>a</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>×</mo><mn>2</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo separator="true">,</mo><mtext> 即 </mtext><msub><mi>x</mi><mi>a</mi></msub><mtext> 为首个乘以2后大于 </mtext><msub><mi>x</mi><mi>n</mi></msub><mtext> 的丑数 </mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>x</mi><mi>b</mi></msub><mo>×</mo><mn>3</mn><mo>&gt;</mo><msub><mi>x</mi><mi>n</mi></msub><mo>≥</mo><msub><mi>x</mi><mrow><mi>b</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>×</mo><mn>3</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo separator="true">,</mo><mtext> 即 </mtext><msub><mi>x</mi><mi>b</mi></msub><mtext> 为首个乘以3后大于 </mtext><msub><mi>x</mi><mi>n</mi></msub><mtext> 的丑数 </mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>x</mi><mi>c</mi></msub><mo>×</mo><mn>5</mn><mo>&gt;</mo><msub><mi>x</mi><mi>n</mi></msub><mo>≥</mo><msub><mi>x</mi><mrow><mi>c</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>×</mo><mn>5</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo separator="true">,</mo><mtext> 即 </mtext><msub><mi>x</mi><mi>c</mi></msub><mtext> 为首个乘以5后大于 </mtext><msub><mi>x</mi><mi>n</mi></msub><mtext> 的丑数 </mtext></mrow></mstyle></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\left\{\begin{array}{ll}x_{a} \times 2&gt;x_{n} \geq x_{a-1} \times 2 &amp; , \text { 即 } x_{a} \text { 为首个乘以2后大于 } x_{n} \text { 的丑数 } \\x_{b} \times 3&gt;x_{n} \geq x_{b-1} \times 3 &amp; , \text { 即 } x_{b} \text { 为首个乘以3后大于 } x_{n} \text { 的丑数 } \\x_{c} \times 5&gt;x_{n} \geq x_{c-1} \times 5 &amp; , \text { 即 } x_{c} \text { 为首个乘以5后大于 } x_{n} \text { 的丑数 }\end{array}\right.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.60004em;vertical-align:-1.55002em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.49999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-3.15001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.30002em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">3</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">c</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">c</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class="mord"> </span><span class="mord cjk_fallback">即</span><span class="mord"> </span></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord text"><span class="mord"> </span><span class="mord cjk_fallback">为首个乘以</span><span class="mord">2</span><span class="mord cjk_fallback">后大于</span><span class="mord"> </span></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord text"><span class="mord"> </span><span class="mord cjk_fallback">的丑数</span><span class="mord"> </span></span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class="mord"> </span><span class="mord cjk_fallback">即</span><span class="mord"> </span></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord text"><span class="mord"> </span><span class="mord cjk_fallback">为首个乘以</span><span class="mord">3</span><span class="mord cjk_fallback">后大于</span><span class="mord"> </span></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord text"><span class="mord"> </span><span class="mord cjk_fallback">的丑数</span><span class="mord"> </span></span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class="mord"> </span><span class="mord cjk_fallback">即</span><span class="mord"> </span></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">c</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord text"><span class="mord"> </span><span class="mord cjk_fallback">为首个乘以</span><span class="mord">5</span><span class="mord cjk_fallback">后大于</span><span class="mord"> </span></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord text"><span class="mord"> </span><span class="mord cjk_fallback">的丑数</span><span class="mord"> </span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/04/Nzur26.png" alt="Nzur26.png" /></p><p>若索引 a,b,c 满足以上条件，则可使用递推公式计算下个丑数 xn+1 ，其为三种情况中的<strong>最小值</strong>，</p><p>即：xn+1=min(xa × 2, xb × 3, xc × 5)</p><p>动态规划思想：</p><ul><li><p><strong>状态定义</strong>：设动态规划列表 dp ，dp[i] 代表第 i+1 个丑数。</p></li><li><p><strong>转移方程</strong>：每轮计算 dp[i] 后，需要更新索引 a,b,c 的值，使其始终满足方程条件。实现方法：分别独立判断 dp[i] 和 dp[a]×2 , dp[b]×3 , dp[c]×5 的大小关系，若相等则将对应索引 a,b,c 加 1 。</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable rowspacing="0.15999999999999992em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo fence="true">{</mo><mtable rowspacing="0.15999999999999992em" columnalign="left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>a</mi><mo stretchy="false">]</mo><mo>×</mo><mn>2</mn><mo>&gt;</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>≥</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>a</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>×</mo><mn>2</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>b</mi><mo stretchy="false">]</mo><mo>×</mo><mn>3</mn><mo>&gt;</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>≥</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>b</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>×</mo><mn>3</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>c</mi><mo stretchy="false">]</mo><mo>×</mo><mn>5</mn><mo>&gt;</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>≥</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>c</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>×</mo><mn>5</mn></mrow></mstyle></mtd></mtr></mtable></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>min</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>a</mi><mo stretchy="false">]</mo><mo>×</mo><mn>2</mn><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>b</mi><mo stretchy="false">]</mo><mo>×</mo><mn>3</mn><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>c</mi><mo stretchy="false">]</mo><mo>×</mo><mn>5</mn><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{array}{c}\left\{\begin{array}{l}d p[a] \times 2&gt;d p[i-1] \geq d p[a-1] \times 2 \\d p[b] \times 3&gt;d p[i-1] \geq d p[b-1] \times 3 \\d p[c] \times 5&gt;d p[i-1] \geq d p[c-1] \times 5\end{array}\right. \\d p[i]=\min (d p[a] \times 2, d p[b] \times 3, d p[c] \times 5)\end{array}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.80004em;vertical-align:-2.15002em;"></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65002em;"><span style="top:-4.65002em;"><span class="pstrut" style="height:4.05002em;"></span><span class="mord"><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.49999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-3.15001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.30002em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">a</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">b</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">3</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">c</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-2.26em;"><span class="pstrut" style="height:4.05002em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mop">min</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">a</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">b</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">c</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">5</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15002em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span></span></span></span></span></p></li></ul><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/07/04/NzucrD.png" alt="NzucrD.png" /></p><blockquote><p>注意:  dp[0]=1，第一个丑数为 1 ；</p></blockquote><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>, c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">      <span class="comment">//第一个丑数为 1</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> n2 = <span class="number">2</span> * dp[a];</span><br><span class="line">            <span class="keyword">int</span> n3 = <span class="number">3</span> * dp[b];</span><br><span class="line">            <span class="keyword">int</span> n5 = <span class="number">5</span> * dp[c];</span><br><span class="line">            dp[i] = Math.min(Math.min(n2,n3),n5);</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == n2)&#123;</span><br><span class="line">                a++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == n3)&#123;</span><br><span class="line">                b++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == n5)&#123;</span><br><span class="line">                c++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(N) ： 其中 N=n ，动态规划需遍历计算 dp列表。</li><li>空间复杂度 O(N) ： 长度为 N 的 dp 列表使用 O(N)的额外空间。</li></ul><h3 id="其他优秀解答"><a class="markdownIt-Anchor" href="#其他优秀解答"></a> 其他优秀解答</h3><blockquote><p>解题思路</p></blockquote><p>小根堆，要去找第n个丑数，首先想到的就是一个个去生成。uglyNum=2^x ∗3^y ∗5^z ，由 1 生成了 2、3、5 ，接着 2、3、5 利用前面公式继续生成。生成过程是先放小的，并且我们需要去重，去重就需要用到 set</p><blockquote><p>代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//小根堆</span></span><br><span class="line">        PriorityQueue&lt;Long&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        Set&lt;Long&gt; s = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="comment">//初始化,放进堆和set，发现1要开Long数组才可以</span></span><br><span class="line">        <span class="keyword">long</span>[] primes = <span class="keyword">new</span> <span class="keyword">long</span>[]&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> prime : primes) &#123;</span><br><span class="line">            pq.offer(prime);</span><br><span class="line">            s.add(prime);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> num = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            num = pq.poll();</span><br><span class="line">            <span class="comment">//遍历三个因子</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!s.contains(num * primes[j])) &#123;</span><br><span class="line">                    pq.offer(num * primes[j]);</span><br><span class="line">                    s.add(num * primes[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 小根堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 50. 第一个只出现一次的字符</title>
      <link href="/2020/08/22/%E5%89%91%E6%8C%87-Offer-50-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/"/>
      <url>/2020/08/22/%E5%89%91%E6%8C%87-Offer-50-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h3 id="题目信息"><a class="markdownIt-Anchor" href="#题目信息"></a> 题目信息</h3><ul><li><p>题目：剑指 Offer 50. 第一个只出现一次的字符</p></li><li><p>时间： 2020-08-22</p></li><li><p>题目链接：<a href="https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/" target="_blank" rel="noopener">Leetcode</a></p></li><li><p>tag：哈希表</p></li><li><p>难易程度：简单</p></li><li><p>题目描述：</p><p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。</p></li></ul><p><strong>示例:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = "abaccdeff"</span><br><span class="line">返回 "b"</span><br><span class="line"></span><br><span class="line">s = "" </span><br><span class="line">返回 " "</span><br></pre></td></tr></table></figure><blockquote><p>注意</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. 0 &lt;= s 的长度 &lt;= 50000</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><blockquote><p>本题难点</p></blockquote><p>字符串查找第一个只出现一次的字符，性能最优。</p><blockquote><p>具体思路</p></blockquote><p>哈希表</p><ul><li>遍历字符串 <code>s</code>：使用哈希表统计 “各字符数量是否 &gt;1 ”。</li><li>再遍历字符串 <code>s</code> ：在哈希表中找到首个 “数量为 1的字符”，并返回。</li></ul><blockquote><p>注意</p></blockquote><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">firstUniqChar</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Character, Boolean&gt; dic = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">char</span>[] sc = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : sc)</span><br><span class="line">            dic.put(c, !dic.containsKey(c));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : sc)</span><br><span class="line">            <span class="keyword">if</span>(dic.get(c)) <span class="keyword">return</span> c;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(N) ：N为字符串 s的长度；需遍历 s 两轮，使用 O(N) ；HashMap 查找的操作复杂度为 O(1)；</li><li>空间复杂度 O(N) ：HashMap 需存储 N 个字符的键值对，使用 O(N)大小的额外空间。</li></ul><h3 id="其他优秀解答"><a class="markdownIt-Anchor" href="#其他优秀解答"></a> 其他优秀解答</h3><blockquote><p>解题思路</p></blockquote><p>有序哈希表，在字符串很长时， 效率更高。</p><blockquote><p>代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">firstUniqChar</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] array = s.toCharArray();</span><br><span class="line">        HashMap&lt;Character,Boolean&gt; map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">      <span class="comment">// 遍历字符串 s 中的每个字符 c ；</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:array)&#123;</span><br><span class="line">          <span class="comment">//若 dic 中 不包含 键(key) c ：则向 dic 中添加键值对 (c, True) ，代表字符 c 的数量为1</span></span><br><span class="line">          <span class="comment">//若 dic 中 包含 键(key) c ：则修改键 c 的键值对为 (c, False) ，代表字符 c 的数量 &gt;1 </span></span><br><span class="line">            map.put(c,!map.containsKey(c));</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 判断存在时，直接遍历entrySet，而不是遍历原字符串。在`aaaab`时，效率高</span></span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Character,Boolean&gt; entry:map.entrySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(entry.getValue())&#123;</span><br><span class="line">                <span class="keyword">return</span> entry.getKey();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 52. 两个链表的第一个公共节点</title>
      <link href="/2020/08/21/%E5%89%91%E6%8C%87-Offer-52-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/"/>
      <url>/2020/08/21/%E5%89%91%E6%8C%87-Offer-52-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h3 id="题目信息"><a class="markdownIt-Anchor" href="#题目信息"></a> 题目信息</h3><ul><li><p>题目；剑指 Offer 52. 两个链表的第一个公共节点</p></li><li><p>时间： 2020-08-21</p></li><li><p>题目链接：<a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/" target="_blank" rel="noopener">Leetcode</a></p></li><li><p>tag：  单链表</p></li><li><p>难易程度：简单</p></li><li><p>题目描述：</p><p>输入两个链表，找出它们的第一个公共节点。</p></li></ul><p><strong>示例:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A：      a1 -&gt; a2 </span><br><span class="line">                 \</span><br><span class="line">-&gt; c1 -&gt; c2 -&gt; c3</span><br><span class="line">                 /</span><br><span class="line">B：b1 -&gt; b2 -&gt; b3</span><br></pre></td></tr></table></figure><blockquote><p>注意</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 如果两个链表没有交点，返回 null.</span><br><span class="line">2. 在返回结果后，两个链表仍须保持原有的结构。</span><br><span class="line">3. 可假定整个链表结构中没有循环。</span><br><span class="line">4. 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><blockquote><p>本题难点</p></blockquote><p>两条链表不一样长，其到达交点的路程不一样。时间复杂度有要求。</p><blockquote><p>具体思路</p></blockquote><p>使用两个指针 node1，node2 分别指向两个链表 headA，headB 的头结点，然后同时分别逐结点遍历。</p><ul><li><p>当 node1 到达链表 headA 的末尾时，重新定位到链表 headB 的头结点；</p></li><li><p>当 node2 到达链表 headB 的末尾时，重新定位到链表 headA 的头结点。</p></li></ul><p>当它们相遇时，所指向的结点就是第一个公共结点。</p><blockquote><p>注意</p></blockquote><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(headA == <span class="keyword">null</span> || headB == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode node1 = headA;</span><br><span class="line">        ListNode node2 = headB;</span><br><span class="line">      <span class="comment">//两分叉长度一致时，即A B链表长度相同且存在公共节点，此时，不等node1走完A链表(node2走完B链表)即可获得公共节点;</span></span><br><span class="line">      <span class="comment">//两分叉不同且存在公共节点时，此时即为最开始分析时的思路，node1,node2分别走完两链表的所有长度，并在节点处相遇。</span></span><br><span class="line">      <span class="comment">//不存在公共节点，此时最终离开循环时,node1=node2=null,两链表A，B长度相同时，node1,node2只要分别遍历完自己的那条链表就行; 两链表长度不同时,node1先遍历A链表,再遍历B链表,node2先遍历B链表,再遍历A链表,由于A链表+B链表长度固定，等价于node1,node2分别遍历一条长度为A+B的链表，最终一起指向null，循环结束；</span></span><br><span class="line">        <span class="keyword">while</span>(node1 != node2)&#123;</span><br><span class="line">            node1 = node1 != <span class="keyword">null</span> ? node1.next : headB;</span><br><span class="line">            node2 = node2 != <span class="keyword">null</span> ? node2.next : headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(<em>M</em>+N) ：第一个链表的长度为 m,第二个链表的长度为n，两链表遍历一次花费的时间。</li><li>空间复杂度 O(1) ： 使用常数大小的额外空间。</li></ul><h3 id="其他优秀解答"><a class="markdownIt-Anchor" href="#其他优秀解答"></a> 其他优秀解答</h3><blockquote><p>解题思路</p></blockquote><p>双链指针同时移动，确保同时到链表尾。先确定哪个指针路程长，让其先走几个结点。</p><ul><li>辅助函数getLength(ListNode head)用于计数某个链表的长度：通过移动指针temp的循环确定链表长度。</li><li>通过<code>lengthA</code>与<code>lengthB</code>大小，判断哪个指针先走，先走的指针要走的步数即为<code>abs(lengthA-lengthB)</code>。</li><li>“站在同一起跑线后”，就可以指针每移动一次，判断是否走到同一个结点，若是，该结点即为交结点。</li></ul><p>对于没有交点的情况，最终a与b会同时成为<code>null</code>，然后<code>while</code>循环结束，返回<code>a</code>也就是<code>null</code></p><blockquote><p>代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lengthA = getLength(headA), lengthB = getLength(headB);</span><br><span class="line">        ListNode a = headA, b = headB;</span><br><span class="line">        <span class="keyword">if</span>(lengthA &gt; lengthB)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lengthA - lengthB; i++)</span><br><span class="line">                a = a.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lengthB - lengthA; i++)</span><br><span class="line">                b = b.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(a != b)&#123;</span><br><span class="line">            a = a.next;</span><br><span class="line">            b = b.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(ListNode temp = head; temp != <span class="keyword">null</span>; temp = temp.next, length++);</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 53 - I. 在排序数组中查找数字 I</title>
      <link href="/2020/08/20/%E5%89%91%E6%8C%87-Offer-53-I-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97-I/"/>
      <url>/2020/08/20/%E5%89%91%E6%8C%87-Offer-53-I-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97-I/</url>
      
        <content type="html"><![CDATA[<h3 id="题目信息"><a class="markdownIt-Anchor" href="#题目信息"></a> 题目信息</h3><ul><li><p>题目：剑指 Offer 53 - I. 在排序数组中查找数字 I</p></li><li><p>时间： 2020-08-20</p></li><li><p>题目链接：<a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/" target="_blank" rel="noopener">Leetcode</a></p></li><li><p>tag：二分查找 哈希表</p></li><li><p>难易程度：简单</p></li><li><p>题目描述：</p><p>统计一个数字在排序数组中出现的次数。</p></li></ul><p><strong>示例1:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [5,7,7,8,8,10], target = 8</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p><strong>示例2:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [5,7,7,8,8,10], target = 6</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><blockquote><p>注意</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. 0 &lt;= 数组长度 &lt;= 50000</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><blockquote><p>本题难点</p></blockquote><p>排序数组中查找数字，性能最优。</p><blockquote><p>具体思路</p></blockquote><p>排序数组中的搜索问题，首先想到 <strong>二分法</strong> 解决。</p><p>排序数组 nums 中的所有数字 target 形成一个窗口，记窗口的 左 / 右边界 索引分别为 left 和 right ，分别对应窗口左边 / 右边的首个元素。</p><p>统计数字 target 的出现次数，可转化为：使用二分法分别找到 左边界 left 和 右边界 right ，易得数字 target 的数量为 right−left−1 。</p><ul><li>计算中点 m=(i+j)/2（向下取整）</li><li>若 nums[m]&lt;target ，则 target 在闭区间 [m+1,j] 中，因此执行 i=m+1；</li><li>若 nums[m]&gt;target ，则 target 在闭区间 [i,m−1] 中，因此执行 j=m−1；</li><li>若 nums[m]=target ，则右边界 right 在闭区间 [m+1,j] 中；左边界 left 在闭区间 [i,m−1] 中。<ul><li>若查找 右边界 right ，则执行 i=m+1 ；（跳出时 i指向右边界）</li><li>若查找 左边界 left ，则执行 j=m−1 ；（跳出时 j指向左边界）</li></ul></li></ul><blockquote><p>提示：查找完右边界后，可用 nums[j]=j 判断数组中是否包含 target ，若不包含则直接提前返回 0 ，无需后续查找左边界。查找完右边界后，左边界 left一定在闭区间 [0,j]  中，因此直接从此区间开始二分查找即可。</p></blockquote><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 搜索右边界 right</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = (i + j) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[m] &lt;= target) i = m + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> j = m - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> right = i;</span><br><span class="line">        <span class="comment">// 若数组中无 target ，则提前返回</span></span><br><span class="line">        <span class="keyword">if</span>(j &gt;= <span class="number">0</span> &amp;&amp; nums[j] != target) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 搜索左边界 right</span></span><br><span class="line">        i = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = (i + j) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[m] &lt; target) i = m + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> j = m - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = j;</span><br><span class="line">        <span class="keyword">return</span> right - left - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(logN) ： 二分法为对数级别复杂度。</li><li>空间复杂度 O(1) ：几个变量使用常数大小的额外空间。</li></ul><h3 id="其他优秀解答"><a class="markdownIt-Anchor" href="#其他优秀解答"></a> 其他优秀解答</h3><blockquote><p>解题思路</p></blockquote><p>直接遍历排序数组，计数。</p><blockquote><p>代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num == target)&#123;</span><br><span class="line">              count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 53 - II. 0～n-1中缺失的数字</title>
      <link href="/2020/08/19/%E5%89%91%E6%8C%87-Offer-53-II-0%EF%BD%9En-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
      <url>/2020/08/19/%E5%89%91%E6%8C%87-Offer-53-II-0%EF%BD%9En-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h3 id="题目信息"><a class="markdownIt-Anchor" href="#题目信息"></a> 题目信息</h3><ul><li><p>题目；剑指 Offer 53 - II. 0～n-1中缺失的数字</p></li><li><p>时间： 2020-08-19</p></li><li><p>题目链接：<a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/" target="_blank" rel="noopener">Leetcode</a></p></li><li><p>tag： 二分查找</p></li><li><p>难易程度：简单</p></li><li><p>题目描述：</p><p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p></li></ul><p><strong>示例1:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,1,3]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p><strong>示例2:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><blockquote><p>注意</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= 数组长度 &lt;= 10000</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><blockquote><p>本题难点</p></blockquote><p>排序数组查找数组，性能最优。</p><blockquote><p>具体思路</p></blockquote><p>排序数组中的搜索问题，首先想到 <strong>二分法</strong> 解决。</p><p>题目中的数组可以按照以下规则划分为两部分。</p><ul><li><strong>左子数组：</strong> nums[i]=i</li><li><strong>右子数组：</strong> nums[i]≠i</li></ul><p>缺失的数字等于 <strong>“右子数组的首位元素”</strong> 对应的索引；因此考虑使用二分法查找 “右子数组的首位元素” 。</p><p><strong>循环二分：</strong> 当 i≤j时循环 <em>（即当闭区间 [i,j]为空时跳出）</em> ；</p><ul><li>计算中点 m=(i+j)/2，其中 “/” 为向下取整除法；</li><li>若 nums[m]=m ，则 “右子数组的首位元素” 一定在闭区间 [m+1,j] 中，因此执行 i=m+1；</li><li>若 nums[m]≠m ，则 “左子数组的末位元素” 一定在闭区间 [i,m−1] 中，因此执行 j=m−1；</li></ul><blockquote><p>注意 : 跳出时，变量 i和 j分别指向 “右子数组的首位元素” 和 “左子数组的末位元素” 。因此返回 i即可</p></blockquote><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = (i + j) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[m] == m) i = m + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> j = m - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(logN) ：二分法为对数级别复杂度。</li><li>空间复杂度 O(1) ：几个变量使用常数大小的额外空间。</li></ul><h3 id="其他优秀解答"><a class="markdownIt-Anchor" href="#其他优秀解答"></a> 其他优秀解答</h3><blockquote><p>解题思路</p></blockquote><p>通俗易懂 以索引作为标杆对比元素值。</p><blockquote><p>代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( i != nums[i])&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 54. 二叉搜索树的第k大节点</title>
      <link href="/2020/08/18/%E5%89%91%E6%8C%87-Offer-54-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9/"/>
      <url>/2020/08/18/%E5%89%91%E6%8C%87-Offer-54-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h3 id="题目信息"><a class="markdownIt-Anchor" href="#题目信息"></a> 题目信息</h3><ul><li><p>题目：剑指 Offer 54. 二叉搜索树的第k大节点</p></li><li><p>时间： 2020-08-18</p></li><li><p>题目链接：<a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/" target="_blank" rel="noopener">Leetcode</a></p></li><li><p>tag：二叉搜索树  中序遍历 递归</p></li><li><p>难易程度：中等</p></li><li><p>题目描述：</p><p>给定一棵二叉搜索树，请找出其中第k大的节点。</p></li></ul><p><strong>示例1:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [3,1,4,null,2], k = 1</span><br><span class="line">   3</span><br><span class="line">  / \</span><br><span class="line"> 1   4</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p><strong>示例2:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [5,3,6,2,4,null,null,1], k = 3</span><br><span class="line">       5</span><br><span class="line">      / \</span><br><span class="line">     3   6</span><br><span class="line">    / \</span><br><span class="line">   2   4</span><br><span class="line">  /</span><br><span class="line"> 1</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><blockquote><p>注意</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. 1 ≤ k ≤ 二叉搜索树元素个数</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><blockquote><p>本题难点</p></blockquote><p>二叉排序树：根节点的值大于左子树的值，小于右子树的值。查找第K大节点。</p><blockquote><p>具体思路</p></blockquote><p>二叉搜索树的中序遍历为 <strong>递增序列</strong> ，易得二叉搜索树的 <strong>中序遍历倒序</strong> 为 <strong>递减序列</strong> 。</p><p>求 “二叉搜索树第 k大的节点” 可转化为求 “此树的中序遍历倒序的第 k个节点”。</p><ul><li><p>中序遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    dfs(root.left); <span class="comment">// 左</span></span><br><span class="line">    System.out.println(root.val); <span class="comment">// 根</span></span><br><span class="line">    dfs(root.right); <span class="comment">// 右</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>中序遍历的倒序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印中序遍历倒序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    dfs(root.right); <span class="comment">// 右</span></span><br><span class="line">    System.out.println(root.val); <span class="comment">// 根</span></span><br><span class="line">    dfs(root.left); <span class="comment">// 左</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>求第 k大节点，需要实现以下 <strong>三项工作</strong> ：</p><ul><li>递归遍历时计数，统计当前节点的序号；</li><li>递归到第 k个节点时，应记录结果 res ；</li><li>记录结果后，后续的遍历即失去意义，应提前终止（即返回）。</li></ul><blockquote><p>提示：在获得res结果时，增加一个return语句可以避免之后的无效迭代dfs(root.left);</p></blockquote><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="comment">////形参k不能随着dfs的迭代而不断变化，为了记录迭代进程和结果，引入类变量count和res</span></span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>, res=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthLargest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.count = k;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">      <span class="comment">// 若 k=0 ，代表已找到目标节点，无需继续遍历，因此直接返回；</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span> || count == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//递归右子树</span></span><br><span class="line">        dfs(root.right);</span><br><span class="line">      <span class="comment">//统计序号： 执行 k=k−1 （即从 k 减至 0 ）；</span></span><br><span class="line">      <span class="comment">//记录结果： 若 k=0 ，代表当前节点为第 k 大的节点，因此记录 res=root.val ；</span></span><br><span class="line">        <span class="keyword">if</span>(--count == <span class="number">0</span>)&#123;</span><br><span class="line">            res = root.val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//递归左子树</span></span><br><span class="line">        dfs(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(N) ：当树退化为链表时（全部为右子节点），无论 k的值大小，递归深度都为 N，占用 O(N) 时间。</li><li>空间复杂度 O(N) ：当树退化为链表时（全部为右子节点），系统使用 O(N) 大小的栈空间。</li></ul><h3 id="其他优秀解答"><a class="markdownIt-Anchor" href="#其他优秀解答"></a> 其他优秀解答</h3><blockquote><p>解题思路</p></blockquote><p>中序遍历倒序的非递归算法。</p><blockquote><p>代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthLargest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (Objects.nonNull(root) || !stack.empty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (Objects.nonNull(root)) &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">            TreeNode pop = stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (count == k) &#123;</span><br><span class="line">                <span class="keyword">return</span> pop.val;</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">            root = pop.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 二叉搜索树 </tag>
            
            <tag> 中序遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 55 - I. 二叉树的深度</title>
      <link href="/2020/08/17/%E5%89%91%E6%8C%87-Offer-55-I-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/"/>
      <url>/2020/08/17/%E5%89%91%E6%8C%87-Offer-55-I-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h3 id="题目信息"><a class="markdownIt-Anchor" href="#题目信息"></a> 题目信息</h3><ul><li><p>题目：剑指 Offer 55 - I. 二叉树的深度</p></li><li><p>时间： 2020-08-17</p></li><li><p>题目链接：<a href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/" target="_blank" rel="noopener">Leetcode</a></p></li><li><p>tag：  二叉树 层序遍历  后序遍历</p></li><li><p>难易程度：简单</p></li><li><p>题目描述：</p><p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p></li></ul><p><strong>示例:</strong></p><p>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回它的最大深度 3 。</p><blockquote><p>注意</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. 节点总数 <span class="tag">&lt;<span class="name">=</span> <span class="attr">10000</span></span></span><br></pre></td></tr></table></figure><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><blockquote><p>本题难点</p></blockquote><p>树的遍历方式总体分为两类：深度优先搜索（DFS）、广度优先搜索（BFS）；</p><ul><li><strong>常见的 DFS ：</strong> 先序遍历、中序遍历、后序遍历；</li><li><strong>常见的 BFS ：</strong> 层序遍历（即按层遍历）。</li></ul><p>求树的深度需要遍历树的所有节点。</p><blockquote><p>具体思路</p></blockquote><p>二叉树的层序遍历 / 广度优先搜索往往利用 <strong>队列</strong> 实现。</p><p>每遍历一层，则计数器 +1 ，直到遍历完成，则可得到树的深度。</p><blockquote><p>注意</p></blockquote><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//初始化一个空队列 queue </span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">          <span class="comment">//遍历队列： 遍历 queue 中的各节点 node ，并将其左子节点和右子节点加入 queue；</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = queue.size();i &gt; <span class="number">0</span> ; i--)&#123;</span><br><span class="line">                TreeNode t = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(t.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.add(t.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(t.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.add(t.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res++;       </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(N) ：<em>N</em> 为树的节点数量，计算树的深度需要遍历所有节点。</li><li>空间复杂度 O(N) ： 最差情况下（当树平衡时），队列 <code>queue</code> 同时存储 N/2个节点。</li></ul><h3 id="其他优秀解答"><a class="markdownIt-Anchor" href="#其他优秀解答"></a> 其他优秀解答</h3><blockquote><p>解题思路</p></blockquote><p>此树的深度和其左（右）子树的深度之间的关系。显然，<strong>此树的深度</strong> 等于 <strong>左子树的深度</strong> 与 <strong>右子树的深度</strong> 中的 <strong>最大值</strong> +1 。</p><blockquote><p>代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 层序遍历 </tag>
            
            <tag> 后序遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 55 - II. 平衡二叉树</title>
      <link href="/2020/08/16/%E5%89%91%E6%8C%87-Offer-55-II-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2020/08/16/%E5%89%91%E6%8C%87-Offer-55-II-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h3 id="题目信息"><a class="markdownIt-Anchor" href="#题目信息"></a> 题目信息</h3><ul><li><p>题目：剑指 Offer 55 - II. 平衡二叉树</p></li><li><p>时间： 2020-08-16</p></li><li><p>题目链接：<a href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/" target="_blank" rel="noopener">Leetcode</a></p></li><li><p>tag：  平衡二叉树 深度优先搜索</p></li><li><p>难易程度：简单</p></li><li><p>题目描述：</p><p>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</p></li></ul><p><strong>示例1:</strong></p><p>给定二叉树 <code>[3,9,20,null,null,15,7]</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回 <code>true</code> 。</p><p><strong>示例2:</strong></p><p>给定二叉树 <code>[1,2,2,3,3,null,null,4,4]</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      1</span><br><span class="line">     / \</span><br><span class="line">    2   2</span><br><span class="line">   / \</span><br><span class="line">  3   3</span><br><span class="line"> / \</span><br><span class="line">4   4</span><br></pre></td></tr></table></figure><p>返回 <code>false</code> 。</p><blockquote><p>注意</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. 1 &lt;= 树的结点个数 &lt;= 10000</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><blockquote><p>本题难点</p></blockquote><p><strong>树的深度</strong> 等于 <strong>左子树的深度</strong> 与 <strong>右子树的深度</strong> 中的 <strong>最大值</strong> +1 。</p><blockquote><p>具体思路</p></blockquote><p>后序遍历 + 剪枝 （从底至顶），思路是对二叉树做后序遍历，从底至顶返回子树深度，若判定某子树不是平衡树则 “剪枝” ，直接向上返回。</p><ul><li>当节点<code>root</code> 左 / 右子树的深度差 ≤1，则返回当前子树的深度，即节点 <code>root</code> 的左 / 右子树的深度最大值 +1（ <code>max(left, right) + 1</code> ）</li><li>当节点<code>root</code> 左 / 右子树的深度差 &gt;2，则返回 −1 ，代表 <strong>此子树不是平衡树</strong> 。</li></ul><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> recur(root) != -<span class="number">1</span>;    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">recur</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">      <span class="comment">//当 root 为空：说明越过叶节点，因此返回高度 0 ；</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">//当左（右）子树深度为 −1 ：代表此树的 左（右）子树 不是平衡树，因此剪枝，直接返回 −1 ；</span></span><br><span class="line">        <span class="keyword">int</span> left = recur(root.left);</span><br><span class="line">        <span class="keyword">if</span>(left == -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> right = recur(root.right);</span><br><span class="line">        <span class="keyword">if</span>(right == -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(left - right) &lt; <span class="number">2</span> ? Math.max(left,right) + <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(N) ： <em>N</em> 为树的节点数；最差情况下，需要递归遍历树的所有节点。</li><li>空间复杂度 O(N) ：  最差情况下（树退化为链表时），系统递归需要使用 O(N) 的栈空间。</li></ul><h3 id="其他优秀解答"><a class="markdownIt-Anchor" href="#其他优秀解答"></a> 其他优秀解答</h3><blockquote><p>解题思路</p></blockquote><p>先序遍历 + 判断深度 （从顶至底）</p><p>思路是构造一个获取当前子树的深度的函数 depth(root) ，通过比较某子树的左右子树的深度abs(depth(root.left) - depth(root.right)) &lt;= 1 是否成立，来判断某子树是否是二叉平衡树。若所有子树都平衡，则此树平衡。</p><blockquote><p>代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      <span class="comment">//abs(self.depth(root.left) - self.depth(root.right)) &lt;= 1 ：判断 当前子树 是否是平衡树；</span></span><br><span class="line">      <span class="comment">//isBalanced(root.left) ： 先序遍历递归，判断 当前子树的左子树 是否是平衡树；</span></span><br><span class="line">      <span class="comment">//isBalanced(root.right) ： 先序遍历递归，判断 当前子树的右子树 是否是平衡树；</span></span><br><span class="line">        <span class="keyword">return</span> Math.abs(depth(root.left) - depth(root.right)) &lt;= <span class="number">1</span> &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.max(depth(root.left), depth(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度优先搜索 </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 平衡二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 56 - I. 数组中数字出现的次数</title>
      <link href="/2020/08/15/%E5%89%91%E6%8C%87-Offer-56-I-%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/"/>
      <url>/2020/08/15/%E5%89%91%E6%8C%87-Offer-56-I-%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="题目信息"><a class="markdownIt-Anchor" href="#题目信息"></a> 题目信息</h3><ul><li><p>题目：剑指 Offer 56 - I. 数组中数字出现的次数</p></li><li><p>时间： 2020-08-15</p></li><li><p>题目链接：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/" target="_blank" rel="noopener">Leetcode</a></p></li><li><p>tag：位运算</p></li><li><p>难易程度：中等</p></li><li><p>题目描述：</p><p>一个整型数组 <code>nums</code> 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p></li></ul><p><strong>示例1:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [4,1,4,6]</span><br><span class="line">输出：[1,6] 或 [6,1]</span><br></pre></td></tr></table></figure><p><strong>示例2:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,10,4,1,4,3,3]</span><br><span class="line">输出：[2,10] 或 [10,2]</span><br></pre></td></tr></table></figure><blockquote><p>注意</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. 2 &lt;= nums.length &lt;= 10000</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><blockquote><p>本题难点</p></blockquote><p>查找数组中两个只出现一次的数字，性能最优。</p><blockquote><p>具体思路</p></blockquote><p><strong>异或运算</strong></p><ul><li>交换律：p⊕q=q⊕p</li><li>结合律：p⊕(q⊕r)=(p⊕q)⊕r</li><li>恒等率：p⊕0=p</li><li>归零率：p⊕p=0</li></ul><p>如果有若干个数字进行异或操作：根据 交换律、结合律 将相同的数字优先两两进行异或运算。此时就只剩下只出现一次的那个数了！</p><p>由于数组中存在着两个数字不重复的情况，我们将所有的数字异或操作起来，最终得到的结果是这两个数字的异或结果：(相同的两个数字相互异或，值为0)) 最后结果一定不为0，因为有两个数字不重复。</p><p>此时的难点在于，对两个不同数字的分组。</p><p>通过 &amp; 运算来判断一位数字不同即可分为两组，那么我们随便两个不同的数字二进制上至少也有一位不同吧！<br />我们只需要找出那位二进制上不同的数字mask，即可完成分组（ &amp; mask ）操作。</p><p>不同数字mask查找演示:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">num1:       101110      110     1111</span><br><span class="line">num2:       111110      001     1001</span><br><span class="line">num1^num2:  010000      111     0110</span><br><span class="line"></span><br><span class="line">可行的mask:  010000      001     0010</span><br><span class="line">                        010     0100</span><br><span class="line">                        100</span><br></pre></td></tr></table></figure><p>所有的可行 mask 个数，都与异或后1的位数有关。</p><blockquote><p>提示：为了操作方便，我们只去找最低位的mask:</p></blockquote><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">lass Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] singleNumbers(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">       <span class="comment">//用于将所有的数异或起来</span></span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            k ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//获得k中最低位的1</span></span><br><span class="line">        <span class="keyword">int</span> mask = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>((mask &amp; k) == <span class="number">0</span>)&#123;</span><br><span class="line">            mask &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">//将数组分为包含不同数字的两组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>((num &amp; mask) == <span class="number">0</span>)&#123;</span><br><span class="line">                a ^= num;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                b ^= num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;a,b&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(N) ：只需要遍历数组两次。</li><li>空间复杂度 O(1) ： 只需要常数的空间存放若干变量。</li></ul><h3 id="其他优秀解答"><a class="markdownIt-Anchor" href="#其他优秀解答"></a> 其他优秀解答</h3><blockquote><p>解题思路</p></blockquote><p>通过二分查找，将包含两不同数字的数组分组。</p><p>异或和为 0其实并不代表 要找的元素不在这里面，<strong>因为有可能 0只出现了 1次！</strong> 所以这种思路需要特判一下某个数为 0的情况。</p><blockquote><p>代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] singleNumbers(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, min = Integer.MAX_VALUE, max = Integer.MIN_VALUE, zeroCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">                zeroCount += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            min = Math.min(min, num);</span><br><span class="line">            max = Math.max(max, num);</span><br><span class="line">            sum ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 需要特判一下某个数是0的情况。</span></span><br><span class="line">        <span class="keyword">if</span> (zeroCount == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;sum, <span class="number">0</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> lo = min, hi = max;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">            <span class="comment">// 根据 lo 的正负性来判断二分位置怎么写，防止越界。</span></span><br><span class="line">            <span class="keyword">int</span> mid = (lo &lt; <span class="number">0</span> &amp;&amp; hi &gt; <span class="number">0</span>)? (lo + hi) &gt;&gt; <span class="number">1</span>: lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> loSum = <span class="number">0</span>, hiSum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num &lt;= mid) &#123;</span><br><span class="line">                    loSum ^= num;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    hiSum ^= num;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (loSum != <span class="number">0</span> &amp;&amp; hiSum != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 两个都不为0，说明 p 和 q 分别落到2个数组里了。</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;loSum, hiSum&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (loSum == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 说明 p 和 q 都比 mid 大，所以比 mid 小的数的异或和变为0了。</span></span><br><span class="line">                lo = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 说明 p 和 q 都不超过 mid</span></span><br><span class="line">                hi = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 其实如果输入是符合要求的，程序不会执行到这里，为了防止compile error加一下</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 57 - I. 和为s的两个数字</title>
      <link href="/2020/08/14/%E5%89%91%E6%8C%87-Offer-57-I-%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/"/>
      <url>/2020/08/14/%E5%89%91%E6%8C%87-Offer-57-I-%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h3 id="题目信息"><a class="markdownIt-Anchor" href="#题目信息"></a> 题目信息</h3><ul><li><p>题目：剑指 Offer 57 - I. 和为s的两个数字</p></li><li><p>时间： 2020-08-14</p></li><li><p>题目链接：<a href="https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/" target="_blank" rel="noopener">Leetcode</a></p></li><li><p>tag：  双指针 哈希表</p></li><li><p>难易程度：简单</p></li><li><p>题目描述：</p><p>输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。</p></li></ul><p><strong>示例1:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[2,7] 或者 [7,2]</span><br></pre></td></tr></table></figure><p><strong>示例2:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [10,26,30,31,47,60], target = 40</span><br><span class="line">输出：[10,30] 或者 [30,10]</span><br></pre></td></tr></table></figure><blockquote><p>注意</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 1 &lt;= nums.length &lt;= 10^5</span><br><span class="line">2. 1 &lt;= nums[i] &lt;= 10^6</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><blockquote><p>本题难点</p></blockquote><p>查找和为s的两个数字，性能最优。</p><blockquote><p>具体思路</p></blockquote><p>本题的 nums 是 <strong>排序数组</strong> ，因此可使用 <strong>双指针法</strong> 将空间复杂度降低至 O(1)。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">      <span class="comment">//双指针 i , j 分别指向数组 nums 的左右两端 </span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">          <span class="comment">//计算和 s=nums[i]+nums[j] </span></span><br><span class="line">            <span class="keyword">int</span> sum = nums[i] + nums[j];</span><br><span class="line">          <span class="comment">//若 s&gt;target ，则指针 j 向左移动，即执行 j=j−1</span></span><br><span class="line">            <span class="keyword">if</span>(sum &gt; target)&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; target)&#123;<span class="comment">//若 s&lt;target ，则指针 i 向右移动，即执行 i=i+1 </span></span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//若 s=target ，立即返回数组 [nums[i],nums[j]] </span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nums[i],nums[j]&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(N) ：  N为数组 nums 的长度；双指针共同线性遍历整个数组。</li><li>空间复杂度 O(1) ：  变量 i, j 使用常数大小的额外空间。</li></ul><h3 id="其他优秀解答"><a class="markdownIt-Anchor" href="#其他优秀解答"></a> 其他优秀解答</h3><blockquote><p>解题思路</p></blockquote><p>哈希表查找，利用 HashMap 可以通过遍历数组找到数字组合，时间和空间复杂度均为 O(N)；</p><blockquote><p>代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map=<span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            map.put(target-nums[i],nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="comment">//注意排除当前元素</span></span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(nums[i]) &amp;&amp; map.get(nums[i])!=i)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nums[i],map.get(nums[i])&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 57 - II. 和为s的连续正数序列</title>
      <link href="/2020/08/13/%E5%89%91%E6%8C%87-Offer-57-II-%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/"/>
      <url>/2020/08/13/%E5%89%91%E6%8C%87-Offer-57-II-%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h3 id="题目信息"><a class="markdownIt-Anchor" href="#题目信息"></a> 题目信息</h3><ul><li><p>题目：剑指 Offer 57 - II. 和为s的连续正数序列</p></li><li><p>时间： 2020-08-13</p></li><li><p>题目链接：<a href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/" target="_blank" rel="noopener">Leetcode</a></p></li><li><p>tag：双指针 滑动窗口</p></li><li><p>难易程度：简单</p></li><li><p>题目描述：</p><p>输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。</p><p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p></li></ul><p><strong>示例1:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 9</span><br><span class="line">输出：[[2,3,4],[4,5]]</span><br></pre></td></tr></table></figure><p><strong>示例2:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 15</span><br><span class="line">输出：[[1,2,3,4,5],[4,5,6],[7,8]]</span><br></pre></td></tr></table></figure><blockquote><p>注意</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. 1 &lt;= target &lt;= 10^5</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><blockquote><p>本题难点</p></blockquote><p>连续正整数序列的和为target，存在有多个正整数序列满足条件。</p><blockquote><p>具体思路</p></blockquote><p><strong>滑动窗口</strong>：滑动窗口可以看成数组中框起来的一个部分。在一些数组类题目中，我们可以用滑动窗口来观察可能的候选结果。当滑动窗口从数组的左边滑到了右边，我们就可以从所有的候选结果中找到最优的结果。</p><p>窗口的左边界和右边界永远只能向右移动，而不能向左移动。这是为了保证滑动窗口的时间复杂度是 O(n)。如果左右边界向左移动的话，这叫做“回溯”，算法的时间复杂度就可能不止 O(n)</p><p>本题操作：</p><ul><li><strong>sum &lt; target</strong>：窗口的和需要增加，所以要扩大窗口，窗口的右边界向右移动</li><li><strong>sum &gt; target</strong>：窗口的和需要减少，所以要缩小窗口，窗口的左边界向右移动</li><li><strong>sum = target</strong>：记录此时的结果。设此时的窗口为 [i,j)，那么我们已经找到了一个 i 开头的序列，也是唯一一个 i 开头的序列，接下来需要找 i+1 开头的序列，所以窗口的左边界要向右移动</li></ul><blockquote><p>提示：这道题当前可以用等差数列的求和公式来计算滑动窗口的和。当<code>sum==target</code>时，左边界可以直接向右移动两位，即<code>i += 2</code>，因为 <code>i+1</code> 开头的序列一定无解。</p></blockquote><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] findContinuousSequence(<span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="comment">//窗口最左端从1开始</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//窗口最右端从2开始</span></span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//窗口内数字的和</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//窗口的最左端一定小于target/2</span></span><br><span class="line">        <span class="keyword">while</span>(l &lt;= target/<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="comment">//等差数列的求和公式 n(a1+an)/2</span></span><br><span class="line">            sum = (r - l + <span class="number">1</span>) *(l + r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(sum &lt; target)&#123;</span><br><span class="line">                r++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; target)&#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//保存其中一组答案</span></span><br><span class="line">                <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[r-l + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = l; k &lt;= r; k++)&#123;</span><br><span class="line">                    arr[k-l] = k;</span><br><span class="line">                &#125;</span><br><span class="line">                res.add(arr);</span><br><span class="line">                <span class="comment">//将左边窗口滑动</span></span><br><span class="line">                l+=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[res.size()][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(N) ： 由于窗口两个指针移动均单调不减，且最多移动 target/2  次，即方法一提到的枚举的上界，所以时间复杂度为 O(target)</li><li>空间复杂度 O(1) ：  除了答案数组只需要常数的空间存放若干变量</li></ul><h3 id="其他优秀解答"><a class="markdownIt-Anchor" href="#其他优秀解答"></a> 其他优秀解答</h3><blockquote><p>解题思路</p></blockquote><p>先找到符合的连续的2个数之和，然后符合的连续3个数，这样子递增的。例如9，先找符合的连续两个数是4+5=4+(4+1)，连续的三个数是2+3+4=2+(2+1)+(2+2)。难点是，我们能如何找到连续两个数开头的4和连续三个数的2，我们就可以根据开头的数自增就可以了。</p><blockquote><p>代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] findContinuousSequence(<span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(target&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            target -= i++;</span><br><span class="line">            <span class="keyword">if</span>(target&gt;<span class="number">0</span> &amp;&amp; target%i == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[i];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = target/i, j = <span class="number">0</span>; k &lt; target/i+i; k++,j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    array[j] = k;</span><br><span class="line">                &#125;</span><br><span class="line">                result.add(array);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(result);</span><br><span class="line">        <span class="keyword">return</span> result.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][]);       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 58 - I. 翻转单词顺序</title>
      <link href="/2020/08/12/%E5%89%91%E6%8C%87-Offer-58-I-%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F/"/>
      <url>/2020/08/12/%E5%89%91%E6%8C%87-Offer-58-I-%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="题目信息"><a class="markdownIt-Anchor" href="#题目信息"></a> 题目信息</h3><ul><li><p>题目：翻转单词顺序</p></li><li><p>时间： 2020-08-12</p></li><li><p>题目链接：<a href="https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/" target="_blank" rel="noopener">Leetcode</a></p></li><li><p>tag：字符串  排序</p></li><li><p>难易程度：简单</p></li><li><p>题目描述：</p><p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串&quot;I am a student. “，则输出&quot;student. a am I”。</p></li></ul><p><strong>示例1:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: "the sky is blue"</span><br><span class="line">输出: "blue is sky the"</span><br></pre></td></tr></table></figure><p><strong>示例2:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: "  hello world!  "</span><br><span class="line">输出: "world! hello"</span><br><span class="line">解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</span><br></pre></td></tr></table></figure><blockquote><p>注意</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 无空格字符构成一个单词。</span><br><span class="line">2. 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</span><br><span class="line">3. 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><blockquote><p>本题难点</p></blockquote><p>处理空格情况，字符串倒序。</p><blockquote><p>具体思路</p></blockquote><ul><li>倒序遍历字符串 s，记录单词左右索引边界 i, j；</li><li>每确定一个单词的边界，则将其添加至单词列表 res ；</li><li>最终，将单词列表拼接为字符串，并返回即可。</li></ul><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        s = s.trim(); <span class="comment">// 删除首尾空格</span></span><br><span class="line">        <span class="keyword">int</span> j = s.length() - <span class="number">1</span>, i = j;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; s.charAt(i) != <span class="string">' '</span>) i--; <span class="comment">// 搜索首个空格</span></span><br><span class="line">            res.append(s.substring(i + <span class="number">1</span>, j + <span class="number">1</span>) + <span class="string">" "</span>); <span class="comment">// 添加单词</span></span><br><span class="line">            <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; s.charAt(i) == <span class="string">' '</span>) i--; <span class="comment">// 跳过单词间空格</span></span><br><span class="line">            j = i; <span class="comment">// j 指向下个单词的尾字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString().trim(); <span class="comment">// 转化为字符串并返回</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(N) ： 其中 N为字符串 s的长度，线性遍历字符串。</li><li>空间复杂度 O(N) ：  新建的 tringBuilder(Java) 中的字符串总长度 ≤N ，占用 O(N) 大小的额外空间。</li></ul><h3 id="其他优秀解答"><a class="markdownIt-Anchor" href="#其他优秀解答"></a> 其他优秀解答</h3><blockquote><p>解题思路</p></blockquote><p>利用 “字符串分割”、“列表倒序” 的内置函数 <em>（面试时不建议使用）</em> ，可简便地实现本题的字符串翻转要求。</p><blockquote><p>代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        String[] strs = s.trim().split(<span class="string">" "</span>); <span class="comment">// 删除首尾空格，分割字符串</span></span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = strs.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">// 倒序遍历单词列表</span></span><br><span class="line">            <span class="keyword">if</span>(strs[i].equals(<span class="string">""</span>)) <span class="keyword">continue</span>; <span class="comment">// 遇到空单词则跳过</span></span><br><span class="line">            res.append(strs[i] + <span class="string">" "</span>); <span class="comment">// 将单词拼接至 StringBuilder</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString().trim(); <span class="comment">// 转化为字符串，删除尾部空格，并返回</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 58 - II. 左旋转字符串</title>
      <link href="/2020/08/11/%E5%89%91%E6%8C%87-Offer-58-II-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2020/08/11/%E5%89%91%E6%8C%87-Offer-58-II-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h3 id="题目信息"><a class="markdownIt-Anchor" href="#题目信息"></a> 题目信息</h3><ul><li><p>题目：剑指 Offer 58 - II. 左旋转字符串</p></li><li><p>时间： 2020-08-11</p></li><li><p>题目链接：<a href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/" target="_blank" rel="noopener">Leetcode</a></p></li><li><p>tag：  字符串 排序</p></li><li><p>难易程度：中等</p></li><li><p>题目描述：</p><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串&quot;abcdefg&quot;和数字2，该函数将返回左旋转两位得到的结果&quot;cdefgab&quot;。</p></li></ul><p><strong>示例1:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = "abcdefg", k = 2</span><br><span class="line">输出: "cdefgab"</span><br></pre></td></tr></table></figure><p><strong>示例2:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = "lrloseumgh", k = 6</span><br><span class="line">输出: "umghlrlose"</span><br></pre></td></tr></table></figure><blockquote><p>注意</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. 1 &lt;= k &lt; s.length &lt;= 10000</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><blockquote><p>本题难点</p></blockquote><p>旋转k个字符串</p><blockquote><p>具体思路</p></blockquote><p>列表遍历拼接</p><ul><li>新建一个StringBuilder(Java) ，记为 res；</li><li>先向 res 添加 “第 n+1 位至末位的字符” ；</li><li>再向 res 添加 “首位至第 n 位的字符” ；</li><li>将 res 转化为字符串并返回。</li></ul><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseLeftWords</span><span class="params">(String s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">         StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &lt; n + s.length(); i++)&#123;</span><br><span class="line">             res.append(s.charAt(i % s.length()));</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(N) ： 线性遍历 s并添加，使用线性时间；</li><li>空间复杂度 O(N) ：  新建的辅助 res 使用 O(N) 大小的额外空间。</li></ul><h3 id="其他优秀解答"><a class="markdownIt-Anchor" href="#其他优秀解答"></a> 其他优秀解答</h3><blockquote><p>解题思路</p></blockquote><p>字符串切片</p><blockquote><p>代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseLeftWords</span><span class="params">(String s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.substring(n,s.length()) + s.substring(<span class="number">0</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 59 - I. 滑动窗口的最大值</title>
      <link href="/2020/08/10/%E5%89%91%E6%8C%87-Offer-59-I-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
      <url>/2020/08/10/%E5%89%91%E6%8C%87-Offer-59-I-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h3 id="题目信息"><a class="markdownIt-Anchor" href="#题目信息"></a> 题目信息</h3><ul><li><p>题目：剑指 Offer 59 - I. 滑动窗口的最大值</p></li><li><p>时间： 2020-08-10</p></li><li><p>题目链接：<a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/" target="_blank" rel="noopener">Leetcode</a></p></li><li><p>tag： 队列 双端队列 滑动窗口</p></li><li><p>难易程度：困难</p></li><li><p>题目描述：</p><p>给定一个数组 <code>nums</code> 和滑动窗口的大小 <code>k</code>，请找出所有滑动窗口里的最大值。</p></li></ul><p><strong>示例:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3</span><br><span class="line">输出: [3,3,5,5,6,7] </span><br><span class="line">解释: </span><br><span class="line"></span><br><span class="line">  滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure><blockquote><p>注意</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. 你可以假设 k 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><blockquote><p>本题难点</p></blockquote><p>数组无序，窗口内的最大值。</p><blockquote><p>具体思路</p></blockquote><p><strong>双向队列</strong>：在头部进行插入、删除操作，也能在尾部进行插入删除操作。</p><p><strong>单调的双向队列</strong>：从队列的头部到尾部，所存储的元素是依次递减（或依次递增）的。</p><p>我们维护一个<code>单调的双向队列</code>，窗口在每次滑动的时候，我就从队列<code>头部</code>取当前窗口中的<code>最大值</code>，每次窗口新进来一个元素的时候，我就将它与队列中的元素进行大小比较：</p><ul><li>进来的元素 &gt; 队列的尾部元素：那么先将队列尾部的元素弹出，然后把刚刚进来的元素添到队列的尾部；</li><li>进来的元素 &lt; 队列的尾部元素：那么把刚刚进来的元素直接添到队列的尾部即可。</li></ul><p>删除元素：当队列的大小超过窗口的大小时，将队列的最大值弹出，窗口进行滑动。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || k == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        Deque&lt;Integer&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length - k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="comment">// 在队列不为空的情况下，如果队列尾部的元素要比当前的元素小，或等于当前的元素</span></span><br><span class="line">            <span class="comment">// 那么为了维持从大到小的原则，我必须让尾部元素弹出</span></span><br><span class="line">            <span class="keyword">while</span>(!deque.isEmpty() &amp;&amp; nums[deque.peekLast()] &lt;= nums[i])&#123;</span><br><span class="line">                deque.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="comment">// 不走 while 的话，说明我们正常在队列尾部添加元素</span></span><br><span class="line">            deque.add(i);</span><br><span class="line">          <span class="comment">// 如果滑动窗口已经略过了队列中头部的元素，则将头部元素弹出</span></span><br><span class="line">            <span class="keyword">if</span>(deque.peekFirst() == (i - k))&#123;</span><br><span class="line">                deque.pollFirst();</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">// 看看窗口有没有形成，只有形成了大小为 k 的窗口，我才能收集窗口内的最大值</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k-<span class="number">1</span>)&#123;</span><br><span class="line">                res[count++] = nums[deque.peekFirst()];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(N) ： 其中 n 为数组 nums 长度；线性遍历 nums 占用 O(N) ；每个元素最多仅入队和出队一次，因此单调队列 deque 占用 O(2N) 。</li><li>空间复杂度 O(k) ：  双端队列 deque 中最多同时存储 k个元素（即窗口大小）。</li></ul><h3 id="其他优秀解答"><a class="markdownIt-Anchor" href="#其他优秀解答"></a> 其他优秀解答</h3><blockquote><p>解题思路</p></blockquote><p>改善之后的暴力法</p><blockquote><p>代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">       <span class="keyword">int</span> len = nums.length;</span><br><span class="line">       <span class="keyword">if</span> (len == <span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//定义结果数组</span></span><br><span class="line">       <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[len - k + <span class="number">1</span>];</span><br><span class="line">       <span class="comment">//maxInd记录每次最大值的下标，max记录最大值</span></span><br><span class="line">       <span class="keyword">int</span> maxInd = -<span class="number">1</span>, max = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - k + <span class="number">1</span>; i++) &#123;</span><br><span class="line">           <span class="comment">//判断最大值下标是否在滑动窗口的范围内</span></span><br><span class="line">           <span class="keyword">if</span> (maxInd &gt;= i)&#123;</span><br><span class="line">               <span class="comment">//存在就只需要比较最后面的值是否大于上一个窗口最大值</span></span><br><span class="line">               <span class="keyword">if</span> (nums[i + k - <span class="number">1</span>] &gt; max)&#123;</span><br><span class="line">                   max = nums[i + k - <span class="number">1</span>];</span><br><span class="line">                   <span class="comment">//更新最大值下标</span></span><br><span class="line">                   maxInd = i + k - <span class="number">1</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//如果不在就重新寻找当前窗口最大值</span></span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               max = nums[i];</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; i + k; j++) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (max &lt; nums[j]) &#123;</span><br><span class="line">                       max = nums[j];</span><br><span class="line">                       maxInd = j;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           res[i] = max;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 队列 </tag>
            
            <tag> 双端队列 </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 59 - II. 队列的最大值</title>
      <link href="/2020/08/09/%E5%89%91%E6%8C%87-Offer-59-II-%E9%98%9F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
      <url>/2020/08/09/%E5%89%91%E6%8C%87-Offer-59-II-%E9%98%9F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h3 id="题目信息"><a class="markdownIt-Anchor" href="#题目信息"></a> 题目信息</h3><ul><li><p>题目：剑指 Offer 59 - II. 队列的最大值</p></li><li><p>时间： 2020-08-09</p></li><li><p>题目链接：<a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/" target="_blank" rel="noopener">Leetcode</a></p></li><li><p>tag： 队列 双端队列</p></li><li><p>难易程度：中等</p></li><li><p>题目描述：</p><p>请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。</p><p>若队列为空，pop_front 和 max_value 需要返回 -1</p></li></ul><p><strong>示例1:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">["MaxQueue","push_back","push_back","max_value","pop_front","max_value"]</span><br><span class="line">[[],[1],[2],[],[],[]]</span><br><span class="line">输出: [null,null,null,2,1,2]</span><br></pre></td></tr></table></figure><p><strong>示例2:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">["MaxQueue","pop_front","max_value"]</span><br><span class="line">[[],[],[]]</span><br><span class="line">输出: [null,-1,-1]</span><br></pre></td></tr></table></figure><blockquote><p>注意</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 1 &lt;= push_back,pop_front,max_value的总操作数 &lt;= 10000</span><br><span class="line">2. 1 &lt;= value &lt;= 10^5</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><blockquote><p>本题难点</p></blockquote><p>时间复杂度有要求为O(N)</p><blockquote><p>具体思路</p></blockquote><p>使用两个队列：一个队列正常入队出队；再用一个双端队列来辅助作为单调队列，维护队头最大值。这样max_value()查询，单调队列队首的值就是查询的最大值。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Queue&lt;Integer&gt; queue;</span><br><span class="line">    Deque&lt;Integer&gt; deque;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MaxQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">max_value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//单调队列队首就是最大值</span></span><br><span class="line">        <span class="keyword">return</span> queue.isEmpty() ? -<span class="number">1</span> : deque.peekFirst();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        queue.add(value);</span><br><span class="line">      <span class="comment">//维护单调队列的单调性：把小的都出队了 队列剩余的都是比当前元素大的，所以是单调递增，队首就是最大值</span></span><br><span class="line">      <span class="comment">//如果之前入队的队尾比后入队的当前元素还要小，就让队尾出队</span></span><br><span class="line">        <span class="keyword">while</span>(!deque.isEmpty() &amp;&amp; deque.peekLast() &lt; value)&#123;</span><br><span class="line">            deque.pollLast();</span><br><span class="line">        &#125;</span><br><span class="line">        deque.add(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//当普通队列的队首元素 等于 单调队列队首 就让单调队列队首出队</span></span><br><span class="line">        <span class="keyword">if</span>(!deque.isEmpty() &amp;&amp; deque.peekFirst().equals(queue.peek()))&#123;</span><br><span class="line">            deque.pollFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.isEmpty() ? -<span class="number">1</span> : queue.poll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(1) ： 删除操作于求最大值操作显然只需要 O(1) 的时间。而插入操作虽然看起来有循环，做一个插入操作时最多可能会有 n 次出队操作。但要注意，由于每个数字只会出队一次，因此对于所有的 n 个数字的插入过程，对应的所有出队操作也不会大于 n 次。因此将出队的时间均摊到每个插入操作上，时间复杂度为 O(1)。</li><li>空间复杂度 O(N) ： 需要用队列存储所有插入的元素。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 队列 </tag>
            
            <tag> 双端队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 61. 扑克牌中的顺子</title>
      <link href="/2020/08/08/%E5%89%91%E6%8C%87-Offer-61-%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90/"/>
      <url>/2020/08/08/%E5%89%91%E6%8C%87-Offer-61-%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<h3 id="题目信息"><a class="markdownIt-Anchor" href="#题目信息"></a> 题目信息</h3><ul><li><p>题目： 剑指 Offer 61. 扑克牌中的顺子</p></li><li><p>时间： 2020-08-08</p></li><li><p>题目链接：<a href="https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/" target="_blank" rel="noopener">Leetcode</a></p></li><li><p>tag：  哈希表 排序</p></li><li><p>难易程度：中等</p></li><li><p>题目描述：</p><p>从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。</p></li></ul><p><strong>示例1:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure><p><strong>示例2:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,0,1,2,5]</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure><blockquote><p>注意</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 数组长度为 5 </span><br><span class="line">2. 数组的数取值为 [0, 13]</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><blockquote><p>本题难点</p></blockquote><p>顺子包含’大小王’的特殊情况。</p><blockquote><p>具体思路</p></blockquote><p>集合 Set + 遍历</p><p>5 张牌是顺子的 <strong>充分条件</strong>：</p><ul><li>除大小王外，所有牌 <strong>无重复</strong> ；</li><li>设此 5张牌中最大的牌为 max ，最小的牌为 min（大小王除外），则需满足：max − min &lt; 5</li></ul><blockquote><p>提示</p></blockquote><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isStraight</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span> || nums == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> min = <span class="number">13</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">          <span class="comment">//遍历五张牌，遇到大小王（即 0 ）直接跳过。</span></span><br><span class="line">            <span class="keyword">if</span>(num == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">//获取最大 / 最小的牌： 借助辅助变量 max 和 min ，遍历统计即可。</span></span><br><span class="line">            min = Math.min(num,min);</span><br><span class="line">            max = Math.max(num,max);</span><br><span class="line"></span><br><span class="line">          <span class="comment">//判别重复： 利用 Set 实现遍历判重</span></span><br><span class="line">            <span class="keyword">if</span>(set.contains(num))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max - min &lt; <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(N) ： 其中 N为 nums长度，本题中 N=5 ；遍历数组使用 O(N)时间。</li><li>空间复杂度 O(N) ： 用于判重的辅助 Set 使用 O(N)额外空间。</li></ul><h3 id="其他优秀解答"><a class="markdownIt-Anchor" href="#其他优秀解答"></a> 其他优秀解答</h3><blockquote><p>解题思路</p></blockquote><p>先对数组执行排序。<br />判别重复： 排序数组中的相同元素位置相邻，通过遍历数组，判断 nums[i]=nums[i+1] 是否成立来判重。</p><p>获取最大 / 最小的牌： 排序后，数组末位元素 nums[4] 为最大牌；元素 nums[joker] 为最小牌，其中 joker 为大小王的数量。</p><blockquote><p>代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isStraight</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> joker = <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(nums); <span class="comment">// 数组排序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">0</span>) joker++; <span class="comment">// 统计大小王数量</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == nums[i + <span class="number">1</span>]) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 若有重复，提前返回 false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">4</span>] - nums[joker] &lt; <span class="number">5</span>; <span class="comment">// 最大牌 - 最小牌 &lt; 5 则可构成顺子</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 62. 圆圈中最后剩下的数字</title>
      <link href="/2020/08/07/%E5%89%91%E6%8C%87-Offer-62-%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97/"/>
      <url>/2020/08/07/%E5%89%91%E6%8C%87-Offer-62-%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h3 id="题目信息"><a class="markdownIt-Anchor" href="#题目信息"></a> 题目信息</h3><ul><li><p>题目： 剑指 Offer 62. 圆圈中最后剩下的数字</p></li><li><p>时间： 2020-08-07</p></li><li><p>题目链接：<a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/" target="_blank" rel="noopener">Leetcode</a></p></li><li><p>tag： 动态规划 迭代 约瑟夫环</p></li><li><p>难易程度：中等</p></li><li><p>题目描述：</p><p>0,1,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。</p><p>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p></li></ul><p><strong>示例1:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: n = 5, m = 3</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure><p><strong>示例2:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: n = 10, m = 17</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><blockquote><p>注意</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 1 &lt;= n &lt;= 10^5</span><br><span class="line">2. 1 &lt;= m &lt;= 10^6</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><blockquote><p>本题难点</p></blockquote><p>约瑟夫环</p><p>N个人围成一圈，第一个人从1开始报数，报M的将被杀掉，下一个人接着从1开始报。如此反复，最后剩下一个，求最后的胜利者。</p><blockquote><p>具体思路</p></blockquote><p>约塞夫问题就是用人来举例的，那我们也<strong>给每个人一个编号</strong>（索引值），每个人用<strong>字母</strong>代替</p><p>下面这个例子是<code>N=8 m=3</code>的例子</p><p>我们定义<code>F(n,m)</code>表示最后剩下那个人的<code>索引号</code>，因此我们只关系最后剩下来这个人的索引号的变化情况即可</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/img/20200710223002.png" alt="image-20200710222956328" /></p><p>从8个人开始，每次杀掉一个人，去掉被杀的人，然后把杀掉那个人之后的第一个人作为开头重新编号</p><ul><li>第一次C被杀掉，人数变成7，D作为开头，（最终活下来的G的编号从6变成3）</li><li>第二次F被杀掉，人数变成6，G作为开头，（最终活下来的G的编号从3变成0）</li><li>第三次A被杀掉，人数变成5，B作为开头，（最终活下来的G的编号从0变成3）</li><li>以此类推，当只剩一个人时，他的编号必定为0！（重点！）</li></ul><p>现在我们知道了G的索引号的变化过程，那么我们反推一下<br />从<code>N = 7</code> 到<code>N = 8</code> 的过程</p><p>如何才能将<code>N = 7</code> 的排列变回到<code>N = 8</code> 呢？</p><p>我们先把被杀掉的C补充回来，然后右移m个人，发现溢出了，再把溢出的补充在最前面</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/img/20200710223708.png" alt="image-20200710223150733" /></p><p>因此我们可以推出递推公式f(8,3)=[f(7,3)+3]%8</p><p>进行推广泛化，即f(n,m)=[f(n−1,m)+m]%n</p><ul><li>递推公式</li></ul><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/img/20200710224044asd.png" alt="image-20200710223906449" /></p><blockquote><p>提示 : 最终剩下的数字的数组下标为0；</p></blockquote><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= n; i++)&#123;</span><br><span class="line">            res = (res + m) % i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(N) ：其中 N为 迭代n次的长度。</li><li>空间复杂度 O(1) ： 变量 res 使用常数大小的额外空间。</li></ul><h3 id="其他优秀解答"><a class="markdownIt-Anchor" href="#其他优秀解答"></a> 其他优秀解答</h3><blockquote><p>解题思路</p></blockquote><p>模拟链表。纯暴力的做法，每次找到删除的那个数字，需要 O(m) 的时间复杂度，然后删除了 n−1 次。但实际上我们可以直接找到下一个要删除的位置的。假设当前删除的位置是 idx，下一个删除的数字的位置是 idx+m 。但是，由于把当前位置的数字删除了，后面的数字会前移一位，所以实际的下一个位置是 idx+m−1。由于数到末尾会从头继续数，所以最后取模一下，就是 (idx+m−1)(modn)。</p><blockquote><p>代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            idx = (idx + m - <span class="number">1</span>) % n;</span><br><span class="line">            list.remove(idx);</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 迭代 </tag>
            
            <tag> 约瑟夫环 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 63. 股票的最大利润</title>
      <link href="/2020/08/06/%E5%89%91%E6%8C%87-Offer-63-%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/"/>
      <url>/2020/08/06/%E5%89%91%E6%8C%87-Offer-63-%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/</url>
      
        <content type="html"><![CDATA[<h3 id="题目信息"><a class="markdownIt-Anchor" href="#题目信息"></a> 题目信息</h3><ul><li><p>题目：剑指 Offer 63. 股票的最大利润</p></li><li><p>时间： 2020-08-06</p></li><li><p>题目链接：<a href="https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/" target="_blank" rel="noopener">Leetcode</a></p></li><li><p>tag：动态规划</p></li><li><p>难易程度：中等</p></li><li><p>题目描述：</p><p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p></li></ul><p><strong>示例1:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</span><br></pre></td></tr></table></figure><p><strong>示例2:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><blockquote><p>注意</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. 0 &lt;= 数组长度 &lt;= 10^5</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><blockquote><p>本题难点</p></blockquote><p>共有 n 天，第 a 天买，第 b 天卖，则需保证 a&lt;b ；可推出交易方案数共有：(<em>n</em>−1)+(<em>n</em>−2)+⋯+2+1=<em>n</em>(<em>n</em>−1)/2种，暴力法的时间复杂度为 O(n^2)。</p><blockquote><p>具体思路</p></blockquote><p>动态规划</p><ul><li><p><strong>状态定义</strong>：设动态规划列表 dp ，dp[i] 代表以 prices[i] 为结尾的子数组的最大利润（以下简称为 前 i 日的最大利润 ）。</p></li><li><p><strong>转移方程</strong>：由于题目限定 “买卖该股票一次” ，因此前 i 日最大利润 dp[i] 等于前 i−1 日最大利润 dp[i−1] 和第 i 日卖出的最大利润中的最大值。</p><p>dp[i] = mac(dp[i -1],prices[i] - min(prices[0:i]))</p></li></ul><blockquote><p>提示:由于 dp[i] 只与 dp[i−1] , prices[i] , cost 相关，因此可使用一个变量（记为利润 profit ）代替 dp 列表。</p></blockquote><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cost = Integer.MAX_VALUE, profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> price : prices) &#123;</span><br><span class="line">            cost = Math.min(cost, price);</span><br><span class="line">            profit = Math.max(profit, price - cost);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(N) ： 其中 N为 prices列表长度，动态规划需遍历 prices。</li><li>空间复杂度 O(1) ：   变量 cost和 profit 使用常数大小的额外空间。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 64. 求1+2+…+n</title>
      <link href="/2020/08/05/%E5%89%91%E6%8C%87-Offer-64-%E6%B1%821-2-%E2%80%A6-n/"/>
      <url>/2020/08/05/%E5%89%91%E6%8C%87-Offer-64-%E6%B1%821-2-%E2%80%A6-n/</url>
      
        <content type="html"><![CDATA[<h3 id="题目信息"><a class="markdownIt-Anchor" href="#题目信息"></a> 题目信息</h3><ul><li><p>题目；剑指 Offer 64. 求1+2+…+n</p></li><li><p>时间： 2020-08-05</p></li><li><p>题目链接：<a href="https://leetcode-cn.com/problems/qiu-12n-lcof/" target="_blank" rel="noopener">Leetcode</a></p></li><li><p>tag：位运算 限制运算符号</p></li><li><p>难易程度：中等</p></li><li><p>题目描述：</p><p>求 <code>1+2+...+n</code> ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p></li></ul><p><strong>示例1:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: n = 3</span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure><p><strong>示例2:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: n = 9</span><br><span class="line">输出: 45</span><br></pre></td></tr></table></figure><blockquote><p>注意</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. 1 &lt;= n &lt;= 10000</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><blockquote><p>本题难点</p></blockquote><p>不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句</p><blockquote><p>具体思路</p></blockquote><p>逻辑运算符：</p><ul><li>if(A &amp;&amp; B)  // 若 A 为 false ，则 B 的判断不会执行（即短路），直接判定 A &amp;&amp; B 为 false</li><li>if(A || B) // 若 A 为 true ，则 B 的判断不会执行（即短路），直接判定 A || B 为 true</li></ul><p>本题需要实现 “当 n=1 时终止递归” 的需求，可通过短路效应实现</p><p>n &gt; 1 &amp;&amp; sumNums(n - 1) // 当 n = 1 时 n &gt; 1 不成立 ，此时 “短路” ，终止后续递归</p><blockquote><p>提示</p></blockquote><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> flag = n &gt; <span class="number">1</span> &amp;&amp; sumNums(n-<span class="number">1</span>)&gt;<span class="number">0</span>;</span><br><span class="line">        res += n;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(N) ： 计算 n+(n−1)+…+2+1<em>n</em>+(<em>n</em>−1)+…+2+1 需要开启 n 个递归函数。</li><li>空间复杂度 O(N) ：  递归深度达到 n，系统使用 O(n)大小的额外空间。</li></ul><h3 id="其他优秀解答"><a class="markdownIt-Anchor" href="#其他优秀解答"></a> 其他优秀解答</h3><blockquote><p>解题思路</p></blockquote><p>平均计算、迭代、递归</p><blockquote><p>代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span> + n) * n / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        res += i;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    n += sumNums(n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 限制运算符号 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 65. 不用加减乘除做加法</title>
      <link href="/2020/08/04/%E5%89%91%E6%8C%87-Offer-65-%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95/"/>
      <url>/2020/08/04/%E5%89%91%E6%8C%87-Offer-65-%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="题目信息"><a class="markdownIt-Anchor" href="#题目信息"></a> 题目信息</h3><ul><li><p>题目：剑指 Offer 65. 不用加减乘除做加法</p></li><li><p>时间： 2020-08-04</p></li><li><p>题目链接：<a href="https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/" target="_blank" rel="noopener">Leetcode</a></p></li><li><p>tag： 位运算 限制运算符号</p></li><li><p>难易程度：中等</p></li><li><p>题目描述：</p><p>写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。</p></li></ul><p><strong>示例1:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: a = 1, b = 1</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><blockquote><p>注意</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. a, b 均可能是负数或 0</span><br><span class="line">2. 结果不会溢出 32 位整数</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><blockquote><p>本题难点</p></blockquote><p>求和不使用 “+”、“-”、“*”、“/” 四则运算符号。</p><blockquote><p>具体思路</p></blockquote><p>位运算</p><p>设两数字的二进制形式 a,b ，其求和 s=a+b ，a(i) 代表 a 的二进制第 i 位，则分为以下四种情况：</p><table><thead><tr><th style="text-align:center">a(i)</th><th style="text-align:center">b(i)</th><th style="text-align:center">无进位和n(i)</th><th style="text-align:center">进位和c(i)</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr></tbody></table><p><strong>无进位和</strong> 与 <strong>异或运算</strong> 规律相同</p><p><strong>进位</strong> 和 <strong>与运算</strong> 规律相同（并需左移一位）</p><p>即可将 s = a+b 转化为： s = 非进位和 n + 进位 c</p><p>循环求 n和 c ，直至进位 c=0；此时 s=n，返回 n即可。</p><blockquote><p>提示</p></blockquote><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(b != <span class="number">0</span>)&#123;</span><br><span class="line">            c = (a &amp; b) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            a ^= b;</span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(1) ： 最差情况下（例如 a= 0x7fffffff , b=1 时），需循环 31 次，使用 O(1) 时间；每轮中的常数次位操作使用 O(1) 时间。</li><li>空间复杂度 O(1) ： 使用常数大小的额外空间。</li></ul><h3 id="其他优秀解答"><a class="markdownIt-Anchor" href="#其他优秀解答"></a> 其他优秀解答</h3><blockquote><p>解题思路</p></blockquote><p>递归法，把a+b转换成非进位和+进位，由于不能用加法，因此要一直转换直到第二个加数变成0。</p><blockquote><p>代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 转换成非进位和 + 进位</span></span><br><span class="line">        <span class="keyword">return</span> add(a ^ b, (a &amp; b) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 限制运算符号 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 66. 构建乘积数组</title>
      <link href="/2020/08/03/%E5%89%91%E6%8C%87-Offer-66-%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84/"/>
      <url>/2020/08/03/%E5%89%91%E6%8C%87-Offer-66-%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h3 id="题目信息"><a class="markdownIt-Anchor" href="#题目信息"></a> 题目信息</h3><ul><li><p>题目：剑指 Offer 66. 构建乘积数组</p></li><li><p>时间： 2020-08-03</p></li><li><p>题目链接：<a href="https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/" target="_blank" rel="noopener">Leetcode</a></p></li><li><p>tag：  限制运算符号</p></li><li><p>难易程度：简单</p></li><li><p>题目描述：</p><p>给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B 中的元素 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。</p></li></ul><p><strong>示例:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: [120,60,40,30,24]</span><br></pre></td></tr></table></figure><blockquote><p>注意</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 所有元素乘积之和不会溢出 32 位整数</span><br><span class="line">2. a.length <span class="tag">&lt;<span class="name">=</span> <span class="attr">100000</span></span></span><br></pre></td></tr></table></figure><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><blockquote><p>本题难点</p></blockquote><p>不能使用除法，限制运算符号。</p><blockquote><p>具体思路</p></blockquote><p>B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]</p><table><thead><tr><th>B[i]</th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>B[0] =</td><td>1</td><td>A[1]</td><td>A[2]</td><td>…</td><td>A[n-1]</td><td>A[n]</td></tr><tr><td>B[1] =</td><td>A[0]</td><td>1</td><td>A[2]</td><td>…</td><td>A[n-1]</td><td>A[n]</td></tr><tr><td>B[2] =</td><td>A[0]</td><td>A[1]</td><td>1</td><td>…</td><td>A[n-1]</td><td>A[n]</td></tr><tr><td>…</td><td>…</td><td>…</td><td>…</td><td>…</td><td>…</td><td>…</td></tr><tr><td>B[n-1] =</td><td>A[0]</td><td>A[1]</td><td>A[2]</td><td>…</td><td>1</td><td>A[n]</td></tr><tr><td>B[n] =</td><td>A[0]</td><td>A[1]</td><td>A[2]</td><td>…</td><td>A[n-1]</td><td>1</td></tr></tbody></table><p>根据表格的主对角线（全为 11 ），可将表格分为 <strong>上三角</strong> 和 <strong>下三角</strong> 两部分。分别迭代计算下三角和上三角两部分的乘积，即可 <strong>不使用除法</strong> 就获得结果。</p><blockquote><p>提示：通过两轮循环，分别计算表格中下三角和上三角的乘积。</p></blockquote><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] constructArr(<span class="keyword">int</span>[] a) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">      <span class="comment">//初始化：数组 B ，其中 B[0]=1 ；辅助变量 tmp=1 ；</span></span><br><span class="line">        <span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[a.length];</span><br><span class="line">        b[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">1</span>;</span><br><span class="line">      <span class="comment">//计算 B[i] 的 下三角 各元素的乘积，直接乘入 B[i] ；</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            b[i] = b[i - <span class="number">1</span>] * a[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//计算 B[i] 的 上三角 各元素的乘积，记为 tmp ，并乘入 B[i] </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = a.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            tmp *= a[i + <span class="number">1</span>];</span><br><span class="line">            b[i] *= tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(N) ： 其中 N为数组长度，两轮遍历数组 a，使用 O(N) 时间。</li><li>空间复杂度 O(1) ：  变量 tmp 使用常数大小额外空间（数组 b作为返回值，不计入复杂度考虑）。</li></ul><h3 id="其他优秀解答"><a class="markdownIt-Anchor" href="#其他优秀解答"></a> 其他优秀解答</h3><blockquote><p>解题思路</p></blockquote><p>对称遍历</p><ul><li>从左往右遍历累乘，结果保存在数组 left 中，此时 left[i] 表示，A[i]左边所有元素的乘积</li><li>然后从右往左遍历累乘，结果保存在数组 right中，此时right[i] 表示获取A[i]右边所有元素的乘积</li><li>最后结果数组res[i] =left[i]*right[i]</li></ul><blockquote><p>代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] constructArr(<span class="keyword">int</span>[] a) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a.length == <span class="number">0</span> || a == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = a.length;</span><br><span class="line">        <span class="keyword">int</span>[] left = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span>[] right = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        left[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        right[len-<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= len -<span class="number">1</span>; i++)&#123;</span><br><span class="line">            left[i] = a[i-<span class="number">1</span>] * left[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = len-<span class="number">2</span>; j &gt;= <span class="number">0</span>; j-- )&#123;</span><br><span class="line">            right[j] = a[j+<span class="number">1</span>] * right[j+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            res[i] = left[i] * right[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 限制运算符号 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 68 - I. 二叉搜索树的最近公共祖先</title>
      <link href="/2020/08/02/%E5%89%91%E6%8C%87-Offer-68-I-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
      <url>/2020/08/02/%E5%89%91%E6%8C%87-Offer-68-I-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
      
        <content type="html"><![CDATA[<h3 id="题目信息"><a class="markdownIt-Anchor" href="#题目信息"></a> 题目信息</h3><ul><li><p>题目： 剑指 Offer 68 - I. 二叉搜索树的最近公共祖先</p></li><li><p>时间： 2020-08-02</p></li><li><p>题目链接：<a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/" target="_blank" rel="noopener">Leetcode</a></p></li><li><p>tag：二叉树 二叉搜索树 递归 迭代</p></li><li><p>难易程度：简单</p></li><li><p>题目描述：</p><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p>最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p><p>例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5]</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     6</span><br><span class="line">   /   \</span><br><span class="line">  2     8</span><br><span class="line"> / \   / \</span><br><span class="line">0   4 7   9</span><br><span class="line">   / \</span><br><span class="line">  3   5</span><br></pre></td></tr></table></figure></li></ul><p><strong>示例1:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8</span><br><span class="line">输出: 6 </span><br><span class="line">解释: 节点 2 和节点 8 的最近公共祖先是 6。</span><br></pre></td></tr></table></figure><p><strong>示例2:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4</span><br><span class="line">输出: 2</span><br><span class="line">解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure><blockquote><p>注意</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 所有节点的值都是唯一的。</span><br><span class="line">2. p、q 为不同节点且均存在于给定的二叉搜索树中。</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><blockquote><p>本题难点</p></blockquote><p>最近公共祖先</p><blockquote><p>具体思路</p></blockquote><p><strong>祖先的定义</strong>： 若节点 p 在节点 root 的左（右）子树中，或 p=root，则称 root 是 p 的祖先。</p><p><strong>最近公共祖先的定义</strong>： 设节点 root 为节点 p,q 的某公共祖先，若其左子节点 root.left 和右子节点 root.right 都不是 p,q 的公共祖先，则称 root 是 “最近的公共祖先” 。</p><p>若 root<em>r<strong>o</strong>o**t</em> 是 p,q<em>p</em>,<em>q</em> 的 <strong>最近公共祖先</strong> ，则只可能为以下情况之一：</p><ol><li><em>p</em> 和 q<em>q</em> 在 root 的子树中，且分列 root 的 <strong>异侧</strong>（即分别在左、右子树中）；</li><li><em>p</em>=root，且 q在 root 的左或右子树中；</li><li><em>q</em>=root，且 p 在 root的左或右子树中；</li></ol><p>本题给定了两个重要条件：① 树为 二叉搜索树 ，② 树的所有节点的值都是 唯一 的。根据以上条件，可方便地判断 p,q 与 root 的子树关系，即：</p><ul><li>若 root.val&lt;p.val ，则 p 在 root<strong>右子树</strong> 中</li><li>若 root.val&gt;p.val ，则 p 在 root<strong>左子树</strong> 中</li><li>若 root.val=p.val ，则 p 和root指向同一节点</li></ul><blockquote><p>提示 ：迭代</p></blockquote><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.val &gt; p.val &amp;&amp; root.val &gt; q.val)&#123;<span class="comment">////当 p,q 都在 root 的 左子树 中，则遍历至 root.left</span></span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val &lt; p.val &amp;&amp; root.val &lt; q.val)&#123;<span class="comment">//当 p,q 都在 root 的 右子树 中，则遍历至 root.right</span></span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(N) ：  其中 N为二叉树节点数；每循环一轮排除一层，二叉搜索树的层数最小为 log⁡N（满二叉树），最大为 N（退化为链表）。</li><li>空间复杂度 O(1) ：使用常数大小的额外空间。</li></ul><h3 id="其他优秀解答"><a class="markdownIt-Anchor" href="#其他优秀解答"></a> 其他优秀解答</h3><blockquote><p>解题思路</p></blockquote><p>递归</p><ul><li>当 p,q 都在 root 的 右子树 中，则开启递归 root.right 并返回；</li><li>否则，当 p,q 都在 root 的 左子树 中，则开启递归 root.left 并返回；</li></ul><blockquote><p>代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root.val &lt; p.val &amp;&amp; root.val &lt; q.val)</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="keyword">if</span>(root.val &gt; p.val &amp;&amp; root.val &gt; q.val)</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 二叉搜索树 </tag>
            
            <tag> 迭代 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 68 - II. 二叉树的最近公共祖先</title>
      <link href="/2020/08/01/%E5%89%91%E6%8C%87-Offer-68-II-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
      <url>/2020/08/01/%E5%89%91%E6%8C%87-Offer-68-II-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
      
        <content type="html"><![CDATA[<h3 id="题目信息"><a class="markdownIt-Anchor" href="#题目信息"></a> 题目信息</h3><ul><li><p>题目： 剑指 Offer 68 - II. 二叉树的最近公共祖先</p></li><li><p>时间： 2020-08-01</p></li><li><p>题目链接：<a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/" target="_blank" rel="noopener">Leetcode</a></p></li><li><p>tag：二叉树 递归 深度优先搜索</p></li><li><p>难易程度：中等</p></li><li><p>题目描述：</p><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     3</span><br><span class="line">   /   \</span><br><span class="line">  5     1</span><br><span class="line"> / \   / \</span><br><span class="line">6   2 0   8</span><br><span class="line">   / \</span><br><span class="line">  7   4</span><br></pre></td></tr></table></figure></li></ul><p><strong>示例1:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1</span><br><span class="line">输出: 3</span><br><span class="line">解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</span><br></pre></td></tr></table></figure><p><strong>示例2:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4</span><br><span class="line">输出: 5</span><br><span class="line">解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure><blockquote><p>注意</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 所有节点的值都是唯一的。</span><br><span class="line">2. p、q 为不同节点且均存在于给定的二叉树中。</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><blockquote><p>本题难点</p></blockquote><p>一般二叉树查找最近公共祖先节点。</p><blockquote><p>具体思路</p></blockquote><p>考虑通过递归对二叉树进行后序遍历，当遇到节点 p 或 q 时返回。从底至顶回溯，当节点 p,q 在节点 root 的异侧时，节点 root 即为最近公共祖先，则向上返回 root 。</p><p><strong>递推工作</strong>：</p><ul><li>递归左子节点，返回值记为 left ；</li><li>递归右子节点，返回值记为 right ；</li></ul><p><strong>返回值</strong>：</p><ul><li>当 left 和 right 同时<strong>为空</strong> ：说明 root 的左 / 右子树中都不包含 p,q ，返回 null ；</li><li>当 left 和 right 同时<strong>不为空</strong> ：说明 p,q 分列在 root 的 异侧 （分别在 左 / 右子树），因此 root 为最近公共祖先，返回 root ；</li><li>当 <strong>left 为空</strong> ，<strong>right 不为空</strong> ：p,q 都不在 root 的左子树中，直接返回 right 。具体可分为两种情况：<ol><li><em>p</em>,<em>q</em> 其中一个在 root的 <strong>右子树</strong> 中，此时 right 指向 p（假设为 p ）；</li><li><em>p</em>,<em>q</em> 两节点都在 root 的 <strong>右子树</strong> 中，此时的 right 指向 <strong>最近公共祖先节点</strong> ；</li></ol></li><li>当 <strong>left 不为空</strong> ， <strong>right为空</strong> ：p,q 都不在 root 的右子树中，直接返回 left 。具体可分为两种情况<ol><li><em>p</em>,<em>q</em> 其中一个在 root的 <strong>左子树</strong> 中，此时 left 指向 p（假设为 p ）；</li><li><em>p</em>,<em>q</em> 两节点都在 root 的 <strong>左子树</strong> 中，此时的 left 指向 <strong>最近公共祖先节点</strong> ；</li></ol></li></ul><blockquote><p>提示</p></blockquote><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//当 root 等于 p,q ，则直接返回 root</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span> || root.val == p.val || root.val == q.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode left = lowestCommonAncestor(root.left,p,q);</span><br><span class="line">        TreeNode right = lowestCommonAncestor(root.right,p,q);</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(N) ： 其中 N为二叉树节点数；最差情况下，需要递归遍历树的所有节点。</li><li>空间复杂度 O(N) ：  最差情况下，递归深度达到 N，系统使用 O(N)大小的额外空间。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 深度优先搜索 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typora + PicGo + Github实现图床</title>
      <link href="/2020/07/18/Typora%20+%20PicGo%20+%20Github%E5%AE%9E%E7%8E%B0%E5%9B%BE%E5%BA%8A/"/>
      <url>/2020/07/18/Typora%20+%20PicGo%20+%20Github%E5%AE%9E%E7%8E%B0%E5%9B%BE%E5%BA%8A/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h2><p>在日常记录学习笔记以及自己的想法时，都会使用到Typora这款优秀的<code>Markdown</code>编辑器，<a href="https://typora.io/" target="_blank" rel="noopener">Typora</a>编写出来的编写的排版让强迫的我也挑不出毛病，极力推荐使用，大家可自行感受写作带来的乐趣。但是在写作的过程中，最大的痛点就是粘贴的图片在本地查看文档是没有问题的，但是把文章复制到博客后，就会存在图片无法加载的情况，为此，寻求<code>google</code>帮助，解决这件麻烦事。在写这篇文章前，终于得到了解决。</p><h2 id="前期准备"><a class="markdownIt-Anchor" href="#前期准备"></a> 前期准备</h2><p>Typora：<a href="https://typora.io/" target="_blank" rel="noopener">官网链接</a>，傻瓜式安装就可以了</p><p>PicGo ：<a href="https://molunerfinn.com/PicGo/" target="_blank" rel="noopener">官网链接</a>，下载在自己能找到的地方</p><p>Github账号注册与仓库创建：作为一个互联网的搬砖师，多多少少也是知道的吧，不会的请自行<code>Google</code>，创建仓库的目的主要是用来存储照片</p><h2 id="软件设置"><a class="markdownIt-Anchor" href="#软件设置"></a> 软件设置</h2><h3 id="typora设置"><a class="markdownIt-Anchor" href="#typora设置"></a> Typora设置</h3><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/2020/07/18/822c637b26def0205359b4d2d733ca52.png" alt="20200718122954gu8y3" /></p><h3 id="picgo设置"><a class="markdownIt-Anchor" href="#picgo设置"></a> PicGo设置</h3><p>参数说明：</p><ul><li>仓库名：表示远程仓库地址，固定格式 <code>Github用户名/仓库名</code>，前期准备用到的仓库</li><li>分支名：表示分支，默认填入master，需要根据自己Github上的分支进行填写</li><li>Token：填入Github中生成的Token，下方将详细讲解Token获取</li><li>存储路径：可以自定义一个文件路径</li><li>自定义域名：建议使用<code>https:cdn.jsdelivr.net/gh/Github用户名/仓库名</code></li></ul><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/2020/07/18/e3c3a1574cb6f45bc25ca5cd756d5586.png" alt="202007181238490ya9y" /></p><h3 id="github-token生成"><a class="markdownIt-Anchor" href="#github-token生成"></a> Github Token生成</h3><p>步骤：</p><ol><li>进入Github首页</li><li>点击右上角的头像</li><li>选择Settings</li><li>在左边的选项中选择Developer settings</li><li>选择左边的Personal access tokens，点击Generate new token后会让你输入github登录密码，验证身份后进入以下页面</li><li>输入Note信息和勾选上对应的repo权限后滑动到最下方，选择Generate token</li><li>就会生成一条Token信息，生成的Token只会出现一次，切记保存</li></ol><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/2020/07/18/75a59eb5f050007a1f98ae2dff4e0cd0.png" alt="github创建Token" /></p><h2 id="测试是否能正常上传"><a class="markdownIt-Anchor" href="#测试是否能正常上传"></a> 测试是否能正常上传</h2><p>为了保证我们上传图片没有问题，可以在Typora中选择 文件 → 偏好设置 → 选择验证图片上传选项进行测试，如看到验证成功，成功上传图片并获得最新的URL则表示成功</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/2020/07/18/ce6fdc9671489711351fdadd9b9c4ac7.png" alt="20200718124545orsasdym" /></p><p>也可以直接在文档中插入图片来查看是否上传成功</p><h2 id="踩坑记录"><a class="markdownIt-Anchor" href="#踩坑记录"></a> 踩坑记录</h2><p>用了一段时间突然发现不能上传了类似下图这样。</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/2020/07/18/14f3a4d60b9742c6abc24e5a5896f5dd.png" alt="aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NvZGV0d29kb2cvQmxvZy1QaWMtUmVwb3NpdG9yeS9tYXN0ZXIvYmxvZ0ltZy9QaWNHb2dpdGh1YiVFNSU4NyVCQSVFOSU5NCU5OSVFNCVCRiVBMSVFNiU4MSVBRi5wbmc" /></p><ul><li>再次检查你的仓库名是否正确，仓库名不能出现空格！！如果一定要有空格请用 - 来代替</li><li>不能上传文件名重复的图片</li><li>文件名不要包含奇怪的字符（加号、乘号、百分号等等）</li></ul><h2 id="解决图床上传的各种问题"><a class="markdownIt-Anchor" href="#解决图床上传的各种问题"></a> 解决图床上传的各种问题</h2><p>有时候间接性还会出现上传失败的问题</p><p>查看日志发现</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/2020/07/18/7b7f823bb7f0aef19f3ee2cd0a6fd236.png" alt="20200718125526q4f5y" /></p><p>解决思路：</p><p>搭一个中间代理</p><h3 id="所需工具"><a class="markdownIt-Anchor" href="#所需工具"></a> 所需工具</h3><ul><li>VPN</li><li>google或outlook邮箱</li></ul><h3 id="解决步骤"><a class="markdownIt-Anchor" href="#解决步骤"></a> 解决步骤</h3><h4 id="进入下方网址"><a class="markdownIt-Anchor" href="#进入下方网址"></a> 进入下方网址</h4><p><a href="https://www.000webhost.com/" target="_blank" rel="noopener">https://www.000webhost.com/</a> ,浏览网页选择下方箭头所指。<br />(没有该网站账号密码没有关系，选择之后注册登录即可，当然也可以先注册登录再选择。)</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/2020/07/18/dbb2a9e0d59372fb0cb3c45db37065a7.png" alt="cd8a16b2a5ed295aa3f5b" /></p><h4 id="建立自己的网站"><a class="markdownIt-Anchor" href="#建立自己的网站"></a> 建立自己的网站</h4><p>网站用户名密码自定义设置</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/2020/07/18/ddf7871cd7f5a2cff889681578a83338.png" alt="aaaab0964503f59a7f9" /></p><h4 id="选择upload-your-site"><a class="markdownIt-Anchor" href="#选择upload-your-site"></a> 选择Upload your site</h4><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/2020/07/18/bdfeafd77cf1ec7ca35d6dceecd6fd85.png" alt="bbbb65589d4082ab" /></p><p>此时我们需要给网站上传一个up.php配置文件</p><h4 id="配置upphp"><a class="markdownIt-Anchor" href="#配置upphp"></a> 配置up.php</h4><p>项目地址：<a href="https://github.com/kjhuanhao/autoPicCdn" target="_blank" rel="noopener">https://github.com/kjhuanhao/autoPicCdn</a><br />下载此项目，修改其中的<strong>up.php</strong>文件。<br />只需修改下列代码，按提示修改即可：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="string">"REPO"</span>,<span class="string">"仓库"</span>);<span class="comment">//必须是下面用户名下的公开仓库</span></span><br><span class="line">define(<span class="string">"USER"</span>,<span class="string">"github仓库名"</span>);<span class="comment">//必须是当前GitHub用户名</span></span><br><span class="line">define(<span class="string">"MAIL"</span>,<span class="string">"yumusb@foxmail.com"</span>);<span class="comment">//</span></span><br><span class="line">define(<span class="string">"TOKEN"</span>,<span class="string">"token"</span>);<span class="comment">//https://github.com/settings/tokens 去这个页面生成一个有写权限的token（write:packages前打勾）</span></span><br></pre></td></tr></table></figure><p><strong>特别注意：token只会生成一次，且生成后不再显示，如果忘记需要重新生成，但是之前生成的就是失效。注意保存！</strong></p><p>修改完毕之后保存即可。</p><h4 id="上传upphp"><a class="markdownIt-Anchor" href="#上传upphp"></a> 上传up.php</h4><p>如图所示操作</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/2020/07/18/bc101c5cb2f4f56183582254acd7ec58.png" alt="cccccd41d47fca87a" /></p><h4 id="保存地址"><a class="markdownIt-Anchor" href="#保存地址"></a> 保存地址</h4><p>访问下列地址:<br /><a href="https://www.000webhost.com/members/website/list" target="_blank" rel="noopener">https://www.000webhost.com/members/website/list</a><br />复制下方箭头所指地址：</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/2020/07/18/d5720aac20281fc9ef7b68d059d09dae.png" alt="dddddd2652c48e1a54ac" />（注：鼠标移至该地址上方图片可选择管理网站，如果因网络不佳中途是关闭网址，可以访问上述超链接进入该网址选择管理网站，进入网站的管理界面，选择其中的File Manager可进入上传up.php的界面。）</p><h4 id="配置picgo"><a class="markdownIt-Anchor" href="#配置picgo"></a> 配置PicGo</h4><p>打开PicGo ——&gt; 选择插件设置 ——&gt; 搜索<strong>web-uploader</strong></p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/2020/07/18/300d8a5f0ad8a1f55d382e6b37dc0822.png" alt="qqqqqeba05a0da2" />之后点击插件模块右下角的设置样式，选择配置uploader -up -uploader</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">API地址填写刚刚复制的地址</span> <span class="string">+ /up.php</span></span><br><span class="line"><span class="attr">POST参数名填写pic</span></span><br><span class="line"><span class="attr">JSON路径填写data.url</span></span><br></pre></td></tr></table></figure><p>填写完毕之后，保存即可！</p><h4 id="自定义web图床"><a class="markdownIt-Anchor" href="#自定义web图床"></a> 自定义web图床</h4><p>上述全部设置完毕之后，在picgo上传区选择自定义图床。之后，就可以进行图片的上传了！</p><h2 id="写在最后"><a class="markdownIt-Anchor" href="#写在最后"></a> 写在最后</h2><p>这次的搭建虽然经历了一些波折，但也算搭建成功了，希望正在搭建的朋友看到我这篇文章能少走一点弯路，顺利把图床搭建起来。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图床 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Hexo博客系统的使用</title>
      <link href="/2020/07/14/%E5%85%B3%E4%BA%8EHexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/07/14/%E5%85%B3%E4%BA%8EHexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。<br />这是一篇关于Hexo博客系统如何使用的文章，最基本的操作指令。</p><blockquote><p>Hexo基本指令</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Usage: hexo &lt;<span class="built_in">command</span>&gt;</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  clean     Remove generated files and cache.</span><br><span class="line">  config    Get or <span class="built_in">set</span> configurations.</span><br><span class="line">  deploy    Deploy your website.</span><br><span class="line">  douban    Generate pages from douban</span><br><span class="line">  generate  Generate static files.</span><br><span class="line">  <span class="built_in">help</span>      Get <span class="built_in">help</span> on a <span class="built_in">command</span>.</span><br><span class="line">  init      Create a new Hexo folder.</span><br><span class="line">  list      List the information of the site</span><br><span class="line">  migrate   Migrate your site from other system to Hexo.</span><br><span class="line">  new       Create a new post.</span><br><span class="line">  publish   Moves a draft post from _drafts to _posts folder.</span><br><span class="line">  render    Render files with renderer plugins.</span><br><span class="line">  server    Start the server.</span><br><span class="line">  version   Display version information.</span><br><span class="line"></span><br><span class="line">Global Options:</span><br><span class="line">  --config  Specify config file instead of using _config.yml</span><br><span class="line">  --cwd     Specify the CWD</span><br><span class="line">  --debug   Display all verbose messages <span class="keyword">in</span> the terminal</span><br><span class="line">  --draft   Display draft posts</span><br><span class="line">  --safe    Disable all plugins and scripts</span><br><span class="line">  --silent  Hide output on console</span><br></pre></td></tr></table></figure><blockquote><p>编译博客</p></blockquote><p>在项目根目录执行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">或者</span><br><span class="line">hexo g</span><br></pre></td></tr></table></figure><blockquote><p>本地运行博客</p></blockquote><p>在项目根目录执行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br><span class="line">或者</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><blockquote><p>发布博客</p></blockquote><p>在项目根目录执行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br><span class="line">或者</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><blockquote><p>发布新页面</p></blockquote><ol><li><p>项目根目录下执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page xxx</span><br></pre></td></tr></table></figure></li><li><p>在项目source目录下会产生xxx页面的文件夹，在xxx文件夹下的index.md文档中编辑页面配置</p></li><li><p>页面头部信息</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title:</span><br><span class="line">date:</span><br><span class="line">updated:</span><br><span class="line">type:</span><br><span class="line">comments:</span><br><span class="line">description:</span><br><span class="line">keywords:</span><br><span class="line">top_img:</span><br><span class="line">mathjax:</span><br><span class="line">katex:</span><br><span class="line">aside:</span><br><span class="line">aplayer：</span><br><span class="line">highlight_shrink：</span><br><span class="line">---</span><br></pre></td></tr></table></figure><table><thead><tr><th>写法</th><th>解释</th></tr></thead><tbody><tr><td>title</td><td>【必需】页面标题</td></tr><tr><td>date</td><td>【必需】页面创建日期</td></tr><tr><td>type</td><td>【必需】标籤、分类和友情链接三个页面需要配置</td></tr><tr><td>updated</td><td>【可选】页面更新日期</td></tr><tr><td>description</td><td>【可选】文章描述</td></tr><tr><td>keywords</td><td>【可选】文章关键字</td></tr><tr><td>comments</td><td>【可选】显示页面评论模块(默认 true)</td></tr><tr><td>top_img</td><td>【可选】页面顶部图片</td></tr><tr><td>comments</td><td>【可选】显示文章评论模块(默认 true)</td></tr><tr><td>mathjax</td><td>【可选】显示mathjax(当设置mathjax的per_page: false时，才需要配置，默认 false)轉載請註明出處。</td></tr><tr><td>katex</td><td>【可选】显示katex(当设置katex的per_page: false时，才需要配置，默认 false)</td></tr><tr><td>aside</td><td>【可选】显示侧边栏 (默认 true)</td></tr><tr><td>aplayer</td><td>【可选】在需要的页面加载aplayer的js和css,请参考文章下面的音乐 配置</td></tr><tr><td>highlight_shrink</td><td>【可选】配置代码框是否展开(true/false)(默认为设置中highlight_shrink的配置)</td></tr></tbody></table></li></ol><blockquote><p>发布新文章</p></blockquote><ol><li><p>项目根目录下执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new post xxx</span><br></pre></td></tr></table></figure></li><li><p>在项目source/_posts目录下会产生xxx.md文档,在文档头部中编辑文章配置</p></li><li><p>文章头部信息</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title:</span><br><span class="line">date:</span><br><span class="line">updated:</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br><span class="line">keywords:</span><br><span class="line">description:</span><br><span class="line">top_img:</span><br><span class="line">comments：</span><br><span class="line">cover:  </span><br><span class="line">toc:  </span><br><span class="line">toc_number:</span><br><span class="line">auto_open:</span><br><span class="line">copyright:</span><br><span class="line">mathjax:</span><br><span class="line">katex:</span><br><span class="line">aplayer：</span><br><span class="line">highlight_shrink：</span><br><span class="line">---</span><br></pre></td></tr></table></figure><table><thead><tr><th>写法</th><th>解释</th></tr></thead><tbody><tr><td>title</td><td>【必需】文章标题</td></tr><tr><td>date</td><td>【必需】文章创建日期</td></tr><tr><td>updated</td><td>【可选】文章更新日期</td></tr><tr><td>tags</td><td>【可选】文章标籤</td></tr><tr><td>categories</td><td>【可选】文章分类</td></tr><tr><td>keywords</td><td>【可选】文章关键字</td></tr><tr><td>description</td><td>【可选】文章描述</td></tr><tr><td>top_img</td><td>【可选】文章顶部图片</td></tr><tr><td>cover</td><td>【可选】文章缩略图(如果没有设置top_img,文章页顶部将显示缩略图，可设为false/图片地址/留空)</td></tr><tr><td>comments</td><td>【可选】显示文章评论模块(默认 true)</td></tr><tr><td>toc</td><td>【可选】显示文章TOC(默认为设置中toc的enable配置)</td></tr><tr><td>toc_number</td><td>【可选】显示toc_number(默认为设置中toc的number配置)</td></tr><tr><td>auto_open</td><td>【可选】是否自动打开TOC(默认为设置中toc的auto_open配置)</td></tr><tr><td>copyright</td><td>【可选】显示文章版权模块(默认为设置中post_copyright的enable配置)</td></tr><tr><td>mathjax</td><td>【可选】显示mathjax(当设置mathjax的per_page: false时，才需要配置，默认 false)轉載請註明出處。</td></tr><tr><td>katex</td><td>【可选】显示katex(当设置katex的per_page: false时，才需要配置，默认 false)</td></tr><tr><td>aplayer</td><td>【可选】在需要的页面加载aplayer的js和css,请参考文章下面的音乐 配置</td></tr><tr><td>highlight_shrink</td><td>【可选】配置代码框是否展开(true/false)(默认为设置中highlight_shrink的配置)</td></tr></tbody></table></li></ol><p>更详细博客配置请参考<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a><br />更详细主题配置请参考<a href="https://demo.jerryc.me" target="_blank" rel="noopener">Butterfly</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
