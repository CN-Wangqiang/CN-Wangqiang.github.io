<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小锵的博客</title>
  
  <subtitle>博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wangqiang.cool/"/>
  <updated>2021-01-13T16:45:58.491Z</updated>
  <id>http://wangqiang.cool/</id>
  
  <author>
    <name>小锵同学、</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>每日一题 - 股票问题</title>
    <link href="http://wangqiang.cool/2021/01/14/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/"/>
    <id>http://wangqiang.cool/2021/01/14/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/</id>
    <published>2021-01-13T16:44:52.000Z</published>
    <updated>2021-01-13T16:45:58.491Z</updated>
    
    <content type="html"><![CDATA[<h2 id="每日一题-股票问题"><a class="markdownIt-Anchor" href="#每日一题-股票问题"></a> 每日一题 - 股票问题</h2><ul><li><p>时间： 2021-01-10</p></li><li><p>题目链接：</p><ul><li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">买卖股票的最佳时机</a></li><li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">买卖股票的最佳时机 II</a></li><li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank" rel="noopener">买卖股票的最佳时机 III</a></li><li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/" target="_blank" rel="noopener">买卖股票的最佳时机 IV</a></li><li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/" target="_blank" rel="noopener">买卖股票的最佳时机含手续费</a></li><li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">最佳买卖股票时机含冷冻期</a></li></ul></li><li><p>题目内容：给一组数组，代表一段时期内的股票价格，如何买卖股票可以让我们获利最多。</p><ul><li>只可以交易一次时</li><li>没有交易次数限制，尽可能多的交易次数时</li><li>只可以交易两次时</li><li>规定交易次数限制时</li><li>没有交易次数限制，但每次交易都有手续费时</li><li>卖完第二天的冷静期无法购买时</li></ul></li><li><p>tag：动态规划</p></li><li><p>难易程度：从简单到困难</p></li></ul><h2 id="买卖股票的最佳时机"><a class="markdownIt-Anchor" href="#买卖股票的最佳时机"></a> 买卖股票的最佳时机</h2><h3 id="题目信息"><a class="markdownIt-Anchor" href="#题目信息"></a> 题目信息</h3><ul><li><p>题目描述：</p><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</p></li></ul><p><strong>示例1:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br></pre></td></tr></table></figure><p><strong>示例2:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><blockquote><p>注意</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. 你不能在买入股票前卖出股票。</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><blockquote><p>本题难点</p></blockquote><p>我们需要找出给定数组中两个数字之间的最大差值（即，最大利润）。此外，第二个数字（卖出价格）必须大于第一个数字（买入价格）。</p><p>形式上，对于每组 i 和 j（其中 j&gt;i)，我们需要找出max(prices[j]−prices[i])。</p><blockquote><p>具体思路</p></blockquote><p>我们来假设自己来购买股票。随着时间的推移，每天我们都可以选择出售股票与否。那么，假设在第 i 天，如果我们要在今天卖股票，那么我们能赚多少钱呢？</p><p>显然，如果我们真的在买卖股票，我们肯定会想：如果我是在历史最低点买的股票就好了！太好了，在题目中，我们只要用一个变量记录一个历史最低价格 minprice，我们就可以假设自己的股票是在那天买的。那么我们在第 i 天卖出股票能得到的利润就是 prices[i] - minprice。</p><p>因此，我们只需要遍历价格数组一遍，记录历史最低点，然后在每一天考虑这么一个问题：如果我是在历史最低点买进的，那么我今天卖出能赚多少钱？当考虑完所有天数之时，我们就得到了最好的答案。</p><blockquote><p>提示</p></blockquote><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> price : prices)&#123;</span><br><span class="line">            <span class="keyword">if</span>(price &lt; min)&#123;</span><br><span class="line">                min = price;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                profit = Math.max(price - min,profit);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(N) ： 只需要遍历一次。</li><li>空间复杂度 O(1) ：  只使用了常数个变量。</li></ul><h3 id="其他解答"><a class="markdownIt-Anchor" href="#其他解答"></a> 其他解答</h3><blockquote><p>解题思路</p></blockquote><p>暴力法</p><blockquote><p>代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> prices[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxprofit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; prices.length; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> profit = prices[j] - prices[i];</span><br><span class="line">                <span class="keyword">if</span> (profit &gt; maxprofit) &#123;</span><br><span class="line">                    maxprofit = profit;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxprofit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(N^2) ： 循环运行 n(n−1)/2 次</li><li>空间复杂度 O(1) ： 只使用了常数个变量。</li></ul><h2 id="买卖股票的最佳时机-ii"><a class="markdownIt-Anchor" href="#买卖股票的最佳时机-ii"></a> 买卖股票的最佳时机 II</h2><h3 id="题目信息-2"><a class="markdownIt-Anchor" href="#题目信息-2"></a> 题目信息</h3><ul><li><p>题目描述：</p><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p></li></ul><p><strong>示例1:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</span><br><span class="line">     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</span><br></pre></td></tr></table></figure><p><strong>示例2:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</span><br><span class="line">注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。</span><br><span class="line">因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br></pre></td></tr></table></figure><p><strong>示例2:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><blockquote><p>注意</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</span><br></pre></td></tr></table></figure><h3 id="解题思路-2"><a class="markdownIt-Anchor" href="#解题思路-2"></a> 解题思路</h3><blockquote><p>本题难点</p></blockquote><p>考虑到「不能同时参与多笔交易」，因此每天交易结束后只可能存在手里有一支股票或者没有股票的状态。</p><blockquote><p>具体思路</p></blockquote><ol><li><p>定义状态<br />dp[i] [0]表示第 i 天交易完后手里没有股票的最大利润，dp[i] [1] 表示第 i 天交易完后手里持有一支股票的最大利润（i 从 0 开始）。</p></li><li><p>考虑 dp[i] [0] 的转移方程，如果这一天交易完后手里没有股票，那么可能的转移状态为前一天已经没有股票，即 dp[i−1] [0]，或者前一天结束的时候手里持有一支股票，即 dp[i−1] [1]，这时候我们要将其卖出，并获得 prices[i] 的收益。因此为了收益最大化，我们列出如下的转移方程：</p><p>dp[i] [0]=max{dp[i−1] [0],dp[i−1] [1]+prices[i]}</p></li><li><p>再来考虑 dp[i] [1]，按照同样的方式考虑转移状态，那么可能的转移状态为前一天已经持有一支股票，即<br />dp[i−1] [1]，或者前一天结束时还没有股票，即 dp[i−1] [0]，这时候我们要将其买入，并减少<br />prices[i] 的收益。可以列出如下的转移方程：</p><p>dp[i] [1]=max{dp[i−1] [1],dp[i−1] [0]−prices[i]}</p></li></ol><blockquote><p>提示</p></blockquote><p>对于初始状态，根据状态定义我们可以知道第 0 天交易结束的时候 dp[0] [0]=0，dp[0] [1]=−prices[0]。</p><p>因此，我们只要从前往后依次计算状态即可。由于全部交易结束后，持有股票的收益一定低于不持有股票的收益，因此这时候 dp[n−1] [0] 的收益必然是大于 dp[n−1] [1] 的，最后的答案即为 dp[n−1] [0]。</p><h3 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>]+prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>],dp[i-<span class="number">1</span>][<span class="number">0</span>]-prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到上面的状态转移方程中，每一天的状态只与前一天的状态有关，而与更早的状态都无关，因此我们不必存储这些无关的状态，只需要将 dp[i−1] [0] 和 dp[i−1] [1] 存放在两个变量中，通过它们计算出 dp[i] [0] 和 dp[i] [1] 并存回对应的变量，以便于第 i+1 天的状态转移即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span> dp0 = <span class="number">0</span>, dp1 = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> newDp0 = Math.max(dp0, dp1 + prices[i]);</span><br><span class="line">            <span class="keyword">int</span> newDp1 = Math.max(dp1, dp0 - prices[i]);</span><br><span class="line">            dp0 = newDp0;</span><br><span class="line">            dp1 = newDp1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(n) ： 其中 n 为数组的长度。一共有 2n 个状态，每次状态转移的时间复杂度为 O(1)，因此时间复杂度为 O(2n)=O(n)。</li><li>空间复杂度 O(1) ： 我们需要开辟 O(n)空间存储动态规划中的所有状态。如果使用空间优化，空间复杂度可以优化至 O(1)。</li></ul><h3 id="其他优秀解答"><a class="markdownIt-Anchor" href="#其他优秀解答"></a> 其他优秀解答</h3><blockquote><p>解题思路</p></blockquote><p><strong>贪心算法的直觉</strong>：由于不限制交易次数，只要今天股价比昨天高，就交易。</p><blockquote><p>代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = prices.length;</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> diff = prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (diff &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                res += diff;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>时间复杂度O(n)：这里 <em>N</em> 表示股价数组的长度；</p></li><li><p>空间复杂度O(1)：只使用了常数个变量。</p></li></ul><h2 id="买卖股票的最佳时机-iii"><a class="markdownIt-Anchor" href="#买卖股票的最佳时机-iii"></a> 买卖股票的最佳时机 III</h2><h3 id="题目信息-3"><a class="markdownIt-Anchor" href="#题目信息-3"></a> 题目信息</h3><ul><li><p>题目描述：</p><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。</p></li></ul><p><strong>示例1:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [3,3,5,0,0,3,1,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。</span><br><span class="line">     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。</span><br></pre></td></tr></table></figure><p><strong>示例2:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [1,2,3,4,5]</span><br><span class="line">输出：4</span><br><span class="line">解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   </span><br><span class="line">     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   </span><br><span class="line">     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br></pre></td></tr></table></figure><p><strong>示例3</strong>:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [7,6,4,3,1] </span><br><span class="line">输出：0 </span><br><span class="line">解释：在这个情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><blockquote><p>注意</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</span><br></pre></td></tr></table></figure><h3 id="解题思路-3"><a class="markdownIt-Anchor" href="#解题思路-3"></a> 解题思路</h3><blockquote><p>本题难点</p></blockquote><p>限制了交易的次数，最多两次，同时要求收益最高</p><blockquote><p>具体思路</p></blockquote><p>由于我们最多可以完成两笔交易，因此在任意一天结束之后，我们会处于以下五个状态中的一种：</p><ul><li>未进行过任何操作；</li><li>只进行过一次买操作；</li><li>进行了一次买操作和一次卖操作，即完成了一笔交易；</li><li>在完成了一笔交易的前提下，进行了第二次买操作；</li><li>完成了全部两笔交易。</li></ul><p>由于第一个状态的利润显然为 0，因此我们可以不用将其记录。对于剩下的四个状态，我们分别将它们的最大利润记为 buy1，sell1 ，buy2以及 sell2。</p><p>这里我们用 buy1′表示第 i−1 天的状态，以便于和第 i 天的状态 buy1进行区分。</p><p>对于 buy1而言，在第 i 天我们可以不进行任何操作，保持不变，也可以在未进行任何操作的前提下以 prices[i] 的价格买入股票，那么 buy1的状态转移方程即为：</p><p>buy1=max{buy1‘ ,−prices[i]}</p><p>对于 sell1而言，在第 i 天我们可以不进行任何操作，保持不变，也可以在只进行过一次买操作的前提下以<br />prices[i] 的价格卖出股票，那么 sell1的状态转移方程即为：</p><p>sell1=max{sell1’ ,buy1‘ +prices[i]}</p><p>同理我们可以得到 buy2和 sell2对应的状态转移方程：</p><p>buy2=max{buy2′,sell1′−prices[i]}<br />sell2=max{sell 2‘,buy2′+prices[i]}</p><p>无论题目中是否允许「在同一天买入并且卖出」这一操作，最终的答案都不会受到影响，这是因为这一操作带来的收益为零。例如在计算 sell1时，我们直接使用 buy1而不是 buy1′进行转移。buy1比buy1′多考虑的是在第 i 天买入股票的情况，而转移到 sell1 时，考虑的是在第 i 天卖出股票的情况，这样在同一天买入并且卖出收益为零，不会对答案产生影响。</p><p>因此，状态转移方程直接可写为</p><p>buy1=max{buy1,−prices[i]}</p><p>sell1=max{sell1,buy1 +prices[i]}</p><p>buy2=max{buy2,sell1−prices[i]}<br />sell2=max{sell2,buy2+prices[i]}</p><blockquote><p>提示</p></blockquote><p>对于边界条件，我们考虑第 i=0 天时的四个状态：<br />buy 1 即为以 prices[0] 的价格买入股票，因此 buy1=−prices[0]；</p><p>sell1即为在同一天买入并且卖出，因此 sell1=0；</p><p>buy2即为在同一天买入并且卖出后再以 prices[0] 的价格买入股票，因此 buy2 =−prices[0]；</p><p>同理可得 sell2=0。</p><p>我们将这四个状态作为边界条件，从 i=1 开始进行动态规划，即可得到答案。</p><h3 id="代码-3"><a class="markdownIt-Anchor" href="#代码-3"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span> buy1 = -prices[<span class="number">0</span>], sell1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> buy2 = -prices[<span class="number">0</span>], sell2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            buy1 = Math.max(buy1, -prices[i]);</span><br><span class="line">            sell1 = Math.max(sell1, buy1 + prices[i]);</span><br><span class="line">            buy2 = Math.max(buy2, sell1 - prices[i]);</span><br><span class="line">            sell2 = Math.max(sell2, buy2 + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sell2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(n) ： 其中 n 是数组 prices 的长度。</li><li>空间复杂度 O(1) ： 只使用了常数个变量。</li></ul><h3 id="其他解答-2"><a class="markdownIt-Anchor" href="#其他解答-2"></a> 其他解答</h3><blockquote><p>解题思路</p></blockquote><p>借鉴买卖股票的最佳时间I的思路，计算 0 到 i 天交易一次的最大收益与 i 到 length 天交易一次的最大收益和。</p><blockquote><p>代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            max = Math.max(max, func(prices, <span class="number">0</span>, i) + func(prices, i, prices.length));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min = prices[start];</span><br><span class="line">        <span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">            profit = Math.max(prices[i] - min, profit);</span><br><span class="line">            min = Math.min(min, prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="买卖股票的最佳时机-iv"><a class="markdownIt-Anchor" href="#买卖股票的最佳时机-iv"></a> 买卖股票的最佳时机 IV</h2><h3 id="题目信息-4"><a class="markdownIt-Anchor" href="#题目信息-4"></a> 题目信息</h3><ul><li><p>题目描述：</p><p>给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。</p></li></ul><p><strong>示例1:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：k = 2, prices = [2,4,1]</span><br><span class="line">输出：2</span><br><span class="line">解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。</span><br></pre></td></tr></table></figure><p><strong>示例2:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：k = 2, prices = [3,2,6,5,0,3]</span><br><span class="line">输出：7</span><br><span class="line">解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。</span><br><span class="line">     随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 =</span><br></pre></td></tr></table></figure><blockquote><p>注意</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</span><br></pre></td></tr></table></figure><h3 id="解题思路-4"><a class="markdownIt-Anchor" href="#解题思路-4"></a> 解题思路</h3><blockquote><p>本题难点</p></blockquote><p>股票交易的笔数不确定</p><blockquote><p>具体思路</p></blockquote><p>与其余的股票问题类似，我们使用一系列变量存储「买入」的状态，再用一系列变量存储「卖出」的状态，通过动态规划的方法即可解决本题。</p><p>我们用 buy[i] [j] 表示对于数组 prices[0…i] 中的价格而言，进行恰好 j 笔交易，并且当前手上持有一支股票，这种情况下的最大利润；用 sell[i] [j] 表示恰好进行 j 笔交易，并且当前手上不持有股票，这种情况下的最大利润。</p><p>那么我们可以对状态转移方程进行推导。对于 buy[i] [j]，我们考虑当前手上持有的股票是否是在第 i 天买入的。如果是第 i 天买入的，那么在第 i−1 天时，我们手上不持有股票，对应状态 sell[i−1] [j]，并且需要扣除 prices[i] 的买入花费；如果不是第 i 天买入的，那么在第 i−1 天时，我们手上持有股票，对应状态 buy[i] [j]。那么我们可以得到状态转移方程：</p><p><em>buy</em>[<em>i</em>] [<em>j</em>]=max{<em>buy</em>[<em>i</em>−1] [<em>j</em>],<em>sell</em>[<em>i</em>−1] [<em>j</em>]−<em>price</em>[<em>i</em>]}</p><p>同理对于 sell[i] [j]，如果是第 i 天卖出的，那么在第 i−1 天时，我们手上持有股票，对应状态 buy[i−1] [j−1]，并且需要增加 prices[i] 的卖出收益；如果不是第 i 天卖出的，那么在第 i−1 天时，我们手上不持有股票，对应状态 sell[i−1] [j]。那么我们可以得到状态转移方程：</p><p><em>sell</em>[<em>i</em>] [<em>j</em>]=max{<em>sell</em>[<em>i</em>−1] [<em>j</em>],<em>buy</em>[<em>i</em>−1] [<em>j</em>−1]+<em>price</em>[<em>i</em>]}</p><p>由于在所有的 n 天结束后，手上不持有股票对应的最大利润一定是严格由于手上持有股票对应的最大利润的，然而完成的交易数并不是越多越好（例如数组 prices 单调递减，我们不进行任何交易才是最优的），因此最终的答案即为 sell[n−1] [0…k] 中的最大值。</p><blockquote><p>提示</p></blockquote><p>对于 buy[0] [0…k]，由于只有 prices[0] 唯一的股价，因此我们不可能进行过任何交易，那么我们可以将所有的 buy[0] [1…k] 设置为一个非常小的值，表示不合法的状态。而对于 buy[0] [0]，它的值为 −prices[0]，即「我们在第 0 天以 prices[0] 的价格买入股票」是唯一满足手上持有股票的方法。</p><p>在设置完边界之后，我们就可以使用二重循环，在 i∈[1,n),j∈[0,k] 的范围内进行状态转移。需要注意的是，sell[i] [j] 的状态转移方程中包含 buy[i−1] [j−1]，在 j=0 时其表示不合法的状态，因此在 j=0 时，我们无需对 sell[i] [j] 进行转移，让其保持值为 0 即可。</p><p>本题中 k 的最大值可以达到 10 ^9 ，然而这是毫无意义的，因为 n 天最多只能进行 ⌊n/2⌋ 笔交易，其中 ⌊x⌋ 表示对 x 向下取整。因此我们可以将 k 对 ⌊n/2⌋ 取较小值之后再进行动态规划</p><h3 id="代码-4"><a class="markdownIt-Anchor" href="#代码-4"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        k = Math.min(k, n / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">int</span>[] buy = <span class="keyword">new</span> <span class="keyword">int</span>[k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span>[] sell = <span class="keyword">new</span> <span class="keyword">int</span>[k + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        buy[<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        sell[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">            buy[i] = sell[i] = Integer.MIN_VALUE / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            buy[<span class="number">0</span>] = Math.max(buy[<span class="number">0</span>], sell[<span class="number">0</span>] - prices[i]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; ++j) &#123;</span><br><span class="line">                buy[j] = Math.max(buy[j], sell[j] - prices[i]);</span><br><span class="line">                sell[j] = Math.max(sell[j], buy[j - <span class="number">1</span>] + prices[i]);   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(sell).max().getAsInt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(nmin(n,k)) ： 其中 n是数组 prices 的大小，即我们使用二重循环进行动态规划需要的时间。</li><li>空间复杂度 O(min(<em>n</em>,<em>k</em>)) ：  一维数组进行动态规划。</li></ul><h3 id="其他优秀解答-2"><a class="markdownIt-Anchor" href="#其他优秀解答-2"></a> 其他优秀解答</h3><blockquote><p>解题思路</p></blockquote><p>常规的动态规划</p><ol><li>这里的k居然给这么大，其实超出了天数的一半就没有用，因为不会产生这么多交易；</li><li>首先是状态表示，利用一个三维数组，数组值表示当前还有多少钱，三个维度分别代表：第几天，手上是否有股票0没有1有，还剩下多少次买卖的机会；</li><li>然后是状态转移，分为当前持有股票和不持有股票两种状态来转移分析。</li><li>这里以卖出股票来作为完成一次交易的触发条件。</li></ol><blockquote><p>代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果k超过了最大可买卖次数，那就将k置为最大买卖次数</span></span><br><span class="line">        <span class="comment">// 最大买卖次数就是天数的一半，如果当前卖出又买入，是没有意义的</span></span><br><span class="line">        k = Math.min(k, n / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 状态表示数组，三个维度分别代表：第几天，手上是否有股票0没有1有，还剩下多少次买卖机会</span></span><br><span class="line">        <span class="comment">// 数组值表示当前还有多少钱</span></span><br><span class="line">        <span class="keyword">int</span>[][][] f = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">2</span>][k + <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置初始值，第一天手上有股票的状态，就是买入第一天价格的值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; i++) &#123;</span><br><span class="line">            f[<span class="number">0</span>][<span class="number">1</span>][i] = -prices[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 状态转移，遍历天数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 枚举当天所有可能买卖次数的状态</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= k; j++) &#123;</span><br><span class="line">                <span class="comment">// 当前不持有股票的状态转移</span></span><br><span class="line">                <span class="keyword">if</span>(j &lt; k) &#123;</span><br><span class="line">                    <span class="comment">// 当前不持有股票，要么前一天也没有股票，要么前一天有股票但是今天卖出了</span></span><br><span class="line">                    <span class="comment">// 如果今天卖出的话，买卖次数就会比前一天少一次，当天是j，那么前一天就是j+1</span></span><br><span class="line">                    f[i][<span class="number">0</span>][j] = Math.max(f[i - <span class="number">1</span>][<span class="number">0</span>][j], f[i - <span class="number">1</span>][<span class="number">1</span>][j + <span class="number">1</span>] + prices[i]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 剩余买卖次数j等于初始值剩余交易次数k的时候，</span></span><br><span class="line">                    <span class="comment">// 那么说明从来没有产生过交易，所以需要从前一天的不持有状态转移过来</span></span><br><span class="line">                    f[i][<span class="number">0</span>][j] = f[i - <span class="number">1</span>][<span class="number">0</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 当前持有股票的状态转移，要么前一天也有股票，要么前一天不持有股票但是当天买入了股票</span></span><br><span class="line">                f[i][<span class="number">1</span>][j] = Math.max(f[i - <span class="number">1</span>][<span class="number">1</span>][j], f[i - <span class="number">1</span>][<span class="number">0</span>][j] - prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 获取最大值，最大值肯定出现在当前手上不持有股票的状态</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; i ++) &#123;</span><br><span class="line">            res = Math.max(res, f[n - <span class="number">1</span>][<span class="number">0</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="买卖股票的最佳时机含手续费"><a class="markdownIt-Anchor" href="#买卖股票的最佳时机含手续费"></a> 买卖股票的最佳时机含手续费</h2><h3 id="题目信息-5"><a class="markdownIt-Anchor" href="#题目信息-5"></a> 题目信息</h3><ul><li><p>题目描述：</p><p>给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。</p><p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p><p>返回获得利润的最大值。</p></li></ul><p><strong>示例1:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: prices = [1, 3, 2, 8, 4, 9], fee = 2</span><br><span class="line">输出: 8</span><br><span class="line">解释: 能够达到的最大利润:  </span><br><span class="line">在此处买入 prices[0] = 1</span><br><span class="line">在此处卖出 prices[3] = 8</span><br><span class="line">在此处买入 prices[4] = 4</span><br><span class="line">在此处卖出 prices[5] = 9</span><br><span class="line">总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8.</span><br></pre></td></tr></table></figure><blockquote><p>注意</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. 这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</span><br></pre></td></tr></table></figure><h3 id="解题思路-5"><a class="markdownIt-Anchor" href="#解题思路-5"></a> 解题思路</h3><blockquote><p>本题难点</p></blockquote><p>多加了手续费，交易需要扣除手续费，交易的次数越多手续费越多</p><blockquote><p>具体思路</p></blockquote><p>思路类似买卖股票的最佳时机II</p><ol><li><p>定义状态<br />dp[i] [0]表示第 i 天交易完后手里没有股票的最大利润，dp[i] [1] 表示第 i 天交易完后手里持有一支股票的最大利润（i 从 0 开始）。</p></li><li><p>考虑 dp[i] [0] 的转移方程，如果这一天交易完后手里没有股票，那么可能的转移状态为前一天已经没有股票，即 dp[i−1] [0]，或者前一天结束的时候手里持有一支股票，即 dp[i−1] [1]，这时候我们要将其卖出，并获得 prices[i] 的收益,但需要支付 fee 的手续费。因此为了收益最大化，我们列出如下的转移方程：</p><p>dp[i] [0]=max{dp[i−1] [0],dp[i−1] [1]+prices[i]-fee}</p></li><li><p>再来考虑 dp[i] [1]，按照同样的方式考虑转移状态，那么可能的转移状态为前一天已经持有一支股票，即<br />dp[i−1] [1]，或者前一天结束时还没有股票，即 dp[i−1] [0]，这时候我们要将其买入，并减少<br />prices[i] 的收益。可以列出如下的转移方程：</p><p>dp[i] [1]=max{dp[i−1] [1],dp[i−1] [0]−prices[i]}</p></li></ol><blockquote><p>提示</p></blockquote><p>对于初始状态，根据状态定义我们可以知道第 0 天交易结束的时候 dp[0] [0]=0，dp[0] [1]=−prices[0]。</p><p>因此，我们只要从前往后依次计算状态即可。由于全部交易结束后，持有股票的收益一定低于不持有股票的收益，因此这时候 dp[n−1] [0] 的收益必然是大于 dp[n−1] [1] 的，最后的答案即为 dp[n−1] [0]。</p><h3 id="代码-5"><a class="markdownIt-Anchor" href="#代码-5"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i] - fee);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到上面的状态转移方程中，每一天的状态只与前一天的状态有关，而与更早的状态都无关，因此我们不必存储这些无关的状态，只需要将 dp[i−1] [0] 和 dp[i−1] [1] 存放在两个变量中，通过它们计算出 dp[i] [0] 和 dp[i] [1] 并存回对应的变量，以便于第 i+1 天的状态转移即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span> sell = <span class="number">0</span>, buy = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            sell = Math.max(sell, buy + prices[i] - fee);</span><br><span class="line">            buy = Math.max(buy, sell - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sell;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(n) ： 其中 n 为数组的长度。一共有 2n 个状态，每次状态转移的时间复杂度为O(1)，因此时间复杂度为 O(2n)=O(n)</li><li>空间复杂度 O(1) ： 我们需要开辟 O(n)空间存储动态规划中的所有状态。如果使用空间优化，空间复杂度可以优化至 O(1)。</li></ul><h3 id="其他优秀解答-3"><a class="markdownIt-Anchor" href="#其他优秀解答-3"></a> 其他优秀解答</h3><blockquote><p>解题思路</p></blockquote><p>贪心算法，换一个角度考虑，将手续费放在买入时进行计算，那么就可以得到一种基于贪心的方法。</p><p>我们用 buy 表示在最大化收益的前提下，如果我们手上拥有一支股票，那么它的最低买入价格是多少。</p><blockquote><p>代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span> buy = prices[<span class="number">0</span>] + fee;</span><br><span class="line">        <span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i] + fee &lt; buy) &#123;</span><br><span class="line">                buy = prices[i] + fee;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prices[i] &gt; buy) &#123;</span><br><span class="line">                profit += prices[i] - buy;</span><br><span class="line">                buy = prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最佳买卖股票时机含冷冻期"><a class="markdownIt-Anchor" href="#最佳买卖股票时机含冷冻期"></a> 最佳买卖股票时机含冷冻期</h2><h3 id="题目信息-6"><a class="markdownIt-Anchor" href="#题目信息-6"></a> 题目信息</h3><ul><li><p>题目描述：</p><p>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。</p><p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p></li></ul><p><strong>示例1:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,0,2]</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</span><br></pre></td></tr></table></figure><blockquote><p>注意</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</span><br><span class="line">2. 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</span><br></pre></td></tr></table></figure><h3 id="解题思路-6"><a class="markdownIt-Anchor" href="#解题思路-6"></a> 解题思路</h3><blockquote><p>本题难点</p></blockquote><p>卖出后有冷冻期，不可以频繁的交易，要看准时机，才能获益最大</p><blockquote><p>具体思路</p></blockquote><p>一种常用的方法是将「买入」和「卖出」分开进行考虑：「买入」为负收益，而「卖出」为正收益。在初入股市时，你只有「买入」的权利，只能获得负收益。而当你「买入」之后，你就有了「卖出」的权利，可以获得正收益。显然，我们需要尽可能地降低负收益而提高正收益，因此我们的目标总是将收益值最大化。因此，我们可以使用动态规划的方法，维护在股市中每一天结束后可以获得的「累计最大收益」，并以此进行状态转移，得到最终的答案。</p><p>我们用 f[i] 表示第 i 天结束之后的「累计最大收益」。根据题目描述，由于我们最多只能同时买入（持有）一支股票，并且卖出股票后有冷冻期的限制，因此我们会有三种不同的状态：</p><ul><li>我们目前持有一支股票，对应的「累计最大收益」记为 f[i] [0]；</li><li>我们目前不持有任何股票，并且处于冷冻期中，对应的「累计最大收益」记为 f[i] [1]；</li><li>我们目前不持有任何股票，并且不处于冷冻期中，对应的「累计最大收益」记为 f[i] [2]。</li></ul><p>这里的「处于冷冻期」指的是在第 i<em>i</em> 天结束之后的状态。也就是说：如果第 i<em>i</em> 天结束之后处于冷冻期，那么第 i+1 天无法买入股票。</p><p>在第 i 天时，我们可以在不违反规则的前提下进行「买入」或者「卖出」操作，此时第 i 天的状态会从第 i−1 天的状态转移而来；我们也可以不进行任何操作，此时第 i 天的状态就等同于第 i−1 天的状态。那么我们分别对这三种状态进行分析：</p><ul><li><p>对于 f[i] [0]，我们目前持有的这一支股票可以是在第 i−1 天就已经持有的，对应的状态为 f[i−1] [0]；或者是第 i 天买入的，那么第 i−1 天就不能持有股票并且不处于冷冻期中，对应的状态为 f[i−1] [2] 加上买入股票的负收益 prices[i]。因此状态转移方程为：</p><p>f[i] [0]=max(f[i−1] [0],f[i−1] [2]−prices[i])</p></li><li><p>对于 f[i] [1]，我们在第 i 天结束之后处于冷冻期的原因是在当天卖出了股票，那么说明在第 i−1 天时我们必须持有一支股票，对应的状态为 f[i−1] [0] 加上卖出股票的正收益 prices[i]。因此状态转移方程为：</p><p>f[i] [1]=f[i−1] [0]+prices[i]</p></li><li><p>对于 f[i] [2]，我们在第 i 天结束之后不持有任何股票并且不处于冷冻期，说明当天没有进行任何操作，即第 i−1 天时不持有任何股票：如果处于冷冻期，对应的状态为 f[i−1] [1]；如果不处于冷冻期，对应的状态为 f[i−1] [2]。因此状态转移方程为：</p><p>f[i] [2]=max(f[i−1] [1],f[i−1] [2])</p></li></ul><p>这样我们就得到了所有的状态转移方程。如果一共有 n<em>n</em> 天，那么最终的答案即为：</p><p>max(f[n−1] [0],f[n−1] [1],f[n−1] [2])</p><p>注意到如果在最后一天（第 n−1 天）结束之后，手上仍然持有股票，那么显然是没有任何意义的。因此更加精确地，最终的答案实际上是 f[n−1] [1] 和 f[n−1] [2] 中的较大值，即：</p><p>max(<em>f</em>[<em>n</em>−1] [1],<em>f</em>[<em>n</em>−1] [2])</p><blockquote><p>提示</p></blockquote><p>在第 0 天时，如果持有股票，那么只能是在第 0 天买入的，对应负收益 −prices[0]；如果不持有股票，那么收益为零。注意到第 0 天实际上是不存在处于冷冻期的情况的，但我们仍然可以将对应的状态 f[0] [1] 置为零。</p><p>这样我们就可以从第 1 天开始，根据上面的状态转移方程进行进行动态规划，直到计算出第 n−1 天的结果。</p><h3 id="代码-6"><a class="markdownIt-Anchor" href="#代码-6"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="comment">// f[i][0]: 手上持有股票的最大收益</span></span><br><span class="line">        <span class="comment">// f[i][1]: 手上不持有股票，并且处于冷冻期中的累计最大收益</span></span><br><span class="line">        <span class="comment">// f[i][2]: 手上不持有股票，并且不在冷冻期中的累计最大收益</span></span><br><span class="line">        <span class="keyword">int</span>[][] f = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">3</span>];</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            f[i][<span class="number">0</span>] = Math.max(f[i - <span class="number">1</span>][<span class="number">0</span>], f[i - <span class="number">1</span>][<span class="number">2</span>] - prices[i]);</span><br><span class="line">            f[i][<span class="number">1</span>] = f[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i];</span><br><span class="line">            f[i][<span class="number">2</span>] = Math.max(f[i - <span class="number">1</span>][<span class="number">1</span>], f[i - <span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(f[n - <span class="number">1</span>][<span class="number">1</span>], f[n - <span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到上面的状态转移方程中，<br />f[i] […] 只与 f[i−1] […] 有关，而与 f[i−2] […] 及之前的所有状态都无关，因此我们不必存储这些无关的状态。也就是说，我们只需要将 f[i−1] [0]，f[i−1] [1]，f[i−1] [2] 存放在三个变量中，通过它们计算出 f[i] [0]，f[i] [1]，f[i] [2] 并存回对应的变量，以便于第 i+1 天的状态转移即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span> f0 = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> f1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> f2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> newf0 = Math.max(f0, f2 - prices[i]);</span><br><span class="line">            <span class="keyword">int</span> newf1 = f0 + prices[i];</span><br><span class="line">            <span class="keyword">int</span> newf2 = Math.max(f1, f2);</span><br><span class="line">            f0 = newf0;</span><br><span class="line">            f1 = newf1;</span><br><span class="line">            f2 = newf2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.max(f1, f2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(n) ： 其中 n 为数组 prices 的长度。</li><li>空间复杂度 O(1) ：  我们需要 3n 的空间存储动态规划中的所有状态，对应的空间复杂度为 O(n)。如果使用空间优化，空间复杂度可以优化至 O(1)。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;每日一题-股票问题&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#每日一题-股票问题&quot;&gt;&lt;/a&gt; 每日一题 - 股票问题&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;时间： 2021-01-10&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;题目链接：&lt;
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://wangqiang.cool/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="动态规划" scheme="http://wangqiang.cool/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="贪心算法" scheme="http://wangqiang.cool/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>每日一题 - 实现LRU算法</title>
    <link href="http://wangqiang.cool/2021/01/09/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E5%AE%9E%E7%8E%B0LRU%E7%AE%97%E6%B3%95/"/>
    <id>http://wangqiang.cool/2021/01/09/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E5%AE%9E%E7%8E%B0LRU%E7%AE%97%E6%B3%95/</id>
    <published>2021-01-09T15:54:30.000Z</published>
    <updated>2021-01-09T15:55:50.238Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目信息"><a class="markdownIt-Anchor" href="#题目信息"></a> 题目信息</h3><ul><li><p>tag：链表 哈希表</p></li><li><p>难易程度：中等</p></li><li><p>题目描述：</p><p>设计LRU缓存结构，该结构在构造时确定大小，假设大小为K，并有如下两个功能</p><ul><li>set(key, value)：将记录(key, value)插入该结构</li><li>get(key)：返回key对应的value值</li></ul><p>若opt=1，接下来两个整数x, y，表示set(x, y)<br />若opt=2，接下来一个整数x，表示get(x)，若x未出现过或已被移除，则返回-1<br />对于每个操作2，输出一个答案</p></li></ul><p><strong>示例1:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[[1,1,1],[1,2,2],[1,3,2],[2,1],[1,4,4],[2,2]],3</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[1,-1]</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line">第一次操作后：最常使用的记录为("1", 1)</span><br><span class="line">第二次操作后：最常使用的记录为("2", 2)，("1", 1)变为最不常用的</span><br><span class="line">第三次操作后：最常使用的记录为("3", 2)，("1", 1)还是最不常用的</span><br><span class="line">第四次操作后：最常用的记录为("1", 1)，("2", 2)变为最不常用的</span><br><span class="line">第五次操作后：大小超过了3，所以移除此时最不常使用的记录("2", 2)，加入记录("4", 4)，并且为最常使用的记录，然后("3", 2)变为最不常使用的记录</span><br></pre></td></tr></table></figure><blockquote><p>注意</p></blockquote><ul><li><p>1 &lt;= k &lt;= N &lt;= 10^5</p></li><li><p>-2 * 10^9  &lt;= x , y &lt;= 2 * 10^9</p></li></ul><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><blockquote><p>本题难点</p></blockquote><p>java 中 LinkedHashMap可以很方便的实现LRU算法，不过一般要求手写，需要用双向链表和Map实现LRU算法</p><blockquote><p>具体思路</p></blockquote><p>LRU的每次操作(get,put)都会将节点放入链表首部。需要自定义双向链表。</p><p>双向链表需要提供<code>addToHead</code>,<code>moveToHead</code>,<code>removeNode</code>的接口。这些接口只需要熟悉双向链的删除与头插法就能写出来。</p><p>链表插入删除过程的简化—虚拟节点，<code>Head</code>,<code>Tail</code>。<strong>且初始化时要让Tail.prev保存最开的头结点，即Head.next.</strong></p><p>双向链表的头插法要明确，是将<code>node</code>插入到<code>Head</code>与真正的头结点之间。而真正的头结点是<code>Head</code>.插入完成后，<code>node</code>则变为真正的头结点。</p><p>put操作有则更新，无则创建，超过长度时，需要同时删除链表和map中的数据。—都需要将带插入元素放入链表头部！</p><blockquote><p>提示</p></blockquote><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * lru design</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> operators int整型二维数组 the ops</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k int整型 the k</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer,Node&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Node head = <span class="keyword">new</span> Node(-<span class="number">1</span>,-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> Node tail = <span class="keyword">new</span> Node(-<span class="number">1</span>,-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> k ;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] LRU (<span class="keyword">int</span>[][] operators, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">this</span>.k = k;</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">        <span class="keyword">int</span> len = (<span class="keyword">int</span>)Arrays.stream(operators).filter(x -&gt; x[<span class="number">0</span>] == <span class="number">2</span>).count();</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; operators.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(operators[i][<span class="number">0</span>] == <span class="number">1</span>)&#123;</span><br><span class="line">                set(operators[i][<span class="number">1</span>],operators[i][<span class="number">2</span>]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res[j++] = get(operators[i][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> key,value;</span><br><span class="line">        Node prev,next;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> key,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addToHead</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        node.next = head.next;</span><br><span class="line">        node.prev = head;</span><br><span class="line">        head.next.prev = node;</span><br><span class="line">        head.next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeNode</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        node.prev.next = node.next;</span><br><span class="line">        node.next.prev = node.prev;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveToHead</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        addToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(key))&#123;</span><br><span class="line">            Node node = map.get(key);</span><br><span class="line">            moveToHead(node);</span><br><span class="line">            <span class="keyword">return</span> node.value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> key,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(key))&#123;</span><br><span class="line">            Node node = map.get(key);</span><br><span class="line">            node.value = value;</span><br><span class="line">            moveToHead(node);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.size() == k)&#123;</span><br><span class="line">                <span class="keyword">int</span> rk = tail.prev.key;</span><br><span class="line">                removeNode(tail.prev);</span><br><span class="line">                map.remove(rk);</span><br><span class="line">            &#125;</span><br><span class="line">            Node node  = <span class="keyword">new</span> Node(key,value);</span><br><span class="line">            map.put(key,node);</span><br><span class="line">            addToHead(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(1) ： 哈希表查询的时间复杂度</li><li>空间复杂度 O(n) ：n为构造结构时的大小</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目信息&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#题目信息&quot;&gt;&lt;/a&gt; 题目信息&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;tag：链表 哈希表&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;难易程度：中等&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;题
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://wangqiang.cool/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="链表" scheme="http://wangqiang.cool/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="哈希表" scheme="http://wangqiang.cool/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>在浏览器输入URL回车之后发生了什么</title>
    <link href="http://wangqiang.cool/2020/12/06/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL%E5%9B%9E%E8%BD%A6%E4%B9%8B%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/"/>
    <id>http://wangqiang.cool/2020/12/06/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL%E5%9B%9E%E8%BD%A6%E4%B9%8B%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/</id>
    <published>2020-12-06T06:52:36.000Z</published>
    <updated>2020-12-06T07:38:30.648Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>这个问题已经是老生常谈了，更是经常被作为面试的压轴题出现，网上也有很多文章，但最近闲的无聊，然后就自己做了一篇笔记，感觉比之前理解更透彻了。</p><p>这篇笔记是我这两天看了数十篇文章总结出来的，所以相对全面一点，但由于我是做前端的，所以会比较重点分析浏览器渲染页面那一部分，至于其他部分我会罗列出关键词，感兴趣的可以自行查阅，</p><blockquote><p>本文转自<a href="https://4ark.me/post/b6c7c0a2.html" target="_blank" rel="noopener">4ark</a></p></blockquote><p>**注意：**本文的步骤是建立在，请求的是一个简单的 HTTP 请求，没有 HTTPS、HTTP2、最简单的 DNS、没有代理、并且服务器没有任何问题的基础上，尽管这是不切实际的。</p><h2 id="大致流程"><a class="markdownIt-Anchor" href="#大致流程"></a> 大致流程</h2><ol><li>URL 解析</li><li>DNS 查询</li><li>TCP 连接</li><li>处理请求</li><li>接受响应</li><li>渲染页面</li></ol><h3 id="url-解析"><a class="markdownIt-Anchor" href="#url-解析"></a> URL 解析</h3><p><strong>地址解析：</strong></p><p>首先判断你输入的是一个合法的 URL 还是一个待搜索的关键词，并且根据你输入的内容进行自动完成、字符编码等操作。</p><p><strong>HSTS</strong></p><p>由于安全隐患，会使用 HSTS 强制客户端使用 HTTPS 访问页面。详见：<a href="https://www.barretlee.com/blog/2015/10/22/hsts-intro/" target="_blank" rel="noopener">你所不知道的 HSTS</a></p><p><strong>其他操作</strong></p><p>浏览器还会进行一些额外的操作，比如安全检查、访问限制（之前国产浏览器限制 996.icu）。</p><p><strong>检查缓存</strong></p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/img/WhathappenswhenyoutypeanURLinthebrowserandpressenter.png" alt="WhathappenswhenyoutypeanURLinthebrowserandpressenter" /></p><h3 id="dns-查询"><a class="markdownIt-Anchor" href="#dns-查询"></a> DNS 查询</h3><p><strong>基本步骤</strong></p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/img/asdappenswasdyoutssenterbaiscprocess0715.png" alt="asdappenswasdyoutssenterbaiscprocess0715" /></p><p><strong>浏览器缓存</strong></p><p>浏览器会先检查是否在缓存中，没有则调用系统库函数进行查询。</p><p><strong>操作系统缓存</strong></p><p>操作系统也有自己的 DNS 缓存，但在这之前，会向检查域名是否存在本地的 Hosts 文件里，没有则向 DNS 服务器发送查询请求。</p><p><strong>路由器缓存</strong></p><p>路由器也有自己的缓存。</p><p><strong>ISP DNS 缓存</strong></p><p>ISP DNS 就是在客户端电脑上设置的首选 DNS 服务器，它们在大多数情况下都会有缓存。</p><p><strong>根域名服务器查询</strong></p><p>在前面所有步骤没有缓存的情况下，本地 DNS 服务器会将请求转发到互联网上的根域，下面这个图很好的诠释了整个流程：</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/img/WhathappensURLinthebrowserandpressenterdns.png" alt="WhathappensURLinthebrowserandpressenterdns" /></p><blockquote><p>根域名服务器：<a href="">维基百科</a></p></blockquote><p>需要注意的点</p><ol><li>递归方式：一路查下去中间不返回，得到最终结果才返回信息（浏览器到本地 DNS 服务器的过程）</li><li>迭代方式，就是本地 DNS 服务器到根域名服务器查询的方式。</li><li>什么是 DNS 劫持</li><li>前端 dns-prefetch 优化</li></ol><h3 id="tcp-连接"><a class="markdownIt-Anchor" href="#tcp-连接"></a> TCP 连接</h3><p>TCP/IP 分为四层，在发送数据时，每层都要对数据进行封装：</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/img/whentha0717ebrowserandpressentertcp.png" alt="whentha0717ebrowserandpressentertcp" /></p><ol><li>应用层：发送 HTTP 请求</li></ol><p>在前面的步骤我们已经得到服务器的 IP 地址，浏览器会开始构造一个 HTTP 报文，其中包括：</p><p>请求报头（Request Header）：请求方法、目标地址、遵循的协议等等<br />请求主体（其他参数）<br />其中需要注意的点：</p><p>浏览器只能发送 GET、POST 方法，而打开网页使用的是 GET 方法</p><ol start="2"><li>传输层：TCP 传输报文</li></ol><p>传输层会发起一条到达服务器的 TCP 连接，为了方便传输，会对数据进行分割（以报文段为单位），并标记编号，方便服务器接受时能够準确地还原报文信息。</p><p>在建立连接前，会先进行 TCP 三次握手。</p><blockquote><p>关于 TCP/IP 三次握手，网上已经有很多段子和图片生动地描述了。</p><p>相关知识：SYN 泛洪攻击</p></blockquote><ol start="3"><li>网络层：IP 协议查询 Mac 地址</li></ol><p>将数据段打包，并加入源及目标的 IP 地址，并且负责寻找传输路线。</p><p>判断目标地址是否与当前地址处于同一网络中，是的话直接根据 Mac 地址发送，否则使用路由表查找下一跳地址，以及使用 ARP 协议查询它的 Mac 地址。</p><blockquote><p>注意：在 OSI 参考模型中 ARP 协议位于链路层，但在 TCP/IP 中，它位于网络层。</p></blockquote><ol start="4"><li>链路层：以太网协议</li></ol><p><strong>以太网协议</strong></p><p>根据以太网协议将数据分为以 “帧” 为单位的数据包，每一帧分为两个部分：</p><p>标头：数据包的发送者、接受者、数据类型<br />数据：数据包具体内容<br /><strong>Mac 地址</strong></p><p>以太网规定了连入网络的所有设备都必须具备 “网卡” 接口，数据包都是从一块网卡传递到另一块网卡，网卡的地址就是 Mac 地址。每一个 Mac 地址都是独一无二的，具备了一对一的能力。</p><p><strong>广播</strong></p><p>发送数据的方法很原始，直接把数据通过 ARP 协议，向本网络的所有机器发送，接收方根据标头信息与自身 Mac 地址比较，一致就接受，否则丢弃。</p><p>注意：接收方迴应是单播。</p><blockquote><p>相关知识：ARP攻击</p></blockquote><p>服务器接受请求</p><p>接受过程就是把以上步骤逆转过来，参见上图。</p><h3 id="服务器处理请求"><a class="markdownIt-Anchor" href="#服务器处理请求"></a> <strong>服务器处理请求</strong></h3><p>大致流程</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/img/What7897dasdandpressenteruiaasd.png" alt="What7897dasdandpressenteruiaasd" /></p><p><strong>HTTPD</strong></p><p>最常见的 HTTPD 有 Linux 上常用的 Apache 和 Nginx，以及 Windows 上的 IIS。</p><p>它会监听得到的请求，然后开启一个子进程去处理这个请求。</p><p><strong>处理请求</strong></p><p>接受 TCP 报文后，会对连接进行处理，对 HTTP 协议进行解析（请求方法、域名、路径等），并且进行一些验证：</p><ul><li>验证是否配置虚拟主机</li><li>验证虚拟主机是否接受此方法</li><li>验证该用户可以使用该方法（根据 IP 地址、身份信息等）</li></ul><p><strong>重定向</strong></p><p>假如服务器配置了 HTTP 重定向，就会返回一个 301 永久重定向响应，浏览器就会根据响应，重新发送 HTTP 请求（重新执行上面的过程）。</p><p><strong>URL 重写</strong></p><p>然后会查看 URL 重写规则，如果请求的文件是真实存在的，比如图片、html、css、js 文件等，则会直接把这个文件返回。</p><p>否则服务器会按照规则把请求重写到 一个 REST 风格的 URL 上。</p><p>然后根据动态语言的脚本，来决定调用什么类型的动态文件解释器来处理这个请求。</p><p>以 PHP 语言的 MVC 框架举例，它首先会初始化一些环境的参数，根据 URL 由上到下地去匹配路由，然后让路由所定义的方法去处理请求。</p><h3 id="服务器接受响应"><a class="markdownIt-Anchor" href="#服务器接受响应"></a> 服务器接受响应</h3><p>浏览器接收到来自服务器的响应资源后，会对资源进行分析。</p><p>首先查看 Response header，根据不同状态码做不同的事（比如上面提到的重定向）。</p><p>如果响应资源进行了压缩（比如 gzip），还需要进行解压。</p><p>然后，对响应资源做缓存。</p><p>接下来，根据响应资源里的 MIME 类型去解析响应内容（比如 HTML、Image 各有不同的解析方式）。</p><h3 id="渲染页面"><a class="markdownIt-Anchor" href="#渲染页面"></a> 渲染页面</h3><p><strong>浏览器内核</strong></p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/img/Wasasddhat45671URLssenasdterbroswerasda123.png" alt="Wasasddhat45671URLssenasdterbroswerasda123" /></p><p>不同的浏览器内核，渲染过程也不完全相同，但大致流程都差不多。</p><p><strong>基本流程</strong></p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/img/What4234anwserndpressenter123z.png" alt="What4234anwserndpressenter123z" /></p><p><strong>HTML 解析</strong></p><p>首先要知道浏览器解析是从上往下一行一行地解析的。</p><p>解析的过程可以分为四个步骤：</p><ol><li>解码（encoding）</li></ol><p>传输回来的其实都是一些二进制字节数据，浏览器需要根据文件指定编码（例如 UTF-8）转换成字符串，也就是 HTML 代码。</p><ol start="2"><li>预解析（pre-parsing）</li></ol><p>预解析做的事情是提前加载资源，减少处理时间，它会识别一些会请求资源的属性，比如 img 标籤的 src 属性，并将这个请求加到请求队列中。</p><ol start="3"><li>符号化（Tokenization）</li></ol><p>符号化是词法分析的过程，将输入解析成符号，HTML 符号包括，开始标籤、结束标籤、属性名和属性值。</p><p>它通过一个状态机去识别符号的状态，比如遇到 &lt;，&gt; 状态都会产生变化。</p><ol start="4"><li>构建树（tree construction）</li></ol><blockquote><p>注意：符号化和构建树是并行操作的，也就是説只要解析到一个开始标籤，就会创建一个 DOM 节点。</p></blockquote><p>在上一步符号化中，解析器获得这些标记，然后以合适的方法创建 DOM 对象并把这些符号插入到 DOM 对象中。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Web page parsing<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Web page parsing<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is an example Web page.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>浏览器容错进制</strong></p><p>你从来没有在浏览器看过类似” 语法无效” 的错误，这是因为浏览器去纠正错误的语法，然后继续工作。</p><p><strong>事件</strong></p><p>当整个解析的过程完成以后，浏览器会通过 DOMContentLoaded 事件来通知 DOM 解析完成。</p><p><strong>CSS 解析</strong></p><p>一旦浏览器下载了 CSS，CSS 解析器就会处理它遇到的任何 CSS，根据语法规範解析出所有的 CSS 并进行标记化，然后我们得到一个规则表。</p><p><strong>CSS 匹配规则</strong></p><p>在匹配一个节点对应的 CSS 规则时，是按照从右到左的顺序的，例如：div p { font-size :14px } 会先寻找所有的 p 标籤然后判断它的父元素是否为 div。</p><p>所以我们写 CSS 时，儘量用 id 和 class，千万不要过度层叠。</p><p><strong>渲染树</strong></p><p>其实这就是一个 DOM 树和 CSS 规则树合併的过程。</p><blockquote><p>注意：渲染树会忽略那些不需要渲染的节点，比如设置了 display:none 的节点。</p></blockquote><p><strong>计算</strong></p><p>通过计算让任何尺寸值都减少到三个可能之一：auto、百分比、px，比如把 rem 转化为 px。</p><p><strong>级联</strong></p><p>浏览器需要一种方法来确定哪些样式才真正需要应用到对应元素，所以它使用一个叫做 specificity 的公式，这个公式会通过：</p><ul><li>标籤名、class、id</li><li>是否内联样式</li><li>!important</li></ul><p>然后得出一个权重值，取最高的那个。</p><p><strong>渲染阻塞</strong></p><p>当遇到一个 script 标籤时，DOM 构建会被暂停，直至脚本完成执行，然后继续构建 DOM 树。</p><p>但如果 JS 依赖 CSS 样式，而它还没有被下载和构建时，浏览器就会延迟脚本执行，直至 CSS Rules 被构建。</p><p>所有我们知道：</p><ul><li>CSS 会阻塞 JS 执行</li><li>JS 会阻塞后面的 DOM 解析</li></ul><p>为了避免这种情况，应该以下原则：</p><ul><li>CSS 资源排在 JavaScript 资源前面</li><li>JS 放在 HTML 最底部，也就是 </body> 前</li></ul><p>另外，如果要改变阻塞模式，可以使用 defer 与 async，详见：<a href="https://github.com/xiaoyu2er/blog/issues/8" target="_blank" rel="noopener">这篇文章</a></p><p>###¥ 佈局与绘製</p><p>确定渲染树种所有节点的几何属性，比如：位置、大小等等，最后输入一个盒子模型，它能精準地捕获到每个元素在屏幕内的準确位置与大小。</p><p>然后遍歷渲染树，调用渲染器的 paint () 方法在屏幕上显示其内容。</p><p>###¥ 合併渲染层</p><p>把以上绘製的所有图片合併，最终输出一张图片。</p><p>###¥ 迴流与重绘</p><p><strong>迴流 (reflow)</strong></p><p>当浏览器发现某个部分发现变化影响了佈局时，需要倒回去重新渲染，会从 html 标籤开始递归往下，重新计算位置和大小。</p><p>reflow 基本是无法避免的，因为当你滑动一下鼠标、resize 窗口，页面就会产生变化。</p><p><strong>重绘 (repaint)</strong></p><p>改变了某个元素的背景色、文字颜色等等不会影响周围元素的位置变化时，就会发生重绘。</p><p>每次重绘后，浏览器还需要合併渲染层并输出到屏幕上。</p><p>迴流的成本要比重绘高很多，所以我们应该儘量避免产生迴流。</p><p>比如：</p><ul><li>display:none 会触发迴流，而 visibility:hidden 只会触发重绘。</li></ul><h4 id="javascript-编译执行"><a class="markdownIt-Anchor" href="#javascript-编译执行"></a> JavaScript 编译执行</h4><p>可以分为三个阶段：</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/img/W123hatnURLinthebr678678.png" alt="W123hatnURLinthebr678678" /></p><h5 id="词法分析"><a class="markdownIt-Anchor" href="#词法分析"></a> 词法分析</h5><p>JS 脚本加载完毕后，会首先进入语法分析阶段，它首先会分析代码块的语法是否正确，不正确则抛出 “语法错误”，停止执行。</p><p>几个步骤：</p><ul><li>分词，例如将 var a = 2，，分成 var、a、=、2 这样的词法单元。</li><li>解析，将词法单元转换成抽象语法树（AST）。</li><li>代码生成，将抽象语法树转换成机器指令。</li></ul><h5 id="预编译"><a class="markdownIt-Anchor" href="#预编译"></a> 预编译</h5><p>JS 有三种运行环境：</p><ul><li>全局环境</li><li>函数环境</li><li>eval</li></ul><p>每进入一个不同的运行环境都会创建一个对应的执行上下文，根据不同的上下文环境，形成一个函数调用栈，栈底永远是全局执行上下文，栈顶则永远是当前执行上下文。</p><p>创建执行上下文</p><p>创建执行上下文的过程中，主要做了以下三件事：</p><ul><li>创建变量对象<ul><li>参数、函数、变量</li></ul></li><li>建立作用域链<ul><li>确认当前执行环境是否能访问变量</li></ul></li><li>确定 This 指向</li></ul><h5 id="执行"><a class="markdownIt-Anchor" href="#执行"></a> 执行</h5><p><strong>JS 线程</strong></p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/img/Wzxc123nasdqwdsc.png" alt="Wzxc123nasdqwdsc" /></p><p>虽然 JS 是单线程的，但实际上参与工作的线程一共有四个：</p><blockquote><p>其中三个只是协助，只有 JS 引擎线程是真正执行的</p></blockquote><ul><li>JS 引擎线程：也叫 JS 内核，负责解析执行 JS 脚本程序的主线程，例如 V8 引擎</li><li>事件触发线程：属于浏览器内核线程，主要用于控制事件，例如鼠标、键盘等，当事件被触发时，就会把事件的处理函数推进事件队列，等待 JS 引擎线程执行</li><li>定时器触发线程：主要控制 setInterval 和 setTimeout，用来计时，计时完毕后，则把定时器的处理函数推进事件队列中，等待 JS 引擎线程。</li><li>HTTP 异步请求线程：通过 XMLHttpRequest 连接后，通过浏览器新开的一个线程，监控 readyState 状态变更时，如果设置了该状态的回调函数，则将该状态的处理函数推进事件队列中，等待 JS 引擎线程执行。</li></ul><p>注：浏览器对同一域名的併发连接数是有限的，通常为 6 个。</p><p><strong>宏任务</strong></p><p>分为：</p><ul><li>同步任务：按照顺序执行，只有前一个任务完成后，才能执行后一个任务</li><li>异步任务：不直接执行，只有满足触发条件时，相关的线程将该异步任务推进任务队列中，等待 JS 引擎主线程上的任务执行完毕时才开始执行，例如异步 Ajax、DOM 事件，setTimeout 等。</li></ul><p><strong>微任务</strong></p><p>微任务是 ES6 和 Node 环境下的，主要 API 有：Promise，process.nextTick。</p><p>微任务的执行在宏任务的同步任务之后，在异步任务之前。</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/img/Wzxc123nasdqwdsc.png" alt="Wzxc123nasdqwdsc" /></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>); <span class="comment">// 宏任务 同步</span></span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2'</span>); <span class="comment">// 宏任务 异步</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'3'</span>); <span class="comment">// 宏任务 同步</span></span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'4'</span>) <span class="comment">// 微任务</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'5'</span>) <span class="comment">// 宏任务 同步</span></span><br></pre></td></tr></table></figure><p>以上代码输出顺序为：1,3,5,4,2</p><h2 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h2><ul><li><a href="https://github.com/skyline75489/what-happens-when-zh_CN" target="_blank" rel="noopener">what-happens-when-zh_CN</a></li><li><a href="https://heyingye.github.io/2018/04/16/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/" target="_blank" rel="noopener">彻底理解浏览器的缓存机制</a></li><li><a href="https://blog.fundebug.com/2019/01/03/understand-browser-rendering/" target="_blank" rel="noopener">深入浅出浏览器渲染原理</a></li><li><a href="https://heyingye.github.io/2018/03/19/js%E5%BC%95%E6%93%8E%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/#%E9%A2%84%E7%BC%96%E8%AF%91%E9%98%B6%E6%AE%B5" target="_blank" rel="noopener">js 引擎的执行过程（一）</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h2&gt;
&lt;p&gt;这个问题已经是老生常谈了，更是经常被作为面试的压轴题出现，网上也有很多文章，但最近闲的无聊，然后就自己做了一篇笔记，感觉比之前理解更透彻了。&lt;/
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://wangqiang.cool/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="Http" scheme="http://wangqiang.cool/tags/Http/"/>
    
  </entry>
  
  <entry>
    <title>静态代理+ JDK,CGLIB动态代理详解与实战</title>
    <link href="http://wangqiang.cool/2020/12/06/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86+%20JDK,CGLIB%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%AE%9E%E6%88%98/"/>
    <id>http://wangqiang.cool/2020/12/06/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86+%20JDK,CGLIB%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%AE%9E%E6%88%98/</id>
    <published>2020-12-06T06:52:36.000Z</published>
    <updated>2020-12-06T07:37:54.332Z</updated>
    
    <content type="html"><![CDATA[<h2 id="代理模式"><a class="markdownIt-Anchor" href="#代理模式"></a> 代理模式</h2><p>代理模式是一种比较好的理解的设计模式。简单来说就是 <strong>我们使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。</strong></p><p><strong>代理模式的主要作用是扩展目标对象的功能，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作。</strong></p><p>举个例子：你的找了一小红来帮你问话，小红就看作是代理我的代理对象，代理的行为（方法）是问话。</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/img/20201206150121.png" alt="代理模式图解" /></p><p>代理模式有静态代理和动态代理两种实现方式，我们 先来看一下静态代理模式的实现。</p><h2 id="静态代理"><a class="markdownIt-Anchor" href="#静态代理"></a> 静态代理</h2><h3 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h3><p><strong>静态代理中，我们对目标对象的每个方法的增强都是手动完成的（*后面会具体演示代码_），非常不灵活（<em>比如接口一旦新增加方法，目标对象和代理对象都要进行修改</em>）且麻烦(_需要对每个目标类都单独写一个代理类*)。</strong> 实际应用场景非常非常少，日常开发几乎看不到使用静态代理的场景。</p><p>上面我们是从实现和应用角度来说的静态代理，从 JVM 层面来说， <strong>静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。</strong></p><h3 id="静态代理使用步骤"><a class="markdownIt-Anchor" href="#静态代理使用步骤"></a> 静态代理使用步骤</h3><ol><li>定义一个接口及其实现类；</li><li>创建一个代理类同样实现这个接口</li><li>将目标对象注注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。</li></ol><h3 id="代码示例"><a class="markdownIt-Anchor" href="#代码示例"></a> 代码示例</h3><p><strong>1.定义发送短信的接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SmsService</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">send</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.实现发送短信的接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsServiceImpl</span> <span class="keyword">implements</span> <span class="title">SmsService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">send</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"send message:"</span> + message);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.创建代理类并同样实现发送短信的接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsProxy</span> <span class="keyword">implements</span> <span class="title">SmsService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SmsService smsService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SmsProxy</span><span class="params">(SmsService smsService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.smsService = smsService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">send</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用方法之前，我们可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">"before method send()"</span>);</span><br><span class="line">        smsService.send(message);</span><br><span class="line">        <span class="comment">//调用方法之后，我们同样可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">"after method send()"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4.实际使用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SmsService smsService = <span class="keyword">new</span> SmsServiceImpl();</span><br><span class="line">        SmsProxy smsProxy = <span class="keyword">new</span> SmsProxy(smsService);</span><br><span class="line">        smsProxy.send(<span class="string">"java"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上述代码之后，控制台打印出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">before method send()</span><br><span class="line">send message:java</span><br><span class="line">after method send()</span><br></pre></td></tr></table></figure><p>可以输出结果看出，我们已经增加了 <code>SmsServiceImpl</code> 的<code>send()</code>方法。</p><h2 id="动态代理"><a class="markdownIt-Anchor" href="#动态代理"></a> 动态代理</h2><p>相比于静态代理来说，动态代理更加灵活。我们不需要针对每个目标类都单独创建一个代理类，并且也不需要我们必须实现接口，我们可以直接代理实现类( <em>CGLIB 动态代理机制</em>)。</p><p><strong>从 JVM 角度来说，动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</strong></p><p>说到动态代理，Spring AOP、RPC 框架应该是两个不得不的提的，它们的实现都依赖了动态代理。</p><p><strong>动态代理在我们日常开发中使用的相对较小，但是在框架中的几乎是必用的一门技术。学会了动态代理之后，对于我们理解和学习各种框架的原理也非常有帮助。</strong></p><p>就 Java 来说，动态代理的实现方式有很多种，比如 <strong>JDK 动态代理</strong>、<strong>CGLIB 动态代理</strong>等等。</p><h3 id="jdk-动态代理机制"><a class="markdownIt-Anchor" href="#jdk-动态代理机制"></a> JDK 动态代理机制</h3><h4 id="介绍-2"><a class="markdownIt-Anchor" href="#介绍-2"></a> 介绍</h4><p><strong>在 Java 动态代理机制中 <code>InvocationHandler</code> 接口和 <code>Proxy</code> 类是核心。</strong></p><p><code>Proxy</code> 类中使用频率最高的方法是：<code>newProxyInstance()</code> ，这个方法主要用来生成一个代理对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          InvocationHandler h)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个方法一共有 3 个参数：</p><ol><li><strong>loader</strong> :类加载器，用于加载代理对象。</li><li><strong>interfaces</strong> : 被代理类实现的一些接口；</li><li><strong>h</strong> : 实现了 <code>InvocationHandler</code> 接口的对象；</li></ol><p>要实现动态代理的话，还必须需要实现<code>InvocationHandler</code> 来自定义处理逻辑。 当我们的动态代理对象调用一个方法时候，这个方法的调用就会被转发到实现<code>InvocationHandler</code> 接口类的 <code>invoke</code> 方法来调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当你使用代理对象调用方法的时候实际会调用到这个方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>invoke()</code> 方法有下面三个参数：</p><ol><li><strong>proxy</strong> :动态生成的代理类</li><li><strong>method</strong> : 与代理类对象调用的方法相对应</li><li><strong>args</strong> : 当前 method 方法的参数</li></ol><p>也就是说：<strong>你通过<code>Proxy</code> 类的 <code>newProxyInstance()</code> 创建的代理对象在调用方法的时候，实际会调用到实现<code>InvocationHandler</code> 接口的类的 <code>invoke()</code>方法。</strong> 你可以在 <code>invoke()</code> 方法中自定义处理逻辑，比如在方法执行前后做什么事情。</p><h4 id="jdk-动态代理类使用步骤"><a class="markdownIt-Anchor" href="#jdk-动态代理类使用步骤"></a> JDK 动态代理类使用步骤</h4><ol><li>定义一个接口及其实现类；</li><li>自定义 <code>InvocationHandler</code> 并重写<code>invoke</code>方法，在 <code>invoke</code> 方法中我们会调用原生方法（被代理类的方法）并自定义一些处理逻辑；</li><li>通过 <code>Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</code> 方法创建代理对象；</li></ol><h4 id="代码示例-2"><a class="markdownIt-Anchor" href="#代码示例-2"></a> 代码示例</h4><p><strong>1.定义发送短信的接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SmsService</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">send</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.实现发送短信的接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsServiceImpl</span> <span class="keyword">implements</span> <span class="title">SmsService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">send</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"send message:"</span> + message);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.定义一个 JDK 动态代理类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shuang.kou</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createTime</span> 2020年05月11日 11:23:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DebugInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代理类中的真实对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DebugInvocationHandler</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class="line">        <span class="comment">//调用方法之前，我们可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">"before method "</span> + method.getName());</span><br><span class="line">        Object result = method.invoke(target, args);</span><br><span class="line">        <span class="comment">//调用方法之后，我们同样可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">"after method "</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>invoke()</code> 方法: 当我们的动态代理对象调用原生方法的时候，最终实际上调用到的是 <code>invoke()</code> 方法，然后 <code>invoke()</code> 方法代替我们去调用了被代理对象的原生方法。</p><p><strong>4.获取代理对象的工厂类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkProxyFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getProxy</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">                target.getClass().getClassLoader(), <span class="comment">// 目标类的类加载</span></span><br><span class="line">                target.getClass().getInterfaces(),  <span class="comment">// 代理需要实现的接口，可指定多个</span></span><br><span class="line">                <span class="keyword">new</span> DebugInvocationHandler(target)   <span class="comment">// 代理对象对应的自定义 InvocationHandler</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getProxy()</code> ：主要通过<code>Proxy.newProxyInstance（）</code>方法获取某个类的代理对象</p><p><strong>5.实际使用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SmsService smsService = (SmsService) JdkProxyFactory.getProxy(<span class="keyword">new</span> SmsServiceImpl());</span><br><span class="line">smsService.send(<span class="string">"java"</span>);</span><br></pre></td></tr></table></figure><p>运行上述代码之后，控制台打印出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">before method send</span><br><span class="line">send message:java</span><br><span class="line">after method send</span><br></pre></td></tr></table></figure><h3 id="cglib-动态代理机制"><a class="markdownIt-Anchor" href="#cglib-动态代理机制"></a> CGLIB 动态代理机制</h3><h4 id="介绍-3"><a class="markdownIt-Anchor" href="#介绍-3"></a> 介绍</h4><p><strong>JDK 动态代理有一个最致命的问题是其只能代理实现了接口的类。</strong></p><p><strong>为了解决这个问题，我们可以用 CGLIB 动态代理机制来避免。</strong></p><p><a href="https://github.com/cglib/cglib" target="_blank" rel="noopener">CGLIB</a>(<em>Code Generation Library</em>)是一个基于<a href="http://www.baeldung.com/java-asm" target="_blank" rel="noopener">ASM</a>的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB 通过继承方式实现代理。很多知名的开源框架都使用到了<a href="https://github.com/cglib/cglib" target="_blank" rel="noopener">CGLIB</a>， 例如 Spring 中的 AOP 模块中：如果目标对象实现了接口，则默认采用 JDK 动态代理，否则采用 CGLIB 动态代理。</p><p><strong>在 CGLIB 动态代理机制中 <code>MethodInterceptor</code> 接口和 <code>Enhancer</code> 类是核心。</strong></p><p>你需要自定义 <code>MethodInterceptor</code> 并重写 <code>intercept</code> 方法，<code>intercept</code> 用于拦截增强被代理类的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodInterceptor</span></span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">Callback</span></span>&#123;</span><br><span class="line">    <span class="comment">// 拦截被代理类中的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, java.lang.reflect.Method method, Object[] args,</span></span></span><br><span class="line"><span class="function"><span class="params">                               MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>obj</strong> :被代理的对象（需要增强的对象）</li><li><strong>method</strong> :被拦截的方法（需要增强的方法）</li><li><strong>args</strong> :方法入参</li><li><strong>methodProxy</strong> :用于调用原始方法</li></ol><p>你可以通过 <code>Enhancer</code>类来动态获取被代理类，当代理类调用方法的时候，实际调用的是 <code>MethodInterceptor</code>中的 <code>intercept</code> 方法。</p><h4 id="cglib-动态代理类使用步骤"><a class="markdownIt-Anchor" href="#cglib-动态代理类使用步骤"></a> CGLIB 动态代理类使用步骤</h4><ol><li>定义一个类；</li><li>自定义 <code>MethodInterceptor</code> 并重写 <code>intercept</code> 方法，<code>intercept</code> 用于拦截增强被代理类的方法，和 JDK 动态代理中的 <code>invoke</code> 方法类似；</li><li>通过 <code>Enhancer</code> 类的 <code>create()</code>创建代理类；</li></ol><h4 id="代码示例-3"><a class="markdownIt-Anchor" href="#代码示例-3"></a> 代码示例</h4><p>不同于 JDK 动态代理不需要额外的依赖。<a href="https://github.com/cglib/cglib" target="_blank" rel="noopener">CGLIB</a>(<em>Code Generation Library</em>) 实际是属于一个开源项目，如果你要使用它的话，需要手动添加相关依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>1.实现一个使用阿里云发送短信的类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> github.javaguide.dynamicProxy.cglibDynamicProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AliSmsService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">send</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"send message:"</span> + message);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.自定义 <code>MethodInterceptor</code>（方法拦截器）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义MethodInterceptor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DebugMethodInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o           被代理的对象（需要增强的对象）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method      被拦截的方法（需要增强的方法）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args        方法入参</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodProxy 用于调用原始方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//调用方法之前，我们可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">"before method "</span> + method.getName());</span><br><span class="line">        Object object = methodProxy.invokeSuper(o, args);</span><br><span class="line">        <span class="comment">//调用方法之后，我们同样可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">"after method "</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.获取代理类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxyFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getProxy</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建动态代理增强类</span></span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">// 设置类加载器</span></span><br><span class="line">        enhancer.setClassLoader(clazz.getClassLoader());</span><br><span class="line">        <span class="comment">// 设置被代理类</span></span><br><span class="line">        enhancer.setSuperclass(clazz);</span><br><span class="line">        <span class="comment">// 设置方法拦截器</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> DebugMethodInterceptor());</span><br><span class="line">        <span class="comment">// 创建代理类</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4.实际使用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AliSmsService aliSmsService = (AliSmsService) CglibProxyFactory.getProxy(AliSmsService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">aliSmsService.send(<span class="string">"java"</span>);</span><br></pre></td></tr></table></figure><p>运行上述代码之后，控制台打印出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">before method send</span><br><span class="line">send message:java</span><br><span class="line">after method send</span><br></pre></td></tr></table></figure><h3 id="jdk-动态代理和-cglib-动态代理对比"><a class="markdownIt-Anchor" href="#jdk-动态代理和-cglib-动态代理对比"></a> JDK 动态代理和 CGLIB 动态代理对比</h3><ol><li><strong>JDK 动态代理只能只能代理实现了接口的类，而 CGLIB 可以代理未实现任何接口的类。</strong> 另外， CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。</li><li>就二者的效率来说，大部分情况都是 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势更加明显。</li></ol><h2 id="静态代理和动态代理的对比"><a class="markdownIt-Anchor" href="#静态代理和动态代理的对比"></a> 静态代理和动态代理的对比</h2><ol><li><strong>灵活性</strong> ：动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。另外，静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的！</li><li><strong>JVM 层面</strong> ：静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</li></ol><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>这篇文章中主要介绍了代理模式的两种实现：静态代理以及动态代理。涵盖了静态代理和动态代理实战、静态代理和动态代理的区别、JDK 动态代理和 Cglib 动态代理区别等内容。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;代理模式&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#代理模式&quot;&gt;&lt;/a&gt; 代理模式&lt;/h2&gt;
&lt;p&gt;代理模式是一种比较好的理解的设计模式。简单来说就是 &lt;strong&gt;我们使用代理对象来代替对真实对象(real object)的访问
      
    
    </summary>
    
    
      <category term="Java基础" scheme="http://wangqiang.cool/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="代理模式" scheme="http://wangqiang.cool/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="设计模式" scheme="http://wangqiang.cool/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Kafka消息中间件到底会不会丢消息</title>
    <link href="http://wangqiang.cool/2020/12/04/Kafka%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%88%B0%E5%BA%95%E4%BC%9A%E4%B8%8D%E4%BC%9A%E4%B8%A2%E6%B6%88%E6%81%AF/"/>
    <id>http://wangqiang.cool/2020/12/04/Kafka%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%88%B0%E5%BA%95%E4%BC%9A%E4%B8%8D%E4%BC%9A%E4%B8%A2%E6%B6%88%E6%81%AF/</id>
    <published>2020-12-04T14:40:16.000Z</published>
    <updated>2020-12-06T05:16:42.601Z</updated>
    
    <content type="html"><![CDATA[<h2 id="kafka消息中间件到底会不会丢消息"><a class="markdownIt-Anchor" href="#kafka消息中间件到底会不会丢消息"></a> Kafka消息中间件到底会不会丢消息</h2><p>大型互联网公司一般都会要求消息传递最大限度的不丢失，比如用户服务给代金券服务发送一个消息，如果消息丢失会造成用户未收到应得的代金券，最终用户会投诉。</p><p>为避免上面类似情况的发生，除了做好补偿措施，更应该在系设计的时候充分考虑各种异常，设计一个稳定、高可用的消息系统。</p><h2 id="认识kafka"><a class="markdownIt-Anchor" href="#认识kafka"></a> 认识Kafka</h2><p>看一下维基百科的定义</p><blockquote><p>Kafka是分布式发布-订阅消息系统。它最初由LinkedIn公司开发，之后成为Apache项目的一部分。</p><p>Kafka是一个分布式的，可划分的，冗余备份的持久性的日志服务。它主要用于处理活跃的流式数据。</p></blockquote><p><strong>kafka架构</strong></p><p>Kafka的整体架构非常简单，是显式分布式架构，主要由producer、broker（kafka）和consumer组成。</p><p><img src= "/img/loading.gif" data-src="https://gitee.com/ID_wangqiang/MyImage/raw/master/img//20201118144939.png" alt="" /></p><p><strong>Producer</strong>（生产者）可以将数据发布到所选择的topic（主题）中。生产者负责将记录分配到topic的哪一个 partition（分区）中。可以使用循环的方式来简单地实现负载均衡，也可以根据某些语义分区函数(如记录中的key)来完成。</p><p><strong>Consumer</strong>（消费者）使用一个consumer group（消费组）名称来进行标识，发布到topic中的每条记录被分配给订阅消费组中的一个消费者实例。消费者实例可以分布在多个进程中或者多个机器上。</p><h2 id="kafka到底会不会丢失消息"><a class="markdownIt-Anchor" href="#kafka到底会不会丢失消息"></a> Kafka到底会不会丢失消息？</h2><p>在讨论kafka是否丢消息前先来了解一下什么是<strong>消息传递语义</strong>。</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/img/20201118145540.png" alt="" /></p><p>message delivery semantic 也就是消息传递语义，简单说就是消息传递过程中消息传递的保证性。主要分为三种：</p><ul><li><strong>at most once</strong>：最多一次。消息可能丢失也可能被处理，但最多只会被处理一次。</li><li><strong>at least once</strong>：至少一次。消息不会丢失，但可能被处理多次。可能重复，不会丢失。</li><li><strong>exactly once</strong>：精确传递一次。消息被处理且只会被处理一次。不丢失不重复就一次。</li></ul><p>理想情况下肯定是希望系统的消息传递是严格exactly once，也就是保证不丢失、只会被处理一次，但是很难做到。</p><p>回到主角Kafka，Kafka有三次消息传递的过程：</p><ol><li>生产者发消息给Kafka Broker。</li><li>Kafka Broker 消息同步和持久化</li><li>Kafka Broker 将消息传递给消费者。</li></ol><p>在这三步中每一步都有可能会丢失消息，下面详细分析为什么会丢消息，如何最大限度避免丢失消息。</p><h2 id="生产者丢失消息"><a class="markdownIt-Anchor" href="#生产者丢失消息"></a> 生产者丢失消息</h2><p>先介绍一下生产者发送消息的一般流程（部分流程与具体配置项强相关，这里先忽略）：</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/img/20201118145821.png" alt="" /></p><ol><li>生产者是与leader直接交互，所以先从集群获取topic对应分区的leader元数据；</li><li>获取到leader分区元数据后直接将消息发给过去；</li><li>Kafka Broker对应的leader分区收到消息后写入文件持久化；</li><li>Follower拉取Leader消息与Leader的数据保持一致；</li><li>Follower消息拉取完毕需要给Leader回复ACK确认消息；</li><li>Kafka Leader和Follower分区同步完，Leader分区会给生产者回复ACK确认消息。</li></ol><p>生产者采用push模式将数据发布到broker，每条消息追加到分区中，顺序写入磁盘。消息写入Leader后，Follower是主动与Leader进行同步。</p><p>Kafka消息发送有两种方式：同步（sync）和异步（async），默认是同步方式，可通过producer.type属性进行配置。</p><p>Kafka通过配置request.required.acks属性来确认消息的生产：</p><ul><li>0表示不进行消息接收是否成功的确认；不能保证消息是否发送成功，生成环境基本不会用。</li><li>1表示当Leader接收成功时确认；只要Leader存活就可以保证不丢失，保证了吞吐量。</li><li>-1或者all表示Leader和Follower都接收成功时确认；可以最大限度保证消息不丢失，但是吞吐量低。</li></ul><p>kafka producer 的参数acks 的默认值为1，所以默认的producer级别是at least once，并不能exactly once。</p><p><strong>敲黑板了，这里可能会丢消息的！</strong></p><ul><li>如果acks配置为0，发生网络抖动消息丢了，生产者不校验ACK自然就不知道丢了。</li><li>如果acks配置为1保证leader不丢，但是如果leader挂了，恰好选了一个没有ACK的follower，那也丢了。</li><li>all：保证leader和follower不丢，但是如果网络拥塞，没有收到ACK，会有重复发的问题。</li></ul><h2 id="kafka-broker丢失消息"><a class="markdownIt-Anchor" href="#kafka-broker丢失消息"></a> Kafka Broker丢失消息</h2><p>Kafka Broker 接收到数据后会将数据进行持久化存储，你以为是下面这样的：</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/img/20201118150608.png" alt="消息持久化，无cache" /></p><p>没想到是这样的：</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/img/20201118150656.png" alt="消息持久化，有cache" /></p><p>操作系统本身有一层缓存，叫做 Page Cache，当往磁盘文件写入的时候，系统会先将数据流写入缓存中，至于什么时候将缓存的数据写入文件中是由操作系统自行决定。</p><p>Kafka提供了一个参数 producer.type 来控制是不是主动flush，如果Kafka写入到mmap之后就立即 flush 然后再返回 Producer 叫同步 (sync)；写入mmap之后立即返回 Producer 不调用 flush 叫异步 (async)。</p><p><strong>敲黑板了，这里可能会丢消息的！</strong></p><p>Kafka通过多分区多副本机制中已经能最大限度保证数据不会丢失，如果数据已经写入系统 cache 中但是还没来得及刷入磁盘，此时突然机器宕机或者掉电那就丢了，当然这种情况很极端。</p><h2 id="消费者丢失消息"><a class="markdownIt-Anchor" href="#消费者丢失消息"></a> 消费者丢失消息</h2><p>消费者通过pull模式主动的去 kafka 集群拉取消息，与producer相同的是，消费者在拉取消息的时候也是找leader分区去拉取。</p><p>多个消费者可以组成一个消费者组（consumer group），每个消费者组都有一个组id。同一个消费组者的消费者可以消费同一topic下不同分区的数据，但是不会出现多个消费者消费同一分区的数据。</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/img/20201118150844.png" alt="消费者群组消费消息" /></p><p>消费者消费的进度通过offset保存在kafka集群的__consumer_offsets这个topic中。</p><p>消费消息的时候主要分为两个阶段：</p><p>1、标识消息已被消费，commit offset坐标；</p><p>2、处理消息。</p><p><strong>敲黑板了，这里可能会丢消息的！</strong></p><p>场景一：先commit再处理消息。如果在处理消息的时候异常了，但是offset 已经提交了，这条消息对于该消费者来说就是丢失了，再也不会消费到了。</p><p>场景二：先处理消息再commit。如果在commit之前发生异常，下次还会消费到该消息，重复消费的问题可以通过业务保证消息幂等性来解决。</p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>那么问题来了，kafka到底会不会丢消息？答案是：会！</p><p>Kafka可能会在三个阶段丢失消息：</p><p>（1）生产者发送数据；</p><p>（2）Kafka Broker 存储数据；</p><p>（3）消费者消费数据；</p><p>在生产环境中严格做到exactly once其实是难的，同时也会牺牲效率和吞吐量，最佳实践是业务侧做好补偿机制，万一出现消息丢失可以兜底。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;kafka消息中间件到底会不会丢消息&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#kafka消息中间件到底会不会丢消息&quot;&gt;&lt;/a&gt; Kafka消息中间件到底会不会丢消息&lt;/h2&gt;
&lt;p&gt;大型互联网公司一般都会要求消息传递最大限度的不丢
      
    
    </summary>
    
    
      <category term="中间件" scheme="http://wangqiang.cool/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="Kafka" scheme="http://wangqiang.cool/tags/Kafka/"/>
    
      <category term="消息中间件" scheme="http://wangqiang.cool/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Kafka 如何做到支持百万级 TPS ？</title>
    <link href="http://wangqiang.cool/2020/11/30/Kafka%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E6%94%AF%E6%8C%81%E7%99%BE%E4%B8%87%E7%BA%A7TPS%EF%BC%9F/"/>
    <id>http://wangqiang.cool/2020/11/30/Kafka%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E6%94%AF%E6%8C%81%E7%99%BE%E4%B8%87%E7%BA%A7TPS%EF%BC%9F/</id>
    <published>2020-11-30T14:40:16.000Z</published>
    <updated>2020-12-06T05:20:09.425Z</updated>
    
    <content type="html"><![CDATA[<h2 id="kafka-如何做到支持百万级-tps"><a class="markdownIt-Anchor" href="#kafka-如何做到支持百万级-tps"></a> Kafka 如何做到支持百万级 TPS ？</h2><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImheg@master/img/20201205112006.webp" alt="Kafka" /></p><p>谈到大数据传输都会想到 Kafka，Kafka 号称大数据的杀手锏，在业界有很多成熟的应用场景并且被主流公司认可。这款为大数据而生的消息中间件，以其百万级TPS的吞吐量名声大噪，迅速成为大数据领域的宠儿，在数据采集、传输、存储的过程中发挥着举足轻重的作用。</p><p>在业界已经有很多成熟的消息中间件如：RabbitMQ, RocketMQ, ActiveMQ, ZeroMQ，为什么 Kafka 在众多的敌手中依然能有一席之地，当然靠的是其强悍的吞吐量。下面带领大家来揭秘。</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/img/20201205112104.png" alt="Kafka 支持百万TPS的秘密" /></p><h3 id="顺序读写磁盘"><a class="markdownIt-Anchor" href="#顺序读写磁盘"></a> 顺序读写磁盘</h3><p>生产者写入数据和消费者读取数据都是<strong>顺序读写</strong>的，先来一张图直观感受一下顺序读写和随机读写的速度</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/img/20201205112153.png" alt="顺序读写 VS 随机读写" /></p><p>从图中可以看出传统硬盘或者SSD的顺序读写甚至超过了内存的随机读写，当然与内存的顺序读写对比差距还是很大。</p><p>所以Kafka选择顺序读写磁盘也不足为奇了。</p><p>下面以传统机械磁盘为例详细介绍一下什么是顺序读写和随机读写。</p><p><strong>盘片</strong>和<strong>盘面</strong>：一块硬盘一般有多块盘片，盘片分为上下两面，其中有效面称为盘面，一般上下都有效，也就是说：<strong>盘面数 = 盘片数 * 2。</strong></p><p><strong>磁头</strong>：磁头切换磁道读写数据时是通过机械设备实现的，一般速度较慢；而磁头切换盘面读写数据是通过电子设备实现的，一般速度较快，因此磁头一般是先读写完柱面后才开始寻道的(不用切换磁道)，这样磁盘读写效率更快。</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/img/20201205112235.png" alt="传统机械磁盘" /></p><p><strong>磁道</strong>：磁道就是以中间轴为圆心的圆环，一个盘面有多个磁道，磁道之间有间隙，磁道也就是磁盘存储数据的介质。磁道上布有一层磁介质，通过磁头可以使磁介质的极性转换为数据信号，即磁盘的读，磁盘写刚好与之相反。</p><p><strong>柱面</strong>：磁盘中不同盘面中半径相同的磁道组成的，也就是说柱面总数 = 某个盘面的磁道数。</p><p><strong>扇区</strong>：单个磁道就是多个弧形扇区组成的，盘面上的每个磁道拥有的扇区数量是相等。扇区是最小存储单元，一般扇区大小为512bytes。</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/img/20201205112313.png" alt="单盘片示意图" /></p><p>如果系统每次只读取一个扇区，那恐怕效率太低了，所以出现了block（块）的概念。文件读取的最小单位是block，根据不同操作系统一个block一般由多个扇区组成。</p><p>有了磁盘的背景知识我们就可以很容易理解顺序读写和随机读写了。</p><blockquote><p>维基百科定义：</p><p><strong>顺序读写</strong>：是一种按记录的逻辑顺序进行读、写操作的存取方法 ，即按照信息在存储器中的实际位置所决定的顺序使用信息。</p><p><strong>随机读写</strong>：指的是当存储器中的消息被读取或写入时，所需要的时间与这段信息所在的位置无关。</p></blockquote><p>当读取第一个block时，要经历寻道、旋转延迟、传输三个步骤才能读取完这个block的数据。而对于下一个block，如果它在磁盘的其他任意位置，访问它会同样经历寻道、旋转、延时、传输才能读取完这个block的数据，我们把这种方式叫做<strong>随机读写</strong>。但是如果这个block的起始扇区刚好在刚才访问的block的后面，磁头就能立刻遇到，不需等待直接传输，这种就叫<strong>顺序读写</strong>。</p><p>好，我们再回到 Kafka，详细介绍Kafka如何实现顺序读写入数据。</p><p>Kafka 写入数据是顺序的，下面每一个Partition 都可以当做一个文件，每次接收到新数据后Kafka会把数据插入到文件末尾，虚框部分代表文件尾。</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/img/20201205112435.png" alt="顺序写" /></p><p>这种方法有一个问题就是删除数据不方便，所以 Kafka 一般会把所有的数据都保留下来，每个消费者（Consumer）对每个Topic都有一个 offset 用来记录读取进度或者叫坐标。</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/img/20201205112519.png" alt="顺序读" /></p><h3 id="memory-mapped-filesmmap"><a class="markdownIt-Anchor" href="#memory-mapped-filesmmap"></a> Memory Mapped Files(MMAP)</h3><p>在文章开头我们看到硬盘的顺序读写基本能与内存随机读写速度媲美，但是与内存顺序读写相比还是太慢了，那 Kafka 如果有追求想进一步提升效率怎么办？可以使用现代操作系统分页存储来充分利用内存提高I/O效率，这也是下面要介绍的 MMAP 技术。</p><p><strong>MMAP</strong>也就是<strong>内存映射文件</strong>，在64位操作系统中一般可以表示 20G 的数据文件，它的工作原理是直接利用操作系统的 Page 来实现文件到物理内存的直接映射，完成映射之后对物理内存的操作会被同步到硬盘上。</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/img/20201205112628.png" alt="MMAP原理" /></p><p>通过<strong>MMAP</strong>技术进程可以像读写硬盘一样读写内存（逻辑内存），不必关心内存的大小，因为有虚拟内存兜底。这种方式可以获取很大的I/O提升，省去了用户空间到内核空间复制的开销。</p><p>也有一个很明显的缺陷，写到<strong>MMAP</strong>中的数据并没有被真正的写到硬盘，操作系统会在程序主动调用 flush 的时候才把数据真正的写到硬盘。</p><p>Kafka提供了一个参数：producer.type 来控制是不是主动 flush，如果Kafka写入到MMAP之后就立即flush然后再返回Producer叫同步(sync)；写入MMAP之后立即返回Producer不调用flush叫异步(async)。</p><h3 id="zero-copy零拷贝"><a class="markdownIt-Anchor" href="#zero-copy零拷贝"></a> Zero Copy（零拷贝）</h3><p>Kafka 另外一个黑技术就是使用了零拷贝，要想深刻理解零拷贝必须得知道什么是DMA。</p><p><strong>什么是DMA?</strong></p><p>众所周知 CPU 的速度与磁盘 IO 的速度比起来相差几个数量级，可以用乌龟和火箭做比喻。</p><p>一般来说 IO 操作都是由 CPU 发出指令，然后等待 IO 设备完成操作后返回，那CPU会有大量的时间都在等待IO操作。</p><p>但是CPU 的等待在很多时候并没有太多的实际意义，我们对于 I/O 设备的大量操作其实都只是把内存里面的数据传输到 I/O 设备而已。比如进行大文件复制，如果所有数据都要经过 CPU，实在是有点儿太浪费时间了。</p><p>基于此就有了DMA技术，翻译过来也就是直接内存访问（Direct Memory Access），有了这个可以减少 CPU 的等待时间。</p><p><strong>Kafka 零拷贝原理</strong></p><p>如果不使用零拷贝技术，消费者（consumer）从Kafka消费数据，Kafka从磁盘读数据然后发送到网络上去，数据一共发生了四次传输的过程。其中两次是 DMA 的传输，另外两次，则是通过 CPU 控制的传输。</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/img/20201205112747.png" alt="四次传输过程" /></p><p><strong>第一次传输</strong>：从硬盘上将数据读到操作系统内核的缓冲区里，这个传输是通过 DMA 搬运的。</p><p><strong>第二次传输</strong>：从内核缓冲区里面的数据复制到分配的内存里面，这个传输是通过 CPU 搬运的。</p><p><strong>第三次传输</strong>：从分配的内存里面再写到操作系统的 Socket 的缓冲区里面去，这个传输是由 CPU 搬运的。</p><p><strong>第四次传输</strong>：从 Socket 的缓冲区里面写到网卡的缓冲区里面去，这个传输是通过 DMA 搬运的。</p><p>实际上在kafka中只进行了两次数据传输，如下图：</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/img/20201205112840.png" alt="两次传输，零拷贝技术" /></p><p><strong>第一次传输</strong>：通过 DMA从硬盘直接读到操作系统内核的读缓冲区里面。</p><p><strong>第二次传输</strong>：根据 Socket 的描述符信息直接从读缓冲区里面写入到网卡的缓冲区里面。</p><p>我们可以看到同一份数据的传输次数从四次变成了两次，并且没有通过 CPU 来进行数据搬运，所有的数据都是通过 DMA 来进行传输的。没有在内存层面去复制（Copy）数据，这个方法称之为<strong>零拷贝（Zero-Copy）。</strong></p><p>无论传输数据量的大小，传输同样的数据使用了零拷贝能够缩短 65% 的时间，大幅度提升了机器传输数据的吞吐量，这也是Kafka能够支持百万TPS的一个重要原因。</p><h3 id="batch-data数据批量处理"><a class="markdownIt-Anchor" href="#batch-data数据批量处理"></a> Batch Data（数据批量处理）</h3><p>当消费者（consumer）需要消费数据时，首先想到的是消费者需要一条，kafka发送一条，消费者再要一条kafka再发送一条。但实际上 Kafka 不是这样做的，Kafka 耍小聪明了。</p><p>Kafka 把所有的消息都存放在一个一个的文件中，当消费者需要数据的时候 Kafka 直接把文件发送给消费者。比如说100万条消息放在一个文件中可能是10M的数据量，如果消费者和Kafka之间网络良好，10MB大概1秒就能发送完，既100万TPS，Kafka每秒处理了10万条消息。</p><p>看到这里你可以有疑问了，消费者只需要一条消息啊，kafka把整个文件都发送过来了，文件里面剩余的消息怎么办？不要忘了消费者可以通过offset记录消费进度。</p><p>发送文件还有一个好处就是可以对文件进行批量压缩，减少网络IO损耗。</p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>最后再总结一下 Kafka 支持百万级 TPS 的秘密：</p><p>（1）顺序写入数据，在 Partition 末尾追加，所以速度最优。</p><p>（2）使用 MMAP 技术将磁盘文件与内存映射，Kafka 可以像操作磁盘一样操作内存。</p><p>（3）通过 DMA 技术实现零拷贝，减少数据传输次数。</p><p>（4）读取数据时配合sendfile直接暴力输出，批量压缩把所有消息变成一个批量文件，合理减少网络IO损耗。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;kafka-如何做到支持百万级-tps&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#kafka-如何做到支持百万级-tps&quot;&gt;&lt;/a&gt; Kafka 如何做到支持百万级 TPS ？&lt;/h2&gt;
&lt;p&gt;&lt;img src= &quot;/img/loa
      
    
    </summary>
    
    
      <category term="中间件" scheme="http://wangqiang.cool/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="Kafka" scheme="http://wangqiang.cool/tags/Kafka/"/>
    
      <category term="消息中间件" scheme="http://wangqiang.cool/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 30. 包含min函数的栈</title>
    <link href="http://wangqiang.cool/2020/09/08/%E5%89%91%E6%8C%87-Offer-30-%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/"/>
    <id>http://wangqiang.cool/2020/09/08/%E5%89%91%E6%8C%87-Offer-30-%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/</id>
    <published>2020-09-08T13:54:43.000Z</published>
    <updated>2020-09-08T14:08:43.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目信息"><a class="markdownIt-Anchor" href="#题目信息"></a> 题目信息</h3><ul><li><p>题目：剑指 Offer 30. 包含min函数的栈</p></li><li><p>时间： 2020-09-08</p></li><li><p>题目链接：<a href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/" target="_blank" rel="noopener">Leetcode</a></p></li><li><p>tag：栈</p></li><li><p>难易程度：简单</p></li><li><p>题目描述：</p><p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p></li></ul><p><strong>示例:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MinStack minStack = new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.min();   --&gt; 返回 -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 0.</span><br><span class="line">minStack.min();   --&gt; 返回 -2.</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><blockquote><p>本题难点</p></blockquote><p>普通栈的 push() 和 pop() 函数的复杂度为 O(1)；而获取栈最小值 min() 函数需要遍历整个栈，复杂度为 O(N)。</p><blockquote><p>具体思路</p></blockquote><p>将 min() 函数复杂度降为 O(1) ，可通过建立辅助栈实现；</p><ul><li><p>数据栈dataStack ： 栈 dataStack用于存储所有元素，保证入栈 push() 函数、出栈 pop() 函数、获取栈顶 top() 函数的正常逻辑。</p></li><li><p>辅助栈 minStack： 栈 minStack 中存储栈 dataStack 中所有 非严格降序 的元素，则栈 dataStack 中的最小元素始终对应栈 minStack 的栈顶元素，即 min() 函数只需返回栈minStack 的栈顶元素即可。</p></li><li><p>因此，只需设法维护好栈 minStack 的元素，使其保持非严格降序，即可实现 <code>min()</code> 函数的 O(1)复杂度。</p></li></ul><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; dataStack,minStack;</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dataStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        minStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        dataStack.push(x);</span><br><span class="line">       <span class="comment">//如果辅助栈为空 或者 辅助栈的栈顶元素小于当前元素 </span></span><br><span class="line">        <span class="keyword">if</span>(minStack.empty() || minStack.peek() &gt;= x)&#123;</span><br><span class="line">           <span class="comment">//将当前元素压入辅助栈中，保持辅助栈栈顶元素为最小值</span></span><br><span class="line">            minStack.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//Java 中， Stack 中存储的是 int 的包装类 Integer ，需要使用 equals() 代替 == 来比较值是否相等。</span></span><br><span class="line">         <span class="keyword">if</span>(dataStack.pop().equals(minStack.peek()))</span><br><span class="line">            minStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dataStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(1) ： push(), pop(), top(), min() 四个函数的时间复杂度均为常数级别。</li><li>空间复杂度 O(N) ： 当共有 N 个待入栈元素时，辅助栈 minStack 最差情况下存储 N 个元素，使用 O(N) 额外空间。</li></ul><h3 id="其他优秀解答"><a class="markdownIt-Anchor" href="#其他优秀解答"></a> 其他优秀解答</h3><blockquote><p>解题思路</p></blockquote><p>如果当前压入的值比当前最小值，则压入一个当前最小值，再压入当前的值！</p><blockquote><p>代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先压先前最小值</span></span><br><span class="line">        <span class="comment">//再压一个当前最小值，保证最小值一直存在</span></span><br><span class="line">        <span class="keyword">if</span>(x &lt;= min)&#123;</span><br><span class="line">            stack.push(min);</span><br><span class="line">            min = x;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack.pop() == min)&#123;</span><br><span class="line">            min = stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目信息&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#题目信息&quot;&gt;&lt;/a&gt; 题目信息&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;题目：剑指 Offer 30. 包含min函数的栈&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时间： 2020-09-
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://wangqiang.cool/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="栈" scheme="http://wangqiang.cool/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 31. 栈的压入、弹出序列</title>
    <link href="http://wangqiang.cool/2020/09/08/%E5%89%91%E6%8C%87-Offer-31-%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/"/>
    <id>http://wangqiang.cool/2020/09/08/%E5%89%91%E6%8C%87-Offer-31-%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/</id>
    <published>2020-09-08T13:53:07.000Z</published>
    <updated>2020-09-08T14:08:36.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目信息"><a class="markdownIt-Anchor" href="#题目信息"></a> 题目信息</h3><ul><li><p>题目；剑指 Offer 31. 栈的压入、弹出序列</p></li><li><p>时间： 2020-09-08</p></li><li><p>题目链接：<a href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/" target="_blank" rel="noopener">Leetcode</a></p></li><li><p>tag：栈</p></li><li><p>难易程度：中等</p></li><li><p>题目描述：</p><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p></li></ul><p><strong>示例1:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]</span><br><span class="line">输出：true</span><br><span class="line">解释：我们可以按以下顺序执行：</span><br><span class="line">push(1), push(2), push(3), push(4), pop() -&gt; 4,</span><br><span class="line">push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1</span><br></pre></td></tr></table></figure><p><strong>示例2:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]</span><br><span class="line">输出：false</span><br><span class="line">解释：1 不能在 2 之前弹出。</span><br></pre></td></tr></table></figure><blockquote><p>提示</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 0 &lt;= pushed.length == popped.length &lt;= 1000</span><br><span class="line">2. 0 &lt;= pushed[i], popped[i] &lt; 1000</span><br><span class="line">3. pushed 是 popped 的排列。</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><blockquote><p>本题难点</p></blockquote><p>栈的数据操作具有 <strong>先入后出</strong> 的特性，因此某些弹出序列是无法实现的。</p><blockquote><p>具体思路</p></blockquote><p>给定一个压入序列 pushed 和弹出序列 popped ，则压入 / 弹出操作的顺序（即排列）是 唯一确定 的。</p><p>考虑借用一个辅助栈 stack ，模拟 压入 / 弹出操作的排列。根据是否模拟成功，即可得到结果。</p><ul><li><strong>入栈操作</strong>： 按照压栈序列的顺序执行。</li><li><strong>出栈操作</strong>： 每次入栈后，循环判断 “栈顶元素 == 弹出序列的当前元素” 是否成立，将符合弹出序列顺序的栈顶元素全部弹出。</li></ul><blockquote><p>由于题目规定 栈的所有数字均不相等 ，因此在循环入栈中，每个元素出栈的位置的可能性是唯一的（若有重复数字，则具有多个可出栈的位置）。因而，在遇到 “栈顶元素 == 弹出序列的当前元素” 就应立即执行出栈。</p></blockquote><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validateStackSequences</span><span class="params">(<span class="keyword">int</span>[] pushed, <span class="keyword">int</span>[] popped)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pushed == <span class="keyword">null</span> || popped == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//辅助栈stack</span></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">      <span class="comment">//弹出序列的索引 i</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">//遍历压栈序列： 各元素记为nums </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> nums : pushed)&#123;</span><br><span class="line">          <span class="comment">//元素nums入栈 </span></span><br><span class="line">            stack.push(nums);</span><br><span class="line">          <span class="comment">//循环出栈：若stack 的栈顶元素 == 弹出序列元素popped[i] ，则执行出栈与i++ ；</span></span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; popped[i] == stack.peek())&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//若stack 为空，则此弹出序列合法</span></span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(N) ： 其中 <em>N</em> 为列表 pushed 的长度；每个元素最多入栈与出栈一次，即最多共 2<em>N</em> 次出入栈操作。</li><li>空间复杂度 O(N) ： 辅助栈 stack 最多同时存储 <em>N</em> 个元素。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目信息&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#题目信息&quot;&gt;&lt;/a&gt; 题目信息&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;题目；剑指 Offer 31. 栈的压入、弹出序列&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时间： 2020-09-
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://wangqiang.cool/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="栈" scheme="http://wangqiang.cool/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 32 - I. 从上到下打印二叉树</title>
    <link href="http://wangqiang.cool/2020/09/08/%E5%89%91%E6%8C%87-Offer-32-I-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://wangqiang.cool/2020/09/08/%E5%89%91%E6%8C%87-Offer-32-I-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2020-09-08T13:51:51.000Z</published>
    <updated>2020-09-08T14:08:31.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目信息"><a class="markdownIt-Anchor" href="#题目信息"></a> 题目信息</h3><ul><li><p>题目：剑指 Offer 32 - I. 从上到下打印二叉树</p></li><li><p>时间： 2020-09-08</p></li><li><p>题目链接：<a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/" target="_blank" rel="noopener">Leetcode</a></p></li><li><p>tag：BFS（广度优先搜索） 队列</p></li><li><p>难易程度：中等</p></li><li><p>题目描述：</p><p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p></li></ul><p><strong>示例1:</strong></p><p>给定二叉树: [3,9,20,null,null,15,7],</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回：[3,9,20,15,7]</p><blockquote><p>提示</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.节点数量 <span class="tag">&lt;<span class="name">=</span> <span class="attr">1000</span></span></span><br></pre></td></tr></table></figure><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><blockquote><p>本题难点</p></blockquote><p>二叉树的 <strong>从上至下</strong> 打印（即按层打印），又称为二叉树的 <strong>广度优先搜索</strong>（BFS）。</p><blockquote><p>具体思路</p></blockquote><p>BFS 通常借助 <strong>队列</strong> 的先入先出特性来实现。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] levelOrder(TreeNode root) &#123;</span><br><span class="line">      <span class="comment">//当树的根节点为空，则直接返回空列表 [] </span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//包含根节点的队列 queue = [root] </span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">      queue.add(root);</span><br><span class="line">      <span class="comment">//包含答案的ans列表</span></span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      <span class="comment">//BFS 循环： 当队列 queue 为空时跳出</span></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">          <span class="comment">//出队： 队首元素出队，记为 t；</span></span><br><span class="line">            TreeNode t = queue.poll();</span><br><span class="line">          <span class="comment">//打印： 将 t.val 添加至列表 ans 尾部；</span></span><br><span class="line">            ans.add(t.val);</span><br><span class="line">          <span class="comment">//添加子节点： 若t的左（右）子节点不为空，则将左（右）子节点加入队列 queue ；</span></span><br><span class="line">            <span class="keyword">if</span>(t.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                queue.add(t.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(t.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                queue.add(t.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//打印结果数组 res = []</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[ans.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.size(); i++)&#123;</span><br><span class="line">            res[i] = ans.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//返回打印结果数组 res </span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(N) ： <em>N</em> 为二叉树的节点数量，即 BFS 需循环 <em>N</em> 次。</li><li>空间复杂度 O(N) ： 最差情况下，即当树为平衡二叉树时，最多有 N/2 个树节点同时在 queue中，使用 O(N) 大小的额外空间。</li></ul><h3 id="其他优秀解答"><a class="markdownIt-Anchor" href="#其他优秀解答"></a> 其他优秀解答</h3><blockquote><p>解题思路</p></blockquote><p>一般在树相关的题目中都可以考虑递归解法</p><blockquote><p>代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//新建一个临时列表 level ，用于存储所有层的列表</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; level = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="comment">//打印答案列表 res = []</span></span><br><span class="line">    List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] levelOrder(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归调用函数，从第0层开始</span></span><br><span class="line">        recur(root,<span class="number">0</span>); </span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历每层的列表</span></span><br><span class="line">        <span class="keyword">for</span>(List&lt;Integer&gt; levels : level)&#123;</span><br><span class="line">            <span class="comment">//遍历每层的元素</span></span><br><span class="line">            <span class="keyword">for</span>(Integer x : levels)&#123;</span><br><span class="line">                <span class="comment">//将元素添加到答案列表res中</span></span><br><span class="line">                ans.add(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打印结果数组 res = []</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[ans.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.size(); i++)&#123;</span><br><span class="line">            res[i] = ans.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recur</span><span class="params">(TreeNode root,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//如果列表层数小于二叉树的层数，新增当前层的列表</span></span><br><span class="line">            <span class="keyword">if</span>(level.size() &lt;= k)&#123;</span><br><span class="line">                level.add(<span class="keyword">new</span> ArrayList());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将当前层的元素添加到当前层列表中     </span></span><br><span class="line">            level.get(k).add(root.val);</span><br><span class="line">            <span class="comment">//递归调用二叉树的左子树，层数+1</span></span><br><span class="line">            recur(root.left,k+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//递归调用二叉树的右子树，层数+1</span></span><br><span class="line">            recur(root.right,k+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目信息&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#题目信息&quot;&gt;&lt;/a&gt; 题目信息&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;题目：剑指 Offer 32 - I. 从上到下打印二叉树&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时间： 2020
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://wangqiang.cool/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="队列" scheme="http://wangqiang.cool/tags/%E9%98%9F%E5%88%97/"/>
    
      <category term="广度优先搜索" scheme="http://wangqiang.cool/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 32 - II. 从上到下打印二叉树 II</title>
    <link href="http://wangqiang.cool/2020/09/08/%E5%89%91%E6%8C%87-Offer-32-II-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91-II/"/>
    <id>http://wangqiang.cool/2020/09/08/%E5%89%91%E6%8C%87-Offer-32-II-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91-II/</id>
    <published>2020-09-08T13:49:40.000Z</published>
    <updated>2020-09-08T14:08:23.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目信息"><a class="markdownIt-Anchor" href="#题目信息"></a> 题目信息</h3><ul><li><p>题目：剑指 Offer 32 - II. 从上到下打印二叉树 II</p></li><li><p>时间： 2020-09-08</p></li><li><p>题目链接：<a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/" target="_blank" rel="noopener">Leetcode</a></p></li><li><p>tag：  队列  BFS</p></li><li><p>难易程度：简单</p></li><li><p>题目描述：</p><p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p></li></ul><p><strong>示例1:</strong></p><p>给定二叉树: <code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回其层次遍历结果：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><blockquote><p>提示</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.节点总数 <span class="tag">&lt;<span class="name">=</span> <span class="attr">1000</span></span></span><br></pre></td></tr></table></figure><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><blockquote><p>本题难点</p></blockquote><p>题目要求的二叉树的 <strong>从上至下</strong> 打印（即按层打印），又称为二叉树的 <strong>广度优先搜索</strong>（BFS）</p><blockquote><p>具体思路</p></blockquote><p>BFS 通常借助 <strong>队列</strong> 的先入先出特性来实现。</p><ul><li><strong>每层打印到一行</strong>：将本层全部节点打印到一行，并将下一层全部节点加入队列，以此类推，即可分为多行打印。</li></ul><blockquote></blockquote><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">      <span class="comment">//当根节点为空，则返回空列表 [] </span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//打印结果列表 res = []</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      <span class="comment">//包含根节点的队列 queue = [root]</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">      <span class="comment">//BFS 循环： 当队列 queue 为空时跳出</span></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">          <span class="comment">//新建一个临时列表 ans ，用于存储当前层打印结果</span></span><br><span class="line">            List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">          <span class="comment">//当前层打印循环： 循环次数为当前层节点数（即队列 queue 长度）；</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = queue.size(); i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">              <span class="comment">//出队： 队首元素出队，记为 t</span></span><br><span class="line">                TreeNode t = queue.poll();</span><br><span class="line">              <span class="comment">//打印： 将 t.val 添加至 ans 尾部</span></span><br><span class="line">                ans.add(t.val);</span><br><span class="line">              <span class="comment">//添加子节点： 若 node 的左（右）子节点不为空，则将左（右）子节点加入队列 queue </span></span><br><span class="line">                <span class="keyword">if</span>(t.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.add(t.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(t.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.add(t.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">//将当前层结果 tmp 添加入 res </span></span><br><span class="line">            res.add(ans);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//返回打印结果列表 res 即可</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(<em>N</em>) ：<em>N</em> 为二叉树的节点数量，即 BFS 需循环 <em>N</em> 次。</li><li>空间复杂度 O(<em>N</em>) ： 最差情况下，即当树为平衡二叉树时，最多有 <em>N</em>/2 个树节点同时在 队列queue 中，使用 O(<em>N</em>) 大小的额外空间。</li></ul><h3 id="其他优秀解答"><a class="markdownIt-Anchor" href="#其他优秀解答"></a> 其他优秀解答</h3><blockquote><p>解题思路</p></blockquote><p>一般在树相关的题目中都可以考虑递归解法</p><blockquote><p>代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="comment">//输出结果列表res ，用于存储所有层的列表</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root)&#123;</span><br><span class="line">        <span class="comment">//递归调用函数，从第0层开始</span></span><br><span class="line">      recur(root,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recur</span><span class="params">(TreeNode root,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">          <span class="comment">//如果列表层数小于二叉树的层数，新增当前层的列表</span></span><br><span class="line">            <span class="keyword">if</span>(res.size() &lt;= k)&#123;</span><br><span class="line">              res.add(<span class="keyword">new</span> ArrayList());</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">//将当前层的元素添加到当前层列表中   </span></span><br><span class="line">            res.get(k).add(root.val);</span><br><span class="line">          <span class="comment">//递归调用二叉树的左子树，层数+1</span></span><br><span class="line">            recur(root.left,k+<span class="number">1</span>);</span><br><span class="line">          <span class="comment">//递归调用二叉树的右子树，层数+1</span></span><br><span class="line">            recur(root.right,k+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目信息&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#题目信息&quot;&gt;&lt;/a&gt; 题目信息&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;题目：剑指 Offer 32 - II. 从上到下打印二叉树 II&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时间： 
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://wangqiang.cool/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="队列" scheme="http://wangqiang.cool/tags/%E9%98%9F%E5%88%97/"/>
    
      <category term="广度优先搜索" scheme="http://wangqiang.cool/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 32 - III. 从上到下打印二叉树 III</title>
    <link href="http://wangqiang.cool/2020/09/08/%E5%89%91%E6%8C%87-Offer-32-III-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91-III/"/>
    <id>http://wangqiang.cool/2020/09/08/%E5%89%91%E6%8C%87-Offer-32-III-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91-III/</id>
    <published>2020-09-08T13:47:46.000Z</published>
    <updated>2020-09-08T14:08:16.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目信息"><a class="markdownIt-Anchor" href="#题目信息"></a> 题目信息</h3><ul><li><p>题目：剑指 Offer 32 - III. 从上到下打印二叉树 III</p></li><li><p>时间： 2020-09-08</p></li><li><p>题目链接：<a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/" target="_blank" rel="noopener">Leetcode</a></p></li><li><p>tag：双端队列 队列</p></li><li><p>难易程度：中等</p></li><li><p>题目描述：</p><p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p></li></ul><p><strong>示例1:</strong></p><p>给定二叉树: <code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回其层次遍历结果：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [20,9],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><blockquote><p>提示</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.节点总数 <span class="tag">&lt;<span class="name">=</span> <span class="attr">1000</span></span></span><br></pre></td></tr></table></figure><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><blockquote><p>本题难点</p></blockquote><p>二叉树层序遍历，每层遍历顺序都发生变化，奇数层逆序</p><blockquote><p>具体思路</p></blockquote><p>层序遍历 + 双端队列</p><ul><li><strong>操作</strong>：利用双端队列的两端皆可添加元素的特性，设打印列表（双端队列） <code>level</code> ，并规定<ul><li>奇数层 则添加至 <code>level</code> <strong>尾部</strong></li><li>偶数层 则添加至 <code>level</code> <strong>头部</strong></li></ul></li></ul><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">      <span class="comment">//当树的根节点为空，则直接返回空列表 []</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//打印结果空列表 res</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      <span class="comment">//包含根节点的双端队列 queue </span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">      <span class="comment">//BFS 循环： 当 queue 为空时跳出；</span></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">          <span class="comment">//新建列表 level ，用于临时存储当前层打印结果；</span></span><br><span class="line">            LinkedList&lt;Integer&gt; level = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">          <span class="comment">//当前层打印循环： 循环次数为当前层节点数（即 queue 长度）</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = queue.size(); i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">              <span class="comment">//出队： 队首元素出队，记为 node</span></span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">              <span class="comment">//打印： 若为奇数层，将 node.val 添加至 level 尾部；否则，添加至 level 头部；</span></span><br><span class="line">                <span class="keyword">if</span>(res.size() % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                    level.addLast(node.val);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    level.addFirst(node.val);</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="comment">//添加子节点： 若 node 的左（右）子节点不为空，则加入队列queue；</span></span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.add(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.add(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">//将当前层结果列表level 并添加入结果列表 res中</span></span><br><span class="line">            res.add(level);   </span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//返回打印结果列表 res 即可</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(<em>N</em>) ： N 为二叉树的节点数量，BFS 需循环 <em>N</em> 次，占用 O(<em>N</em>) ；双端队列的队首和队尾的添加和删除操作的时间复杂度均为 O(1) 。</li><li>空间复杂度 O(<em>N</em>) ： 最差情况下，即当树为满二叉树时，最多有 <em>N</em>/2 个树节点 <strong>同时</strong> 在 <code>queue</code> 中，使用 O(<em>N</em>)大小的额外空间。</li></ul><h3 id="其他优秀解答"><a class="markdownIt-Anchor" href="#其他优秀解答"></a> 其他优秀解答</h3><blockquote><p>解题思路</p></blockquote><p>一般在树相关的题目中都可以考虑递归解法</p><blockquote><p>代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//新建一个临时列表 level ，用于存储所有层的列表</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        <span class="comment">//当根节点为空，则返回空列表 [] </span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归调用函数，从第0层开始</span></span><br><span class="line">        recur(root,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recur</span><span class="params">(TreeNode root,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//如果列表层数小于二叉树的层数，新增当前层的列表</span></span><br><span class="line">            <span class="keyword">if</span>(res.size() &lt;= k)&#123;</span><br><span class="line">                res.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将当前层的元素添加到当前层列表中,层数为奇数时采用逆序</span></span><br><span class="line">            <span class="keyword">if</span>((k &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">                res.get(k).add(<span class="number">0</span>,root.val);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res.get(k).add(root.val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//递归调用二叉树的左子树，层数+1</span></span><br><span class="line">            recur(root.left,k+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//递归调用二叉树的右子树，层数+1</span></span><br><span class="line">            recur(root.right,k+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目信息&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#题目信息&quot;&gt;&lt;/a&gt; 题目信息&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;题目：剑指 Offer 32 - III. 从上到下打印二叉树 III&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时间
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://wangqiang.cool/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="队列" scheme="http://wangqiang.cool/tags/%E9%98%9F%E5%88%97/"/>
    
      <category term="双端队列" scheme="http://wangqiang.cool/tags/%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 33. 二叉搜索树的后序遍历序列</title>
    <link href="http://wangqiang.cool/2020/09/08/%E5%89%91%E6%8C%87-Offer-33-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/"/>
    <id>http://wangqiang.cool/2020/09/08/%E5%89%91%E6%8C%87-Offer-33-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/</id>
    <published>2020-09-08T13:45:46.000Z</published>
    <updated>2020-09-08T14:06:57.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目信息"><a class="markdownIt-Anchor" href="#题目信息"></a> 题目信息</h3><ul><li><p>题目：剑指 Offer 33. 二叉搜索树的后序遍历序列</p></li><li><p>时间： 2020-09-08</p></li><li><p>题目链接：<a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/" target="_blank" rel="noopener">Leetcode</a></p></li><li><p>tag：分治算法 递归</p></li><li><p>难易程度：中等</p></li><li><p>题目描述：</p><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 <code>true</code>，否则返回 <code>false</code>。假设输入的数组的任意两个数字都互不相同。</p></li></ul><p><strong>参考如下:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  2   6</span><br><span class="line"> / \</span><br><span class="line">1   3</span><br></pre></td></tr></table></figure><p><strong>示例1:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,6,3,2,5]</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>示例2:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,2,6,5]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><blockquote><p>提示</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.数组长度<span class="tag">&lt;<span class="name">=1000</span></span></span><br></pre></td></tr></table></figure><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><blockquote><p>本题难点</p></blockquote><ul><li><strong>后序遍历定义</strong>： [ 左子树 | 右子树 | 根节点 ] ，即遍历顺序为 “左、右、根” 。</li><li><strong>二叉搜索树定义</strong>： 左子树中所有节点的值&lt; 根节点的值；右子树中所有节点的值 &lt;根节点的值；其左、右子树也分别为二叉搜索树。</li></ul><blockquote><p>具体思路</p></blockquote><p>根据二叉搜索树的定义，可以通过递归，判断所有子树的 <strong>正确性</strong> （即其后序遍历是否满足二叉搜索树的定义） ，若所有子树都正确，则此序列为二叉搜索树的后序遍历。</p><ul><li><p><strong>终止条件</strong>：当 <em>i</em>≥<em>j</em> ，说明此子树节点数量 ≤1 ，无需判别正确性，因此直接返回 true ；</p></li><li><p><strong>递推工作</strong>：</p><ul><li><p><strong>划分左右子树</strong>:遍历后序遍历的 [i,j] 区间元素，寻找 第一个大于根节点 的节点，索引记为<br />m。此时，可划分出左子树区间[i,m−1] 、右子树区间[m,j−1] 、根节点索引 j</p></li><li><p><strong>判断是否为二叉搜索树</strong></p><p><strong>左子树区间</strong>[i,m−1] 内的所有节点都应 &lt;postorder[j] 。而第 1.划分左右子树 步骤已经保证左子树区间的正确性，因此只需要判断右子树区间即可。</p><p><strong>右子树区间</strong>[m,j−1] 内的所有节点都应postorder&gt;[j] 。实现方式为遍历，当遇到 ≤postorder[j] 的节点则跳出；则可通过p=j 判断是否为二叉搜索树。</p></li></ul></li></ul><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verifyPostorder</span><span class="params">(<span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> recur(postorder,<span class="number">0</span>,postorder.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">recur</span><span class="params">(<span class="keyword">int</span>[] postorder,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">      <span class="comment">//当 i≥j ，说明此子树节点数量 ≤1 ，无需判别正确性，因此直接返回 true</span></span><br><span class="line">        <span class="keyword">if</span>(left &gt; right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//划分左右子树</span></span><br><span class="line">        <span class="keyword">int</span> p = left;</span><br><span class="line">      <span class="comment">//划分出左子树区间[i,m−1] </span></span><br><span class="line">        <span class="keyword">while</span>(postorder[p] &lt; postorder[right])&#123;</span><br><span class="line">            p++;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//寻找第一个大于根节点的节点，索引记为 m</span></span><br><span class="line">        <span class="keyword">int</span> m = p;</span><br><span class="line">      <span class="comment">//右子树区间[m,j−1] </span></span><br><span class="line">        <span class="keyword">while</span>(postorder[p] &gt; postorder[right])&#123;</span><br><span class="line">            p++;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//左子树区间[i,m−1] 内的所有节点都应 &lt;postorder[j] </span></span><br><span class="line">      <span class="comment">//右子树区间[m,j−1] 内的所有节点都应postorder[j] </span></span><br><span class="line">        <span class="keyword">return</span> p == right &amp;&amp; recur(postorder,left,m-<span class="number">1</span>) &amp;&amp; recur(postorder,m,right-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(<em>N^2</em>) ： 每次调用 recur(i,j) 减去一个根节点，因此递归占用 O(N) ；最差情况下（即当树退化为链表），每轮递归都需遍历树所有节点，占用 O(N) 。</li><li>空间复杂度 O(<em>N</em>) ： 最差情况下（即当树退化为链表），递归深度将达到 <em>N</em> 。</li></ul><h3 id="其他优秀解答"><a class="markdownIt-Anchor" href="#其他优秀解答"></a> 其他优秀解答</h3><blockquote><p>解题思路</p></blockquote><p>辅助单调栈，后序遍历倒序： [ 根节点 | 右子树 | 左子树 ] 。类似 先序遍历的镜像 ，即先序遍历为 “根、左、右” 的顺序，而后序遍历的倒序为 “根、右、左” 顺序。</p><ul><li><p>为什么要用单调栈呢，因为往右子树遍历的过程，value是越来越大的，一旦出现了value小于栈顶元素value的时候，就表示要开始进入左子树了。</p></li><li><p>单调栈帮我们记录了这些节点，只要栈顶元素还比当前节点大，就表示还是右子树，要移除，因为我们要找到这个左孩子节点直接连接的父节点，也就是找到这个子树的根，只要栈顶元素还大于当前节点，就要一直弹出，直到栈顶元素小于节点，或者栈为空。栈顶的上一个元素就是子树节点的根。</p></li><li><p>接下来，数组继续往前遍历，之后的左子树的每个节点，都要比子树的根要小，才能满足二叉搜索树，否则就不是二叉搜索树。</p></li></ul><blockquote><p>代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verifyPostorder</span><span class="params">(<span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 单调栈使用，单调递增的单调栈</span></span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 表示上一个根节点的元素，这里可以把postorder的最后一个元素root看成无穷大节点的左孩子</span></span><br><span class="line">        <span class="keyword">int</span> pervElem = Integer.MAX_VALUE;</span><br><span class="line">        <span class="comment">// 逆向遍历，就是翻转的先序遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = postorder.length - <span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="comment">// 左子树元素必须要小于递增栈被peek访问的元素，否则就不是二叉搜索树</span></span><br><span class="line">            <span class="keyword">if</span> (postorder[i] &gt; pervElem)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; postorder[i] &lt; stack.peek())&#123;</span><br><span class="line">                <span class="comment">// 数组元素小于单调栈的元素了，表示往左子树走了，记录下上个根节点</span></span><br><span class="line">                <span class="comment">// 找到这个左子树对应的根节点，之前右子树全部弹出，不再记录，因为不可能在往根节点的右子树走了</span></span><br><span class="line">                pervElem = stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 这个新元素入栈</span></span><br><span class="line">            stack.push(postorder[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目信息&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#题目信息&quot;&gt;&lt;/a&gt; 题目信息&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;题目：剑指 Offer 33. 二叉搜索树的后序遍历序列&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时间： 2020-
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://wangqiang.cool/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="分治法" scheme="http://wangqiang.cool/tags/%E5%88%86%E6%B2%BB%E6%B3%95/"/>
    
      <category term="递归" scheme="http://wangqiang.cool/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 34. 二叉树中和为某一值的路径</title>
    <link href="http://wangqiang.cool/2020/09/07/%E5%89%91%E6%8C%87-Offer-34-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
    <id>http://wangqiang.cool/2020/09/07/%E5%89%91%E6%8C%87-Offer-34-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/</id>
    <published>2020-09-07T13:43:52.000Z</published>
    <updated>2020-09-08T14:06:50.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目信息"><a class="markdownIt-Anchor" href="#题目信息"></a> 题目信息</h3><ul><li><p>题目：剑指 Offer 34. 二叉树中和为某一值的路径</p></li><li><p>时间： 2020-09-07</p></li><li><p>题目链接：<a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/" target="_blank" rel="noopener">Leetcode</a></p></li><li><p>tag：深度优先搜索 回溯法</p></li><li><p>难易程度：中等</p></li><li><p>题目描述：</p><p>输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。</p></li></ul><p><strong>示例:</strong></p><p>给定如下二叉树，以及目标和 <code>sum = 22</code>，</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      5</span><br><span class="line">     / \</span><br><span class="line">    4   8</span><br><span class="line">   /   / \</span><br><span class="line">  11  13  4</span><br><span class="line"> /  \    / \</span><br><span class="line">7    2  5   1</span><br></pre></td></tr></table></figure><p>返回：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">   [5,4,11,2],</span><br><span class="line">   [5,8,4,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><blockquote><p>提示</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.节点总数<span class="tag">&lt;<span class="name">=10000</span></span></span><br></pre></td></tr></table></figure><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><blockquote><p>本题难点</p></blockquote><p>本问题是典型的二叉树方案搜索问题，使用回溯法解决，其包含 <strong>先序遍历 + 路径记录</strong> 两部分。</p><blockquote><p>具体思路</p></blockquote><ul><li><strong>先序遍历</strong>：按照 “根、左、右” 的顺序，遍历树的所有节点。</li><li><strong>路径记录</strong>： 在先序遍历中，记录从根节点到当前节点的路径。当路径为 ① 根节点到叶节点形成的路径 <strong>且</strong> ② 各节点值的和等于目标值 <code>sum</code> 时，将此路径加入结果列表。</li></ul><blockquote><p>值得注意的是，记录路径时若直接执行 res.append(path) ，则是将 path 对象加入了 res ；后续 path 改变时， res 中的 path 对象也会随之改变。</p></blockquote><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="comment">//结果列表 res</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  <span class="comment">//路径列表 path</span></span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;(); </span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">        recur(root,sum);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recur</span><span class="params">(TreeNode root,<span class="keyword">int</span> tar)</span></span>&#123;</span><br><span class="line">      <span class="comment">//终止条件： 若节点 root 为空，则直接返回。</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//路径更新： 将当前节点值 root.val 加入路径 path </span></span><br><span class="line">        path.add(root.val);</span><br><span class="line">      <span class="comment">//目标值更新： tar = tar - root.val（即目标值 tar 从 sum 减至 0 ）；</span></span><br><span class="line">        tar -= root.val;</span><br><span class="line">      <span class="comment">//路径记录： 当 ① root 为叶节点 且 ② 路径和等于目标值 ，则将此路径 path 加入 res 。</span></span><br><span class="line">        <span class="keyword">if</span>(tar == <span class="number">0</span> &amp;&amp; root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> LinkedList(path));</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//先序遍历： 递归左 / 右子节点。</span></span><br><span class="line">        recur(root.left,tar);</span><br><span class="line">        recur(root.right,tar);</span><br><span class="line">      <span class="comment">//路径恢复： 向上回溯前，需要将当前节点从路径 path 中删除，即执行 path.removeLast() 。</span></span><br><span class="line">        path.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(<em>N</em>) ： <em>N</em> 为二叉树的节点数，先序遍历需要遍历所有节点。</li><li>空间复杂度 O(<em>N</em>) ： 最差情况下，即树退化为链表时，<code>path</code> 存储所有树节点，使用 O(<em>N</em>) 额外空间。</li></ul><h3 id=""><a class="markdownIt-Anchor" href="#"></a> </h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目信息&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#题目信息&quot;&gt;&lt;/a&gt; 题目信息&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;题目：剑指 Offer 34. 二叉树中和为某一值的路径&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时间： 2020-
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://wangqiang.cool/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="回溯法" scheme="http://wangqiang.cool/tags/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    
      <category term="深度优先搜索" scheme="http://wangqiang.cool/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 35. 复杂链表的复制</title>
    <link href="http://wangqiang.cool/2020/09/06/%E5%89%91%E6%8C%87-Offer-35-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/"/>
    <id>http://wangqiang.cool/2020/09/06/%E5%89%91%E6%8C%87-Offer-35-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/</id>
    <published>2020-09-06T13:41:28.000Z</published>
    <updated>2020-09-08T14:06:35.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目信息"><a class="markdownIt-Anchor" href="#题目信息"></a> 题目信息</h3><ul><li><p>题目：剑指 Offer 35. 复杂链表的复制</p></li><li><p>时间： 2020-09-06</p></li><li><p>题目链接：<a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/" target="_blank" rel="noopener">Leetcode</a></p></li><li><p>tag： 链表</p></li><li><p>难易程度：中等</p></li><li><p>题目描述：</p><p>请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。</p></li></ul><p><strong>示例1:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br><span class="line">输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br></pre></td></tr></table></figure><p><strong>示例2:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [[1,1],[2,1]]</span><br><span class="line">输出：[[1,1],[2,1]]</span><br></pre></td></tr></table></figure><blockquote><p>提示</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.-10000 &lt;= Node.val &lt;= 10000</span><br><span class="line">2.Node.random为null或指向链表中的节点</span><br><span class="line">3.节点数目不超过1000</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><blockquote><p>本题难点</p></blockquote><p>本题的意思是复制一个链表并返回，这个链表与一般链表不同的是多了一个 <code>random</code> 指针。</p><blockquote><p>具体思路</p></blockquote><p>这个复制过程可以分成两步：第一步是复制原始链表上的每个节点，并用next指针相连; 第二步是设置每个节点的random指针。</p><ul><li><strong>复制节点</strong>：将原始链表的任意节点 N复制为新节点N’,再把N’连接到 N的后面。即如果原始链表为A-&gt;B-&gt;C-&gt;D 则复制过后为A-&gt;A’-&gt;B-&gt;B’-&gt;C-&gt;C’-&gt;D-&gt;D’</li><li><strong>建立random连接</strong>： 如果原始链表上的节点 N 的random指针指向节点S,则它对应的复制节点N’的random指针指向节点S的复制节点S’,也就是当前节点S的下一个节点。</li><li><strong>拆分链表</strong>：把这个长链表拆分成两个链表,把奇数位置的节点连接起来就是原始链表,把偶数位置的节点连接起来就是复制出来的链表。</li></ul><blockquote></blockquote><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node next;</span></span><br><span class="line"><span class="comment">    Node random;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">        this.next = null;</span></span><br><span class="line"><span class="comment">        this.random = null;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//插入新节点</span></span><br><span class="line">        Node cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            Node clone = <span class="keyword">new</span> Node(cur.val);</span><br><span class="line">            clone.next = cur.next;</span><br><span class="line">            cur.next = clone;</span><br><span class="line">            cur = clone.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//建立random链接</span></span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            Node clone = cur.next;</span><br><span class="line">            <span class="keyword">if</span>(cur.random != <span class="keyword">null</span>)&#123;</span><br><span class="line">                clone.random = cur.random.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = clone.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//拆分</span></span><br><span class="line">        cur = head;</span><br><span class="line">        Node cloneHead = head.next;</span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            Node next = cur.next;</span><br><span class="line">            cur.next = next.next;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cloneHead;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(<em>N</em>) ： 链表长度为N，遍历所需时间。</li><li>空间复杂度 O(1) ：没有使用额外的空间保存已保存的节点。</li></ul><h3 id="其他优秀解答"><a class="markdownIt-Anchor" href="#其他优秀解答"></a> 其他优秀解答</h3><blockquote><p>解题思路</p></blockquote><p>1.创建HashMap<br />2.复制结点值<br />3.复制指向（next,random）</p><blockquote><p>代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node next;</span></span><br><span class="line"><span class="comment">    Node random;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">        this.next = null;</span></span><br><span class="line"><span class="comment">        this.random = null;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123; <span class="comment">//HashMap实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Node,Node&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">//创建HashMap集合</span></span><br><span class="line">        Node cur=head;</span><br><span class="line">        <span class="comment">//复制结点值</span></span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//存储put:&lt;key,value1&gt;</span></span><br><span class="line">            map.put(cur,<span class="keyword">new</span> Node(cur.val)); <span class="comment">//顺序遍历，存储老结点和新结点(先存储新创建的结点值)</span></span><br><span class="line">            cur=cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//复制结点指向</span></span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//得到get:&lt;key&gt;.value2,3</span></span><br><span class="line">            map.get(cur).next = map.get(cur.next); <span class="comment">//新结点next指向同旧结点的next指向</span></span><br><span class="line">            map.get(cur).random = map.get(cur.random); <span class="comment">//新结点random指向同旧结点的random指向</span></span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回复制的链表</span></span><br><span class="line">        <span class="keyword">return</span> map.get(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目信息&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#题目信息&quot;&gt;&lt;/a&gt; 题目信息&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;题目：剑指 Offer 35. 复杂链表的复制&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时间： 2020-09-06
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://wangqiang.cool/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="链表" scheme="http://wangqiang.cool/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 36. 二叉搜索树与双向链表</title>
    <link href="http://wangqiang.cool/2020/09/05/%E5%89%91%E6%8C%87-Offer-36-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    <id>http://wangqiang.cool/2020/09/05/%E5%89%91%E6%8C%87-Offer-36-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</id>
    <published>2020-09-05T02:17:51.000Z</published>
    <updated>2020-09-08T14:06:28.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目信息"><a class="markdownIt-Anchor" href="#题目信息"></a> 题目信息</h3><ul><li><p>题目：剑指 Offer 36. 二叉搜索树与双向链表</p></li><li><p>时间： 2020-09-05</p></li><li><p>题目链接：<a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/" target="_blank" rel="noopener">Leetcode</a></p></li><li><p>tag：  二叉搜索树 中序遍历 递归 深度优先搜索</p></li><li><p>难易程度：中等</p></li><li><p>题目描述：</p><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</p></li></ul><p><strong>示例:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    4</span><br><span class="line">   / \</span><br><span class="line">  2   5</span><br><span class="line"> / \   </span><br><span class="line">1  3</span><br></pre></td></tr></table></figure><p>我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。</p><blockquote><p>提示</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><blockquote><p>本题难点</p></blockquote><p>二叉搜索树 转换成一个 “排序的循环双向链表” ，其中包含三个要素：</p><ul><li><p><strong>排序链表</strong>： 节点应从小到大排序，因此应使用 <strong>中序遍历</strong> “从小到大”访问树的节点；</p></li><li><p><strong>双向链表</strong>： 在构建相邻节点（设前驱节点 pre ，当前节点 cur ）关系时，不仅应 pre.right=cur ，也应 cur.left=pre 。</p></li><li><p><strong>循环链表</strong>： 设链表头节点 head 和尾节点 tail ，则应构建 head.left=tail 和 tail.right=head 。</p></li></ul><blockquote><p>具体思路</p></blockquote><p>二叉搜索树的中序遍历为 <strong>递增序列</strong> 。</p><ul><li><p><strong>中序遍历</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    dfs(root.left); <span class="comment">// 左</span></span><br><span class="line">    System.out.println(root.val); <span class="comment">// 根</span></span><br><span class="line">    dfs(root.right); <span class="comment">// 右</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>根据以上分析，考虑使用中序遍历访问树的各节点 cur ；并在访问每个节点时构建 cur 和前驱节点 pre 的引用指向；中序遍历完成后，最后构建头节点和尾节点的引用指向即可。</p></blockquote><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public Node left;</span></span><br><span class="line"><span class="comment">    public Node right;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val,Node _left,Node _right) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        left = _left;</span></span><br><span class="line"><span class="comment">        right = _right;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//pre本来是前序节点，随着中序遍历，最终会成为中序遍历的尾节点</span></span><br><span class="line">    <span class="comment">//head指向中序遍历的头节点</span></span><br><span class="line">    Node pre,head;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">treeToDoublyList</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//深度优先搜索二叉搜索树</span></span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="comment">//将头节点head的左指针指向尾节点pre</span></span><br><span class="line">        head.left = pre;</span><br><span class="line">        <span class="comment">//将尾节点pre的左指针指向头节点head</span></span><br><span class="line">        pre.right = head;</span><br><span class="line">        <span class="comment">//返回结果</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node cur)</span></span>&#123;</span><br><span class="line">      <span class="comment">//终止条件： 当节点 cur 为空，代表越过叶节点，直接返回；</span></span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归遍历左子树</span></span><br><span class="line">        dfs(cur.left);</span><br><span class="line">        <span class="comment">//当前节点cur不存在左子树时，此时cur无前驱节点，即前驱节点pre==null，cur为中序遍历的第一个节点</span></span><br><span class="line">        <span class="keyword">if</span>(pre == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//将中序遍历的头节点cur赋予双向链表的头节点head</span></span><br><span class="line">            head = cur;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//当前节点cur存在前置节点pre,将pre的右指针指向cur</span></span><br><span class="line">            pre.right = cur;</span><br><span class="line">            <span class="comment">//当前节点cur存在前驱节点pre,将cur的左指针指向pre，形成双向链表</span></span><br><span class="line">        cur.left = pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将前驱节点pre后移，保存当前节点cur</span></span><br><span class="line">        pre = cur;</span><br><span class="line">        <span class="comment">//递归遍历右子树</span></span><br><span class="line">        dfs(cur.right); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(<em>N</em>) ：  <em>N</em> 为二叉树的节点数，中序遍历需要访问所有节点。</li><li>空间复杂度 O(<em>N</em>) ：  最差情况下，即树退化为链表时，递归深度达到 <em>N</em>，系统使用 O(<em>N</em>) 栈空间。</li></ul><h3 id="其他优秀解答"><a class="markdownIt-Anchor" href="#其他优秀解答"></a> 其他优秀解答</h3><blockquote><p>解题思路</p></blockquote><p>中序遍历的非递归，使用栈的<strong>先进后出</strong>特性。</p><blockquote><p>代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">treeToDoublyList</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">  <span class="comment">//用栈实现</span></span><br><span class="line">         Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">         Node current = root;</span><br><span class="line">         Node pre = <span class="keyword">null</span>, head = <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">while</span>(!stack.isEmpty() || current != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">//内层循环将当前数据入栈</span></span><br><span class="line">             <span class="keyword">while</span>(current != <span class="keyword">null</span>) &#123;</span><br><span class="line">                 stack.push(current);</span><br><span class="line">                 current = current.left;</span><br><span class="line">             &#125;</span><br><span class="line">           <span class="comment">//出栈并将该元素放入到链表中</span></span><br><span class="line">             current = stack.pop();</span><br><span class="line">             <span class="keyword">if</span>(pre == <span class="keyword">null</span>) &#123;<span class="comment">//处理头结点</span></span><br><span class="line">                 head = current;</span><br><span class="line">             &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                 pre.right = current;</span><br><span class="line">                 current.left = pre;</span><br><span class="line">             &#125;</span><br><span class="line">            pre = current;</span><br><span class="line">           <span class="comment">////将cur指向栈顶元素的右孩子</span></span><br><span class="line">            current = current.right;</span><br><span class="line">         &#125;</span><br><span class="line">         pre.right = head;</span><br><span class="line">         head.left = pre;</span><br><span class="line">         <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目信息&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#题目信息&quot;&gt;&lt;/a&gt; 题目信息&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;题目：剑指 Offer 36. 二叉搜索树与双向链表&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时间： 2020-09
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://wangqiang.cool/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="递归" scheme="http://wangqiang.cool/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="深度优先搜索" scheme="http://wangqiang.cool/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
      <category term="二叉树" scheme="http://wangqiang.cool/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="二叉搜索树" scheme="http://wangqiang.cool/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
      <category term="中序遍历" scheme="http://wangqiang.cool/tags/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 37. 序列化二叉树</title>
    <link href="http://wangqiang.cool/2020/09/04/%E5%89%91%E6%8C%87-Offer-37-%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://wangqiang.cool/2020/09/04/%E5%89%91%E6%8C%87-Offer-37-%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2020-09-04T02:15:19.000Z</published>
    <updated>2020-09-08T14:06:20.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目信息"><a class="markdownIt-Anchor" href="#题目信息"></a> 题目信息</h3><ul><li><p>题目： 剑指 Offer 37. 序列化二叉树</p></li><li><p>时间： 2020-09-04</p></li><li><p>题目链接：<a href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/" target="_blank" rel="noopener">Leetcode</a></p></li><li><p>tag：序列化  二叉树  队列</p></li><li><p>难易程度：中等</p></li><li><p>题目描述：</p><p>请实现两个函数，分别用来序列化和反序列化二叉树。</p></li></ul><p><strong>示例:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2   3</span><br><span class="line">   / \</span><br><span class="line">  4   5</span><br></pre></td></tr></table></figure><p>序列化为 “[1,2,3,null,null,4,5]”</p><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><blockquote><p>本题难点</p></blockquote><p>题目要求的 “序列化” 和 “反序列化” 是 <strong>可逆</strong> 操作。因此，序列化的字符串应携带 “完整的” 二叉树信息，即拥有单独表示二叉树的能力。</p><blockquote><p>具体思路</p></blockquote><p>序列化的字符串实际上是二叉树的 “层序遍历”（BFS）结果。为使反序列化可行，考虑将越过叶节点后的 null 也看作是节点。</p><ul><li>**序列化 serialize **：借助队列，对二叉树做层序遍历，并将越过叶节点的 null 也打印出来。</li><li>**反序列化 deserialize **：利用队列按层构建二叉树，借助一个指针 i 指向节点 node 的左、右子节点，每构建一个 node 的左、右子节点，指针 i 就向右移动 1 位。</li></ul><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//若 root 为空，则直接返回空列表 "[]" ；</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"[]"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//队列 queue （包含根节点 root ）</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">      <span class="comment">//序列化列表 res </span></span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder(<span class="string">"["</span>);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">          <span class="comment">//节点出队，记为 node ；</span></span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            <span class="keyword">if</span>(node != <span class="keyword">null</span>)&#123;<span class="comment">//若 node 不为空：打印字符串 node.val ，</span></span><br><span class="line">                res.append(node.val).append(<span class="string">","</span>);</span><br><span class="line">              <span class="comment">//将左、右子节点加入 queue </span></span><br><span class="line">                queue.add(node.left);</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//否则（若 node 为空）：打印字符串 "null"</span></span><br><span class="line">                res.append(<span class="string">"null"</span>).append(<span class="string">","</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//拼接列表（去除最后一个节点后的 ',' 隔开，首尾添加中括号）</span></span><br><span class="line">        res.deleteCharAt(res.length() - <span class="number">1</span>);</span><br><span class="line">        res.append(<span class="string">"]"</span>);</span><br><span class="line">      <span class="comment">//返回序列化结果</span></span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 若 data 为空，直接返回 null ；</span></span><br><span class="line">        <span class="keyword">if</span>(data == <span class="string">"[]"</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//序列化列表 value （先去掉首尾中括号，再用逗号隔开）</span></span><br><span class="line">        String[] value = data.substring(<span class="number">1</span>,data.length() - <span class="number">1</span>).split(<span class="string">","</span>);</span><br><span class="line">      <span class="comment">//根节点 root （值为 vals[0] ）</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(Integer.parseInt(value[<span class="number">0</span>]));</span><br><span class="line">      <span class="comment">//队列 queue（包含 root ）</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">      <span class="comment">//指针i</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">          <span class="comment">//节点出队，记为 node ；</span></span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">          <span class="comment">//构建 node 的左子节点：node.left 的值为 value[i] ，并将 node.left 入队；</span></span><br><span class="line">            <span class="keyword">if</span>(!value[i].equals(<span class="string">"null"</span>))&#123;</span><br><span class="line">                node.left = <span class="keyword">new</span> TreeNode(Integer.parseInt(value[i])); </span><br><span class="line">                queue.add(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">//指针加一，找下一个节点</span></span><br><span class="line">            i++;</span><br><span class="line">          <span class="comment">//构建 node 的右子节点：node.left 的值为 value[i] ，并将 node.left 入队；</span></span><br><span class="line">            <span class="keyword">if</span>(!value[i].equals(<span class="string">"null"</span>))&#123;</span><br><span class="line">                node.right = <span class="keyword">new</span> TreeNode(Integer.parseInt(value[i])); </span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">//指针加一，找下一个节点</span></span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//返回根节点root</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(<em>N</em>) ： N 为二叉树的节点数，层序遍历需要访问所有节点，最差情况下需要访问 N+1 个 null ，总体复杂度为 O(2N+1)=O(N) 。</li><li>空间复杂度 O(<em>N</em>) ： 最差情况下，队列 queue 同时存储 N+1/2个节点（或 N+1 个 null ），使用 O(N) ；列表 res 使用 O(N) 。</li></ul><h3 id="其他优秀解答"><a class="markdownIt-Anchor" href="#其他优秀解答"></a> 其他优秀解答</h3><blockquote><p>解题思路</p></blockquote><p>我们可以根据前序遍历的顺序来序列化二叉树,因为前序遍历是从根节点开始的。在遍历二叉树碰到 null时,将其序列化为一个特殊的字符(如’$’)，节点的数值之间要用一个特殊字符(如’,’)隔开,因为节点的值位数不定且正负不定。</p><blockquote><p>代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">int</span> start=<span class="number">0</span>;<span class="comment">//注意这里必须是全局变量，否则后面的迭代过程中start无法正确变化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="string">"$"</span>;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        recur(root,res);</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recur</span><span class="params">(TreeNode root,StringBuilder res)</span></span>&#123;<span class="comment">//前序遍历</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123; </span><br><span class="line">            res.append(<span class="string">"$,"</span>);<span class="comment">//可以append string</span></span><br><span class="line">            <span class="keyword">return</span>;&#125;</span><br><span class="line">        res.append(root.val);<span class="comment">//append int 由于int位数不定，且可正可负，因此各元素间必须用,分割</span></span><br><span class="line">        res.append(<span class="string">','</span>);<span class="comment">//append char</span></span><br><span class="line">        recur(root.left,res);</span><br><span class="line">        recur(root.right,res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data.equals(<span class="string">"$"</span>)) <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//Sting值相等的判别不能用==</span></span><br><span class="line">        String inputs[] = data.split(<span class="string">","</span>);</span><br><span class="line">        <span class="comment">//虽然data中以,结尾，但是上述分割后会默认最后一个,不存在  不会使最后一个分割元素为空</span></span><br><span class="line">        <span class="keyword">return</span> build(inputs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">build</span><span class="params">(String[] inputs)</span></span>&#123;</span><br><span class="line">        TreeNode res;</span><br><span class="line">        <span class="keyword">if</span>(inputs[start].equals(<span class="string">"$"</span>))&#123; </span><br><span class="line">            start++;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//这里说明当前节点为null，自然不存在左右节点了，直接返回</span></span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="keyword">new</span> TreeNode(Integer.parseInt(inputs[start]));</span><br><span class="line">        start++;</span><br><span class="line">        <span class="comment">//注意：start不能以形参的形式引入build方法中，build(inputs,start);如果是这样</span></span><br><span class="line">        <span class="comment">//下面res.left = build(inputs,start); res.right = build(inputs,start+1);由于处于同一级迭代中start值连续</span></span><br><span class="line">        <span class="comment">//但实际上res.right中应该是上面res.left迭代完成后才会执行的，start不连续，因此把start作为全局变量较为合适</span></span><br><span class="line">        res.left = build(inputs);</span><br><span class="line">        res.right = build(inputs);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目信息&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#题目信息&quot;&gt;&lt;/a&gt; 题目信息&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;题目： 剑指 Offer 37. 序列化二叉树&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时间： 2020-09-04
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://wangqiang.cool/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="回溯法" scheme="http://wangqiang.cool/tags/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    
      <category term="深度优先搜索" scheme="http://wangqiang.cool/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 38. 字符串的排列</title>
    <link href="http://wangqiang.cool/2020/09/03/%E5%89%91%E6%8C%87-Offer-38-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/"/>
    <id>http://wangqiang.cool/2020/09/03/%E5%89%91%E6%8C%87-Offer-38-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</id>
    <published>2020-09-03T02:12:13.000Z</published>
    <updated>2020-09-08T14:06:14.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目信息"><a class="markdownIt-Anchor" href="#题目信息"></a> 题目信息</h3><ul><li><p>题目：剑指 Offer 38. 字符串的排列</p></li><li><p>时间： 2020-09-03</p></li><li><p>题目链接：<a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/" target="_blank" rel="noopener">Leetcode</a></p></li><li><p>tag：深度优先搜索  回溯法</p></li><li><p>难易程度：中等</p></li><li><p>题目描述：</p><p>输入一个字符串，打印出该字符串中字符的所有排列。</p><p>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p></li></ul><p><strong>示例:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = "abc"</span><br><span class="line">输出：["abc","acb","bac","bca","cab","cba"]</span><br></pre></td></tr></table></figure><blockquote><p>提示</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= s.length() &lt;= 8</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><blockquote><p>本题难点</p></blockquote><p>对于一个长度为 n 的字符串（假设字符互不重复），其排列共有 n×(n−1)×(n−2)…×2×1 种方案。要求返回的结果又不能有重复元素。</p><p>回溯法 ：一种通过探索所有可能的候选解来找出所有的解的算法。如果候选解被确认不是一个解的话（或者至少不是最后一个解），回溯算法会通过在上一步进行一些变化抛弃该解，即回溯并且再次尝试。</p><blockquote><p>具体思路</p></blockquote><p>这个问题可以看作有 n 个排列成一行的空格，我们需要从左往右依此填入题目给定的 n 个字符，每个字符只能使用一次。</p><p>定义chars[]为输入字符串的字符数组，递归函数 backtracking表示从左往右填到第 i 个位置，当前字符串排列为 s。 那么整个递归函数分为两个情况：</p><ul><li>如果 s.length()==chars.length，说明我们已经填完了 n 个位置（注意下标从 0 开始），找到了一个可行的解，我们将 s 放入答案数组中，递归结束。</li><li>如果 s.length()&lt;chars.length，我们要考虑这第 i 个位置我们要填哪个字符。根据题目要求我们肯定不能填已经填过的字符，因此很容易想到的一个处理手段是我们定义一个标记数组 hasUsed[] 来标记已经填过的数，那么在填第 i 个数的时候我们遍历题目给定的 n 个字符。</li><li>如果这个数没有被标记过，我们就尝试填入，并将其标记，继续尝试填下一个位置，即调用函数backtrack。搜索回溯的时候要撤销这一个位置填的数以及标记，并继续尝试其他没被标记过的数。</li></ul><blockquote><p>在一定会产生重复结果集的地方剪枝。</p></blockquote><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String[] permutation(String s) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 转换成字符数组</span></span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">      <span class="comment">// 排序是为了去重方便</span></span><br><span class="line">        Arrays.sort(chars);</span><br><span class="line">      <span class="comment">// 由于操作的都是字符，使用 StringBuilder</span></span><br><span class="line">      StringBuilder path = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">      <span class="comment">//标记数组。通过标记才能让递归后的代码知道之前用过哪些数据，就可以舍去这些数字（剪枝）。</span></span><br><span class="line">      <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[chars.length];</span><br><span class="line">      <span class="comment">// 回溯法</span></span><br><span class="line">        backtracking(chars,used,path);</span><br><span class="line">      <span class="comment">// 记得转成字符串数组</span></span><br><span class="line">        <span class="keyword">return</span> ret.toArray(<span class="keyword">new</span> String[ret.size()]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">char</span>[] chars,<span class="keyword">boolean</span>[] hasUsed,StringBuilder s)</span></span>&#123;</span><br><span class="line">      <span class="comment">// 恰好生成了新的字符对象</span></span><br><span class="line">        <span class="keyword">if</span>(s.length() == chars.length)&#123;</span><br><span class="line">            ret.add(s.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hasUsed[i])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">//去重，写 !hasUsed[i - 1] 是因为 chars[i - 1] 在深度优先遍历的过程中刚刚被撤销选择</span></span><br><span class="line">            <span class="keyword">if</span>(i != <span class="number">0</span> &amp;&amp; chars[i] == chars[i -<span class="number">1</span>] &amp;&amp; !hasUsed[i - <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">//当前字符是否使用</span></span><br><span class="line">            hasUsed[i] = <span class="keyword">true</span>;</span><br><span class="line">          <span class="comment">//将当前字符添加到StringBuilder中</span></span><br><span class="line">            s.append(chars[i]);</span><br><span class="line">          <span class="comment">//深度优先搜索</span></span><br><span class="line">            backtracking(chars,hasUsed,s);</span><br><span class="line">          <span class="comment">// 注意：这里是状态重置，是从深层结点回到浅层结点的过程，代码在形式上和递归之前是对称的</span></span><br><span class="line">          <span class="comment">// 递归完成以后，需要撤销选择，递归方法执行之前做了什么，递归方法执行以后就需要做相应的逆向操作</span></span><br><span class="line">            s.deleteCharAt(s.length() -<span class="number">1</span>);</span><br><span class="line">            hasUsed[i] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(<em>N</em>!) ： N 为字符串 s 的长度；时间复杂度和字符串排列的方案数成线性关系，方案数为 N×(N−1)×(N−2)…×2×1 ，因此复杂度为 O(N!) 。</li><li>空间复杂度 O(<em>N</em>) ： 其中 n 为序列的长度。除答案数组以外，递归函数在递归过程中需要为每一层递归函数分配栈空间，所以这里需要额外的空间且该空间取决于递归的深度，这里可知递归调用深度为 O(n)。</li></ul><h3 id="其他优秀解答"><a class="markdownIt-Anchor" href="#其他优秀解答"></a> 其他优秀解答</h3><blockquote><p>解题思路</p></blockquote><ul><li><p><strong>排列方案的生成方法</strong>：根据字符串排列的特点，考虑深度优先搜索所有排列方案。即通过字符交换，先固定第 1 位字符（ n 种情况）、再固定第 2 位字符（ n−1 种情况）、… 、最后固定第 n 位字符（ 1 种情况）。</p></li><li><p><strong>重复方案与剪枝</strong>：</p><p>当字符串存在重复字符时，排列方案中也存在重复方案。为排除重复方案，需在固定某位字符时，保证 “每种字符只在此位固定一次” ，即遇到重复字符时不交换，直接跳过。从 DFS 角度看，此操作称为 “剪枝” 。</p></li></ul><blockquote><p>代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exam38_permutation</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//为了让递归函数添加结果方便，定义到函数之外，这样无需带到递归函数的参数列表中</span></span><br><span class="line">    <span class="keyword">char</span>[] c;</span><br><span class="line">    <span class="comment">//同；但是其赋值依赖c，定义声明分开</span></span><br><span class="line">    <span class="keyword">public</span> String[] permutation(String s) &#123;</span><br><span class="line">        c = s.toCharArray();</span><br><span class="line">        <span class="comment">//从第一层开始递归</span></span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> list.toArray(<span class="keyword">new</span> String[list.size()]);</span><br><span class="line">        <span class="comment">//将字符串数组ArrayList转化为String类型数组</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当递归函数到达第三层，就返回，因为此时第二第三个位置已经发生了交换</span></span><br><span class="line">        <span class="keyword">if</span> (x == c.length - <span class="number">1</span>) &#123;</span><br><span class="line">            list.add(String.valueOf(c));<span class="comment">//将字符数组转换为字符串</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//为了防止同一层递归出现重复元素</span></span><br><span class="line">        HashSet&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="comment">//这里就很巧妙了,第一层可以是a,b,c那么就有三种情况，这里i = x,正巧dfs(0)，正好i = 0开始</span></span><br><span class="line">        <span class="comment">// 当第二层只有两种情况，dfs(1）i = 1开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt; c.length; i++)&#123;</span><br><span class="line">            <span class="comment">//发生剪枝，当包含这个元素的时候，直接跳过</span></span><br><span class="line">            <span class="keyword">if</span> (set.contains(c[i]))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(c[i]);</span><br><span class="line">            <span class="comment">//交换元素，这里很是巧妙，当在第二层dfs(1),x = 1,那么i = 1或者 2， 要不是交换1和1，要不交换1和2</span></span><br><span class="line">            swap(i,x);</span><br><span class="line">            <span class="comment">//进入下一层递归</span></span><br><span class="line">            dfs(x + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//返回时交换回来，这样保证到达第1层的时候，一直都是abc。这里捋顺一下，开始一直都是abc，那么第一位置总共就3个位置</span></span><br><span class="line">            <span class="comment">//分别是a与a交换，这个就相当于 x = 0, i = 0;</span></span><br><span class="line">            <span class="comment">//     a与b交换            x = 0, i = 1;</span></span><br><span class="line">            <span class="comment">//     a与c交换            x = 0, i = 2;</span></span><br><span class="line">            <span class="comment">//就相当于上图中开始的三条路径</span></span><br><span class="line">            <span class="comment">//第一个元素固定后，每个引出两条路径,</span></span><br><span class="line">            <span class="comment">//     b与b交换            x = 1, i = 1;</span></span><br><span class="line">            <span class="comment">//     b与c交换            x = 1, i = 2;</span></span><br><span class="line">            <span class="comment">//所以，结合上图，在每条路径上标注上i的值，就会非常容易好理解了</span></span><br><span class="line">            swap(i,x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> temp = c[i];</span><br><span class="line">        c[i] = c[x];</span><br><span class="line">        c[x] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目信息&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#题目信息&quot;&gt;&lt;/a&gt; 题目信息&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;题目：剑指 Offer 38. 字符串的排列&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时间： 2020-09-03&lt;
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://wangqiang.cool/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="回溯法" scheme="http://wangqiang.cool/tags/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    
      <category term="深度优先搜索" scheme="http://wangqiang.cool/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 39. 数组中出现次数超过一半的数字</title>
    <link href="http://wangqiang.cool/2020/09/02/%E5%89%91%E6%8C%87-Offer-39-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>http://wangqiang.cool/2020/09/02/%E5%89%91%E6%8C%87-Offer-39-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/</id>
    <published>2020-09-02T02:09:50.000Z</published>
    <updated>2020-09-08T14:06:08.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目信息"><a class="markdownIt-Anchor" href="#题目信息"></a> 题目信息</h3><ul><li><p>题目；剑指 Offer 39. 数组中出现次数超过一半的数字</p></li><li><p>时间： 2020-09-02</p></li><li><p>题目链接：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/" target="_blank" rel="noopener">Leetcode</a></p></li><li><p>tag：  数组  哈希表</p></li><li><p>难易程度：简单</p></li><li><p>题目描述：</p><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p><p>假设数组是非空的，并且给定的数组总是存在多数元素。</p></li></ul><p><strong>示例:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><blockquote><p>提示</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= 数组长度 &lt;= 50000</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><blockquote><p>本题难点</p></blockquote><p>如何实现查找数组中的众数的最优解，时间复杂度和空间复杂度最小。</p><blockquote><p>具体思路</p></blockquote><p>摩尔投票法：</p><ul><li><strong>票数和</strong>：由于众数出现的次数超过数组长度的一半；若记 <strong>众数</strong> 的票数为 +1 ，<strong>非众数</strong> 的票数为 −1 ，则一定有所有数字的<strong>票数和</strong> &gt; 0。</li><li><strong>票数正负抵消</strong>： 设数组 <code>nums</code> 中的众数为 <em>x</em> ，数组长度为 <em>n</em> 。若 nums 的前 a 个数字的 票数和 =0 ，则 数组后 (n−a) 个数字的 票数和一定仍 &gt; 0 （即后 (n−a) 个数字的 众数仍为 x ）。</li></ul><p>为构建正负抵消，假设数组首个元素 为众数，遍历统计票数，当发生正负抵消时，剩余数组的众数一定不变 ，这是因为（设真正的众数为 x ）：</p><ul><li>当 n1=x ： 抵消的所有数字中，有一半是众数 x 。</li><li>当 n1≠x ： 抵消的所有数字中，少于或等于一半是众数 x 。</li></ul><p>利用此特性，每轮假设都可以 <strong>缩小剩余数组区间</strong> 。当遍历完成时，最后一轮假设的数字即为众数（由于众数超过一半，最后一轮的票数和必为正数）。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//票数统计 count=0</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">//众数 x</span></span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">//遍历数组 nums 中的每个数字 num </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num :nums)&#123;</span><br><span class="line">          <span class="comment">//当 票数 count 等于 0 ，则假设 当前数字 num 为 众数 x ；</span></span><br><span class="line">            <span class="keyword">if</span>(count == <span class="number">0</span>)&#123;</span><br><span class="line">                x = num;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">//当 num=x 时，票数 count 自增 1 ；否则，票数 count 自减 1</span></span><br><span class="line">            <span class="keyword">if</span>(num == x)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(<em>N</em>) ：数组长度为<em>N</em> ，遍历数组花费的时间。</li><li>空间复杂度 O(<em>1</em>) ： 只开辟了一个空间用于保存众数。</li></ul><h3 id="其他优秀解答"><a class="markdownIt-Anchor" href="#其他优秀解答"></a> 其他优秀解答</h3><blockquote><p>解题思路</p></blockquote><p>哈希表统计法：遍历数组 nums，用 HashMap 统计各数字的数量，最终超过数组长度一半的数字则为众数。此方法时间和空间复杂度均为 O(N)。</p><blockquote><p>代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">            map.put(num,map.getOrDefault(num,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(map.get(num)&gt;(nums.length/<span class="number">2</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目信息&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#题目信息&quot;&gt;&lt;/a&gt; 题目信息&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;题目；剑指 Offer 39. 数组中出现次数超过一半的数字&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时间： 202
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://wangqiang.cool/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数组" scheme="http://wangqiang.cool/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="哈希表" scheme="http://wangqiang.cool/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 40. 最小的k个数</title>
    <link href="http://wangqiang.cool/2020/09/01/%E5%89%91%E6%8C%87-Offer-40-%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/"/>
    <id>http://wangqiang.cool/2020/09/01/%E5%89%91%E6%8C%87-Offer-40-%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/</id>
    <published>2020-09-01T13:39:43.000Z</published>
    <updated>2020-09-08T14:06:02.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目信息"><a class="markdownIt-Anchor" href="#题目信息"></a> 题目信息</h3><ul><li><p>题目：剑指 Offer 40. 最小的k个数</p></li><li><p>时间： 2020-09-01</p></li><li><p>题目链接：<a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/" target="_blank" rel="noopener">Leetcode</a></p></li><li><p>tag： 快速排序</p></li><li><p>难易程度：中等</p></li><li><p>题目描述：</p><p>输入整数数组 <code>arr</code> ，找出其中最小的 <code>k</code> 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p></li></ul><p><strong>示例1:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [3,2,1], k = 2</span><br><span class="line">输出：[1,2] 或者 [2,1]</span><br></pre></td></tr></table></figure><p><strong>示例2:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [0,1,2,1], k = 1</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><blockquote><p>提示</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.0 &lt;= k &lt;= arr.length &lt;= 10000</span><br><span class="line">2.0 &lt;= arr[i] &lt;= 10000</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><blockquote><p>本题难点</p></blockquote><p>多种解题方案，快排，大根堆，二叉搜索树，计数排序</p><blockquote><p>具体思路</p></blockquote><p>快速排序的思想。快排的划分函数每次执行完后都能将数组分成两个部分，小于等于分界值 pivot 的元素的都会被放到数组的左边，大于的都会被放到数组的右边，然后返回分界值的下标。</p><p>我们的目的是寻找最小的 k 个数。假设经过一次 partition 操作，分界值 pivot元素位于下标 j，也就是说，左侧的数组有 j 个元素，是原数组中最小的 j 个数。那么：</p><ul><li><strong>k = j</strong>： 我们就找到了最小的 k 个数，就是左侧的数组；：</li><li><strong>k &lt; j</strong>： 则最小的 k 个数一定都在左侧数组中，我们只需要对左侧数组递归地 parition 即可；</li><li><strong>k &gt; j</strong>：则左侧数组中的 j 个数都属于最小的 k 个数，我们还需要在右侧数组中寻找最小的 k−j 个数，对右侧数组递归地 partition 即可。</li></ul><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr.length == <span class="number">0</span> || k == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//快排查找前k个数，第k个数的数组下标为k-1</span></span><br><span class="line">        <span class="keyword">return</span> findKthSmallest(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>,k-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findKthSmallest(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> l ,<span class="keyword">int</span> h , <span class="keyword">int</span> k)&#123;</span><br><span class="line">      <span class="comment">// 每快排切分1次，找到排序后下标为j的元素，如果j恰好等于k就返回j以及j左边所有的数；</span></span><br><span class="line">        <span class="keyword">int</span> j = partition(arr,l,h);</span><br><span class="line">        <span class="keyword">if</span>(j == k)&#123;</span><br><span class="line">            <span class="keyword">return</span> Arrays.copyOf(arr, j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 否则根据下标j与k的大小关系来决定继续切分左段还是右段。</span></span><br><span class="line">        <span class="keyword">return</span> j &gt; k ? findKthSmallest(arr,l,j-<span class="number">1</span>,k):findKthSmallest(arr,j+<span class="number">1</span>,h,k);        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 快排切分，返回下标j，使得比nums[j]小的数都在j的左边，比nums[j]大的数都在j的右边。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> l,<span class="keyword">int</span> h)</span></span>&#123;</span><br><span class="line">        <span class="comment">//切分元素</span></span><br><span class="line">        <span class="keyword">int</span> privot = arr[l];</span><br><span class="line">        <span class="keyword">int</span> i = l,j = h + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i != h &amp;&amp; arr[++i] &lt; privot);</span><br><span class="line">            <span class="keyword">while</span>(j != l &amp;&amp; arr[--j] &gt; privot);</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= j)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(arr,i,j);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr,l,j);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(<em>N</em>) ： 找下标为k的元素，第一次切分的时候需要遍历整个数组 (0 ~ n) 找到了下标是 j 的元素，假如 k 比 j 小的话，那么我们下次切分只要遍历数组 (0~k-1)的元素就行啦，总之可以看作每次调用 partition 遍历的元素数目都是上一次遍历的 1/2，因此时间复杂度是 N + N/2 + N/4 + … + N/N = 2N, 因此时间复杂度是 O(<em>N</em>)。</li><li>空间复杂度 O(<em>logN</em>) ： 递归调用的期望深度为O(<em>logN</em>)，每层需要的空间为 O(<em>1</em>)，只有常数个变量。</li></ul><h3 id="其他优秀解答"><a class="markdownIt-Anchor" href="#其他优秀解答"></a> 其他优秀解答</h3><blockquote><p>解题思路</p></blockquote><p>本题是求前 K 小，因此用一个容量为 K 的大根堆，每次 poll 出最大的数，那堆中保留的就是前 K 小啦（注意不是小根堆！小根堆的话需要把全部的元素都入堆，那是 O(NlogN)，就不是 O(NlogK)）这个方法比快排慢。</p><blockquote><p>代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保持堆的大小为K，然后遍历数组中的数字，遍历的时候做如下判断：</span></span><br><span class="line"><span class="comment">// 1. 若目前堆的大小小于K，将当前数字放入堆中。</span></span><br><span class="line"><span class="comment">// 2. 否则判断当前数字与大根堆堆顶元素的大小关系，如果当前数字比大根堆堆顶还大，这个数就直接跳过；</span></span><br><span class="line"><span class="comment">//    反之如果当前数字比大根堆堆顶小，先poll掉堆顶，再将该数字放入堆中。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 默认是小根堆，实现大根堆需要重写一下比较器。</span></span><br><span class="line">        Queue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((v1, v2) -&gt; v2 - v1);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pq.size() &lt; k) &#123;</span><br><span class="line">                pq.offer(num);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &lt; pq.peek()) &#123;</span><br><span class="line">                pq.poll();</span><br><span class="line">                pq.offer(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回堆中的元素</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[pq.size()];</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num: pq) &#123;</span><br><span class="line">            res[idx++] = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>解题思路</p></blockquote><p>BST 相对于前两种方法没那么常见，但是也很简单，和大根堆的思路差不多，与前两种方法相比，BST 有一个好处是求得的前K大的数字是有序的。</p><blockquote><p>代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// TreeMap的key是数字, value是该数字的个数。</span></span><br><span class="line">        <span class="comment">// cnt表示当前map总共存了多少个数字。</span></span><br><span class="line">        TreeMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: arr) &#123;</span><br><span class="line">            <span class="comment">// 1. 遍历数组，若当前map中的数字个数小于k，则map中当前数字对应个数+1</span></span><br><span class="line">            <span class="keyword">if</span> (cnt &lt; k) &#123;</span><br><span class="line">                map.put(num, map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">                cnt++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">// 2. 否则，取出map中最大的Key（即最大的数字), 判断当前数字与map中最大数字的大小关系：</span></span><br><span class="line">            <span class="comment">//    若当前数字比map中最大的数字还大，就直接忽略；</span></span><br><span class="line">            <span class="comment">//    若当前数字比map中最大的数字小，则将当前数字加入map中，并将map中的最大数字的个数-1。</span></span><br><span class="line">            Map.Entry&lt;Integer, Integer&gt; entry = map.lastEntry();</span><br><span class="line">            <span class="keyword">if</span> (entry.getKey() &gt; num) &#123;</span><br><span class="line">                map.put(num, map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (entry.getValue() == <span class="number">1</span>) &#123;</span><br><span class="line">                    map.pollLastEntry();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    map.put(entry.getKey(), entry.getValue() - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最后返回map中的元素</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry: map.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">int</span> freq = entry.getValue();</span><br><span class="line">            <span class="keyword">while</span> (freq-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                res[idx++] = entry.getKey();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>解题思路</p></blockquote><p>数据范围有限时直接计数排序就行了：O(<em>N)</em></p><blockquote><p>代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 统计每个数字出现的次数</span></span><br><span class="line">        <span class="keyword">int</span>[] counter = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10001</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: arr) &#123;</span><br><span class="line">            counter[num]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据counter数组从头找出k个数作为返回结果</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num = <span class="number">0</span>; num &lt; counter.length; num++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (counter[num]-- &gt; <span class="number">0</span> &amp;&amp; idx &lt; k) &#123;</span><br><span class="line">                res[idx++] = num;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (idx == k) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目信息&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#题目信息&quot;&gt;&lt;/a&gt; 题目信息&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;题目：剑指 Offer 40. 最小的k个数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时间： 2020-09-01&lt;
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://wangqiang.cool/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="快速排序" scheme="http://wangqiang.cool/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 41. 数据流中的中位数</title>
    <link href="http://wangqiang.cool/2020/08/31/%E5%89%91%E6%8C%87-Offer-41-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <id>http://wangqiang.cool/2020/08/31/%E5%89%91%E6%8C%87-Offer-41-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</id>
    <published>2020-08-31T13:37:40.000Z</published>
    <updated>2020-09-08T14:05:54.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目信息"><a class="markdownIt-Anchor" href="#题目信息"></a> 题目信息</h3><ul><li><p>题目：剑指 Offer 41. 数据流中的中位数</p></li><li><p>时间： 2020-08-31</p></li><li><p>题目链接：<a href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/" target="_blank" rel="noopener">Leetcode</a></p></li><li><p>tag：  大根堆 小根堆</p></li><li><p>难易程度：中等</p></li><li><p>题目描述：</p><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p><p>设计一个支持以下两种操作的数据结构：</p><ul><li>void addNum(int num) - 从数据流中添加一个整数到数据结构中。</li><li>double findMedian() - 返回目前所有元素的中位数。</li></ul></li></ul><p><strong>示例1:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">["MedianFinder","addNum","addNum","findMedian","addNum","findMedian"]</span><br><span class="line">[[],[1],[2],[],[3],[]]</span><br><span class="line">输出：[null,null,null,1.50000,null,2.00000]</span><br></pre></td></tr></table></figure><p><strong>示例2:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">["MedianFinder","addNum","findMedian","addNum","findMedian"]</span><br><span class="line">[[],[2],[],[3],[]]</span><br><span class="line">输出：[null,null,2.00000,null,2.50000]</span><br></pre></td></tr></table></figure><blockquote><p>提示</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最多会对 addNum、findMedia进行 50000 次调用。</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><blockquote><p>本题难点</p></blockquote><p>给定一长度为 N 的无序数组，其中位数的计算方法：首先对数组执行排序（使用 O(NlogN) 时间），然后返回中间元素即可（使用 O(1) 时间）。如何更好的优化时间复杂度</p><blockquote><p>具体思路</p></blockquote><p>建立一个 <strong>大根堆</strong> Left和<strong>小顶堆</strong> Right   ，各保存列表的一半元素，且规定：</p><ul><li>Left 保存 <strong>较小</strong> 的一半，长度为 N/2（ <em>N</em> 为偶数）或 N+1/2 (<em>N</em> 为奇数）；</li><li>Right保存 <strong>较大</strong> 的一半，长度为 N/2（ <em>N</em> 为偶数）或 N+1/2 (<em>N</em> 为奇数）；</li></ul><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> </span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; left;</span><br><span class="line">    Queue&lt;Integer&gt; right;</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MedianFinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//大根堆，堆顶元素最大，存较小的数</span></span><br><span class="line">        left = <span class="keyword">new</span> PriorityQueue&lt;&gt;((x,y) -&gt; (y - x));</span><br><span class="line">        <span class="comment">//小根堆，堆顶元素最小，存较大的数</span></span><br><span class="line">        right = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保证右边的小根堆数全部大于左边的大根堆的数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当前数据流中元素的个数为偶数时，即左半边大小和右半边大小相等时，</span></span><br><span class="line">        <span class="comment">//新添加的元素要插入到右半边的小根堆中，添加后数据流元素个数为奇数，方便后面取中位数</span></span><br><span class="line">        <span class="comment">//因为左半边的大根堆元素都要小于右半边，新插入的元素不一定比左半边元素原来的大</span></span><br><span class="line">        <span class="comment">//利用左半边大根堆的特点，先将元素插入左半边，取出堆顶元素即为最大值再插入右半边的小根堆</span></span><br><span class="line">        <span class="keyword">if</span>(left.size() == right.size())&#123;</span><br><span class="line">            left.add(num);</span><br><span class="line">            right.add(left.poll());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            right.add(num);</span><br><span class="line">            left.add(right.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当数据流中的个数为奇数时，中位数为右半边小根堆的最小值</span></span><br><span class="line">        <span class="comment">//当数据流中的个数为偶数时，中位数位左半边大根堆的最大值和右半边小根堆的最小值的平均</span></span><br><span class="line">        <span class="keyword">return</span> left.size() == right.size() ? (left.peek() + right.peek()) / <span class="number">2.0</span> : right.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MedianFinder object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MedianFinder obj = new MedianFinder();</span></span><br><span class="line"><span class="comment"> * obj.addNum(num);</span></span><br><span class="line"><span class="comment"> * double param_2 = obj.findMedian();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(<em>1</em>) ： 获取堆顶元素使用 O(1) 时间；</li><li>空间复杂度 O(<em>logN</em>) ： 堆的插入和弹出操作使用 O(<em>logN</em>) 时间。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目信息&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#题目信息&quot;&gt;&lt;/a&gt; 题目信息&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;题目：剑指 Offer 41. 数据流中的中位数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时间： 2020-08-3
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://wangqiang.cool/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="大根堆" scheme="http://wangqiang.cool/tags/%E5%A4%A7%E6%A0%B9%E5%A0%86/"/>
    
      <category term="小根堆" scheme="http://wangqiang.cool/tags/%E5%B0%8F%E6%A0%B9%E5%A0%86/"/>
    
  </entry>
  
</feed>
