<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小锵的博客</title>
  
  <subtitle>博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wangqiang.cool/"/>
  <updated>2020-09-07T06:50:58.000Z</updated>
  <id>http://wangqiang.cool/</id>
  
  <author>
    <name>小锵同学、</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>剑指 Offer 58 - I. 翻转单词顺序</title>
    <link href="http://wangqiang.cool/2020/09/07/%E5%89%91%E6%8C%87-Offer-58-I-%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F/"/>
    <id>http://wangqiang.cool/2020/09/07/%E5%89%91%E6%8C%87-Offer-58-I-%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F/</id>
    <published>2020-09-07T06:49:19.000Z</published>
    <updated>2020-09-07T06:50:58.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目信息"><a class="markdownIt-Anchor" href="#题目信息"></a> 题目信息</h3><ul><li><p>题目：翻转单词顺序</p></li><li><p>时间： 2020-09-07</p></li><li><p>题目链接：<a href="https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/" target="_blank" rel="noopener">Leetcode</a></p></li><li><p>tag：字符串  排序</p></li><li><p>难易程度：简单</p></li><li><p>题目描述：</p><p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串&quot;I am a student. “，则输出&quot;student. a am I”。</p></li></ul><p><strong>示例1:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: "the sky is blue"</span><br><span class="line">输出: "blue is sky the"</span><br></pre></td></tr></table></figure><p><strong>示例2:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: "  hello world!  "</span><br><span class="line">输出: "world! hello"</span><br><span class="line">解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</span><br></pre></td></tr></table></figure><blockquote><p>注意</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 无空格字符构成一个单词。</span><br><span class="line">2. 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</span><br><span class="line">3. 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><blockquote><p>本题难点</p></blockquote><p>处理空格情况，字符串倒序。</p><blockquote><p>具体思路</p></blockquote><ul><li>倒序遍历字符串 s，记录单词左右索引边界 i, j；</li><li>每确定一个单词的边界，则将其添加至单词列表 res ；</li><li>最终，将单词列表拼接为字符串，并返回即可。</li></ul><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        s = s.trim(); <span class="comment">// 删除首尾空格</span></span><br><span class="line">        <span class="keyword">int</span> j = s.length() - <span class="number">1</span>, i = j;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; s.charAt(i) != <span class="string">' '</span>) i--; <span class="comment">// 搜索首个空格</span></span><br><span class="line">            res.append(s.substring(i + <span class="number">1</span>, j + <span class="number">1</span>) + <span class="string">" "</span>); <span class="comment">// 添加单词</span></span><br><span class="line">            <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; s.charAt(i) == <span class="string">' '</span>) i--; <span class="comment">// 跳过单词间空格</span></span><br><span class="line">            j = i; <span class="comment">// j 指向下个单词的尾字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString().trim(); <span class="comment">// 转化为字符串并返回</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(N) ： 其中 N为字符串 s的长度，线性遍历字符串。</li><li>空间复杂度 O(N) ：  新建的 tringBuilder(Java) 中的字符串总长度 ≤N ，占用 O(N) 大小的额外空间。</li></ul><h3 id="其他优秀解答"><a class="markdownIt-Anchor" href="#其他优秀解答"></a> 其他优秀解答</h3><blockquote><p>解题思路</p></blockquote><p>利用 “字符串分割”、“列表倒序” 的内置函数 <em>（面试时不建议使用）</em> ，可简便地实现本题的字符串翻转要求。</p><blockquote><p>代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        String[] strs = s.trim().split(<span class="string">" "</span>); <span class="comment">// 删除首尾空格，分割字符串</span></span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = strs.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">// 倒序遍历单词列表</span></span><br><span class="line">            <span class="keyword">if</span>(strs[i].equals(<span class="string">""</span>)) <span class="keyword">continue</span>; <span class="comment">// 遇到空单词则跳过</span></span><br><span class="line">            res.append(strs[i] + <span class="string">" "</span>); <span class="comment">// 将单词拼接至 StringBuilder</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString().trim(); <span class="comment">// 转化为字符串，删除尾部空格，并返回</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目信息&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#题目信息&quot;&gt;&lt;/a&gt; 题目信息&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;题目：翻转单词顺序&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时间： 2020-09-07&lt;/p&gt;
&lt;/li&gt;
&lt;li
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://wangqiang.cool/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="字符串" scheme="http://wangqiang.cool/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="排序" scheme="http://wangqiang.cool/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 58 - II. 左旋转字符串</title>
    <link href="http://wangqiang.cool/2020/09/07/%E5%89%91%E6%8C%87-Offer-58-II-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://wangqiang.cool/2020/09/07/%E5%89%91%E6%8C%87-Offer-58-II-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2020-09-07T06:46:40.000Z</published>
    <updated>2020-09-07T06:48:48.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目信息"><a class="markdownIt-Anchor" href="#题目信息"></a> 题目信息</h3><ul><li><p>题目：剑指 Offer 58 - II. 左旋转字符串</p></li><li><p>时间： 2020-09-07</p></li><li><p>题目链接：<a href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/" target="_blank" rel="noopener">Leetcode</a></p></li><li><p>tag：  字符串 排序</p></li><li><p>难易程度：中等</p></li><li><p>题目描述：</p><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串&quot;abcdefg&quot;和数字2，该函数将返回左旋转两位得到的结果&quot;cdefgab&quot;。</p></li></ul><p><strong>示例1:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = "abcdefg", k = 2</span><br><span class="line">输出: "cdefgab"</span><br></pre></td></tr></table></figure><p><strong>示例2:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = "lrloseumgh", k = 6</span><br><span class="line">输出: "umghlrlose"</span><br></pre></td></tr></table></figure><blockquote><p>注意</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. 1 &lt;= k &lt; s.length &lt;= 10000</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><blockquote><p>本题难点</p></blockquote><p>旋转k个字符串</p><blockquote><p>具体思路</p></blockquote><p>列表遍历拼接</p><ul><li>新建一个StringBuilder(Java) ，记为 res；</li><li>先向 res 添加 “第 n+1 位至末位的字符” ；</li><li>再向 res 添加 “首位至第 n 位的字符” ；</li><li>将 res 转化为字符串并返回。</li></ul><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseLeftWords</span><span class="params">(String s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">         StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &lt; n + s.length(); i++)&#123;</span><br><span class="line">             res.append(s.charAt(i % s.length()));</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(N) ： 线性遍历 s并添加，使用线性时间；</li><li>空间复杂度 O(N) ：  新建的辅助 res 使用 O(N) 大小的额外空间。</li></ul><h3 id="其他优秀解答"><a class="markdownIt-Anchor" href="#其他优秀解答"></a> 其他优秀解答</h3><blockquote><p>解题思路</p></blockquote><p>字符串切片</p><blockquote><p>代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseLeftWords</span><span class="params">(String s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.substring(n,s.length()) + s.substring(<span class="number">0</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目信息&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#题目信息&quot;&gt;&lt;/a&gt; 题目信息&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;题目：剑指 Offer 58 - II. 左旋转字符串&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时间： 2020-0
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://wangqiang.cool/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="字符串" scheme="http://wangqiang.cool/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="排序" scheme="http://wangqiang.cool/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 59 - I. 滑动窗口的最大值</title>
    <link href="http://wangqiang.cool/2020/09/07/%E5%89%91%E6%8C%87-Offer-59-I-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
    <id>http://wangqiang.cool/2020/09/07/%E5%89%91%E6%8C%87-Offer-59-I-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</id>
    <published>2020-09-07T06:44:56.000Z</published>
    <updated>2020-09-07T06:48:11.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目信息"><a class="markdownIt-Anchor" href="#题目信息"></a> 题目信息</h3><ul><li><p>题目：剑指 Offer 59 - I. 滑动窗口的最大值</p></li><li><p>时间： 2020-09-07</p></li><li><p>题目链接：<a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/" target="_blank" rel="noopener">Leetcode</a></p></li><li><p>tag： 队列 双端队列 滑动窗口</p></li><li><p>难易程度：困难</p></li><li><p>题目描述：</p><p>给定一个数组 <code>nums</code> 和滑动窗口的大小 <code>k</code>，请找出所有滑动窗口里的最大值。</p></li></ul><p><strong>示例:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3</span><br><span class="line">输出: [3,3,5,5,6,7] </span><br><span class="line">解释: </span><br><span class="line"></span><br><span class="line">  滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure><blockquote><p>注意</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. 你可以假设 k 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><blockquote><p>本题难点</p></blockquote><p>数组无序，窗口内的最大值。</p><blockquote><p>具体思路</p></blockquote><p><strong>双向队列</strong>：在头部进行插入、删除操作，也能在尾部进行插入删除操作。</p><p><strong>单调的双向队列</strong>：从队列的头部到尾部，所存储的元素是依次递减（或依次递增）的。</p><p>我们维护一个<code>单调的双向队列</code>，窗口在每次滑动的时候，我就从队列<code>头部</code>取当前窗口中的<code>最大值</code>，每次窗口新进来一个元素的时候，我就将它与队列中的元素进行大小比较：</p><ul><li>进来的元素 &gt; 队列的尾部元素：那么先将队列尾部的元素弹出，然后把刚刚进来的元素添到队列的尾部；</li><li>进来的元素 &lt; 队列的尾部元素：那么把刚刚进来的元素直接添到队列的尾部即可。</li></ul><p>删除元素：当队列的大小超过窗口的大小时，将队列的最大值弹出，窗口进行滑动。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || k == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        Deque&lt;Integer&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length - k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="comment">// 在队列不为空的情况下，如果队列尾部的元素要比当前的元素小，或等于当前的元素</span></span><br><span class="line">            <span class="comment">// 那么为了维持从大到小的原则，我必须让尾部元素弹出</span></span><br><span class="line">            <span class="keyword">while</span>(!deque.isEmpty() &amp;&amp; nums[deque.peekLast()] &lt;= nums[i])&#123;</span><br><span class="line">                deque.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="comment">// 不走 while 的话，说明我们正常在队列尾部添加元素</span></span><br><span class="line">            deque.add(i);</span><br><span class="line">          <span class="comment">// 如果滑动窗口已经略过了队列中头部的元素，则将头部元素弹出</span></span><br><span class="line">            <span class="keyword">if</span>(deque.peekFirst() == (i - k))&#123;</span><br><span class="line">                deque.pollFirst();</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">// 看看窗口有没有形成，只有形成了大小为 k 的窗口，我才能收集窗口内的最大值</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k-<span class="number">1</span>)&#123;</span><br><span class="line">                res[count++] = nums[deque.peekFirst()];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(N) ： 其中 n 为数组 nums 长度；线性遍历 nums 占用 O(N) ；每个元素最多仅入队和出队一次，因此单调队列 deque 占用 O(2N) 。</li><li>空间复杂度 O(k) ：  双端队列 deque 中最多同时存储 k个元素（即窗口大小）。</li></ul><h3 id="其他优秀解答"><a class="markdownIt-Anchor" href="#其他优秀解答"></a> 其他优秀解答</h3><blockquote><p>解题思路</p></blockquote><p>改善之后的暴力法</p><blockquote><p>代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">       <span class="keyword">int</span> len = nums.length;</span><br><span class="line">       <span class="keyword">if</span> (len == <span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//定义结果数组</span></span><br><span class="line">       <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[len - k + <span class="number">1</span>];</span><br><span class="line">       <span class="comment">//maxInd记录每次最大值的下标，max记录最大值</span></span><br><span class="line">       <span class="keyword">int</span> maxInd = -<span class="number">1</span>, max = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - k + <span class="number">1</span>; i++) &#123;</span><br><span class="line">           <span class="comment">//判断最大值下标是否在滑动窗口的范围内</span></span><br><span class="line">           <span class="keyword">if</span> (maxInd &gt;= i)&#123;</span><br><span class="line">               <span class="comment">//存在就只需要比较最后面的值是否大于上一个窗口最大值</span></span><br><span class="line">               <span class="keyword">if</span> (nums[i + k - <span class="number">1</span>] &gt; max)&#123;</span><br><span class="line">                   max = nums[i + k - <span class="number">1</span>];</span><br><span class="line">                   <span class="comment">//更新最大值下标</span></span><br><span class="line">                   maxInd = i + k - <span class="number">1</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//如果不在就重新寻找当前窗口最大值</span></span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               max = nums[i];</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; i + k; j++) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (max &lt; nums[j]) &#123;</span><br><span class="line">                       max = nums[j];</span><br><span class="line">                       maxInd = j;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           res[i] = max;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目信息&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#题目信息&quot;&gt;&lt;/a&gt; 题目信息&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;题目：剑指 Offer 59 - I. 滑动窗口的最大值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时间： 2020-
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://wangqiang.cool/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="队列" scheme="http://wangqiang.cool/tags/%E9%98%9F%E5%88%97/"/>
    
      <category term="双端队列" scheme="http://wangqiang.cool/tags/%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97/"/>
    
      <category term="滑动窗口" scheme="http://wangqiang.cool/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 59 - II. 队列的最大值</title>
    <link href="http://wangqiang.cool/2020/09/07/%E5%89%91%E6%8C%87-Offer-59-II-%E9%98%9F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
    <id>http://wangqiang.cool/2020/09/07/%E5%89%91%E6%8C%87-Offer-59-II-%E9%98%9F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</id>
    <published>2020-09-07T06:42:57.000Z</published>
    <updated>2020-09-07T06:48:13.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目信息"><a class="markdownIt-Anchor" href="#题目信息"></a> 题目信息</h3><ul><li><p>题目：剑指 Offer 59 - II. 队列的最大值</p></li><li><p>时间： 2020-09-07</p></li><li><p>题目链接：<a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/" target="_blank" rel="noopener">Leetcode</a></p></li><li><p>tag： 队列 双端队列</p></li><li><p>难易程度：中等</p></li><li><p>题目描述：</p><p>请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。</p><p>若队列为空，pop_front 和 max_value 需要返回 -1</p></li></ul><p><strong>示例1:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">["MaxQueue","push_back","push_back","max_value","pop_front","max_value"]</span><br><span class="line">[[],[1],[2],[],[],[]]</span><br><span class="line">输出: [null,null,null,2,1,2]</span><br></pre></td></tr></table></figure><p><strong>示例2:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">["MaxQueue","pop_front","max_value"]</span><br><span class="line">[[],[],[]]</span><br><span class="line">输出: [null,-1,-1]</span><br></pre></td></tr></table></figure><blockquote><p>注意</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 1 &lt;= push_back,pop_front,max_value的总操作数 &lt;= 10000</span><br><span class="line">2. 1 &lt;= value &lt;= 10^5</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><blockquote><p>本题难点</p></blockquote><p>时间复杂度有要求为O(N)</p><blockquote><p>具体思路</p></blockquote><p>使用两个队列：一个队列正常入队出队；再用一个双端队列来辅助作为单调队列，维护队头最大值。这样max_value()查询，单调队列队首的值就是查询的最大值。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Queue&lt;Integer&gt; queue;</span><br><span class="line">    Deque&lt;Integer&gt; deque;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MaxQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">max_value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//单调队列队首就是最大值</span></span><br><span class="line">        <span class="keyword">return</span> queue.isEmpty() ? -<span class="number">1</span> : deque.peekFirst();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        queue.add(value);</span><br><span class="line">      <span class="comment">//维护单调队列的单调性：把小的都出队了 队列剩余的都是比当前元素大的，所以是单调递增，队首就是最大值</span></span><br><span class="line">      <span class="comment">//如果之前入队的队尾比后入队的当前元素还要小，就让队尾出队</span></span><br><span class="line">        <span class="keyword">while</span>(!deque.isEmpty() &amp;&amp; deque.peekLast() &lt; value)&#123;</span><br><span class="line">            deque.pollLast();</span><br><span class="line">        &#125;</span><br><span class="line">        deque.add(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//当普通队列的队首元素 等于 单调队列队首 就让单调队列队首出队</span></span><br><span class="line">        <span class="keyword">if</span>(!deque.isEmpty() &amp;&amp; deque.peekFirst().equals(queue.peek()))&#123;</span><br><span class="line">            deque.pollFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.isEmpty() ? -<span class="number">1</span> : queue.poll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(1) ： 删除操作于求最大值操作显然只需要 O(1) 的时间。而插入操作虽然看起来有循环，做一个插入操作时最多可能会有 n 次出队操作。但要注意，由于每个数字只会出队一次，因此对于所有的 n 个数字的插入过程，对应的所有出队操作也不会大于 n 次。因此将出队的时间均摊到每个插入操作上，时间复杂度为 O(1)。</li><li>空间复杂度 O(N) ： 需要用队列存储所有插入的元素。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目信息&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#题目信息&quot;&gt;&lt;/a&gt; 题目信息&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;题目：剑指 Offer 59 - II. 队列的最大值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时间： 2020-0
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://wangqiang.cool/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="队列" scheme="http://wangqiang.cool/tags/%E9%98%9F%E5%88%97/"/>
    
      <category term="双端队列" scheme="http://wangqiang.cool/tags/%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 61. 扑克牌中的顺子</title>
    <link href="http://wangqiang.cool/2020/09/07/%E5%89%91%E6%8C%87-Offer-61-%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90/"/>
    <id>http://wangqiang.cool/2020/09/07/%E5%89%91%E6%8C%87-Offer-61-%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90/</id>
    <published>2020-09-07T06:41:31.000Z</published>
    <updated>2020-09-07T06:48:15.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目信息"><a class="markdownIt-Anchor" href="#题目信息"></a> 题目信息</h3><ul><li><p>题目： 剑指 Offer 61. 扑克牌中的顺子</p></li><li><p>时间： 2020-09-07</p></li><li><p>题目链接：<a href="https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/" target="_blank" rel="noopener">Leetcode</a></p></li><li><p>tag：  哈希表 排序</p></li><li><p>难易程度：中等</p></li><li><p>题目描述：</p><p>从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。</p></li></ul><p><strong>示例1:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure><p><strong>示例2:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,0,1,2,5]</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure><blockquote><p>注意</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 数组长度为 5 </span><br><span class="line">2. 数组的数取值为 [0, 13]</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><blockquote><p>本题难点</p></blockquote><p>顺子包含’大小王’的特殊情况。</p><blockquote><p>具体思路</p></blockquote><p>集合 Set + 遍历</p><p>5 张牌是顺子的 <strong>充分条件</strong>：</p><ul><li>除大小王外，所有牌 <strong>无重复</strong> ；</li><li>设此 5张牌中最大的牌为 max ，最小的牌为 min（大小王除外），则需满足：max − min &lt; 5</li></ul><blockquote><p>提示</p></blockquote><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isStraight</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span> || nums == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> min = <span class="number">13</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">          <span class="comment">//遍历五张牌，遇到大小王（即 0 ）直接跳过。</span></span><br><span class="line">            <span class="keyword">if</span>(num == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">//获取最大 / 最小的牌： 借助辅助变量 max 和 min ，遍历统计即可。</span></span><br><span class="line">            min = Math.min(num,min);</span><br><span class="line">            max = Math.max(num,max);</span><br><span class="line"></span><br><span class="line">          <span class="comment">//判别重复： 利用 Set 实现遍历判重</span></span><br><span class="line">            <span class="keyword">if</span>(set.contains(num))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max - min &lt; <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(N) ： 其中 N为 nums长度，本题中 N=5 ；遍历数组使用 O(N)时间。</li><li>空间复杂度 O(N) ： 用于判重的辅助 Set 使用 O(N)额外空间。</li></ul><h3 id="其他优秀解答"><a class="markdownIt-Anchor" href="#其他优秀解答"></a> 其他优秀解答</h3><blockquote><p>解题思路</p></blockquote><p>先对数组执行排序。<br />判别重复： 排序数组中的相同元素位置相邻，通过遍历数组，判断 nums[i]=nums[i+1] 是否成立来判重。</p><p>获取最大 / 最小的牌： 排序后，数组末位元素 nums[4] 为最大牌；元素 nums[joker] 为最小牌，其中 joker 为大小王的数量。</p><blockquote><p>代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isStraight</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> joker = <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(nums); <span class="comment">// 数组排序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">0</span>) joker++; <span class="comment">// 统计大小王数量</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == nums[i + <span class="number">1</span>]) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 若有重复，提前返回 false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">4</span>] - nums[joker] &lt; <span class="number">5</span>; <span class="comment">// 最大牌 - 最小牌 &lt; 5 则可构成顺子</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目信息&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#题目信息&quot;&gt;&lt;/a&gt; 题目信息&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;题目： 剑指 Offer 61. 扑克牌中的顺子&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时间： 2020-09-0
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://wangqiang.cool/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序" scheme="http://wangqiang.cool/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="哈希表" scheme="http://wangqiang.cool/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 62. 圆圈中最后剩下的数字</title>
    <link href="http://wangqiang.cool/2020/09/07/%E5%89%91%E6%8C%87-Offer-62-%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>http://wangqiang.cool/2020/09/07/%E5%89%91%E6%8C%87-Offer-62-%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97/</id>
    <published>2020-09-07T06:39:16.000Z</published>
    <updated>2020-09-07T06:40:45.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目信息"><a class="markdownIt-Anchor" href="#题目信息"></a> 题目信息</h3><ul><li><p>题目： 剑指 Offer 62. 圆圈中最后剩下的数字</p></li><li><p>时间： 2020-09-07</p></li><li><p>题目链接：<a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/" target="_blank" rel="noopener">Leetcode</a></p></li><li><p>tag： 动态规划 迭代 约瑟夫环</p></li><li><p>难易程度：中等</p></li><li><p>题目描述：</p><p>0,1,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。</p><p>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p></li></ul><p><strong>示例1:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: n = 5, m = 3</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure><p><strong>示例2:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: n = 10, m = 17</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><blockquote><p>注意</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 1 &lt;= n &lt;= 10^5</span><br><span class="line">2. 1 &lt;= m &lt;= 10^6</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><blockquote><p>本题难点</p></blockquote><p>约瑟夫环</p><p>N个人围成一圈，第一个人从1开始报数，报M的将被杀掉，下一个人接着从1开始报。如此反复，最后剩下一个，求最后的胜利者。</p><blockquote><p>具体思路</p></blockquote><p>约塞夫问题就是用人来举例的，那我们也<strong>给每个人一个编号</strong>（索引值），每个人用<strong>字母</strong>代替</p><p>下面这个例子是<code>N=8 m=3</code>的例子</p><p>我们定义<code>F(n,m)</code>表示最后剩下那个人的<code>索引号</code>，因此我们只关系最后剩下来这个人的索引号的变化情况即可</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/img/20200710223002.png" alt="image-20200710222956328" /></p><p>从8个人开始，每次杀掉一个人，去掉被杀的人，然后把杀掉那个人之后的第一个人作为开头重新编号</p><ul><li>第一次C被杀掉，人数变成7，D作为开头，（最终活下来的G的编号从6变成3）</li><li>第二次F被杀掉，人数变成6，G作为开头，（最终活下来的G的编号从3变成0）</li><li>第三次A被杀掉，人数变成5，B作为开头，（最终活下来的G的编号从0变成3）</li><li>以此类推，当只剩一个人时，他的编号必定为0！（重点！）</li></ul><p>现在我们知道了G的索引号的变化过程，那么我们反推一下<br />从<code>N = 7</code> 到<code>N = 8</code> 的过程</p><p>如何才能将<code>N = 7</code> 的排列变回到<code>N = 8</code> 呢？</p><p>我们先把被杀掉的C补充回来，然后右移m个人，发现溢出了，再把溢出的补充在最前面</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/img/20200710223708.png" alt="image-20200710223150733" /></p><p>因此我们可以推出递推公式f(8,3)=[f(7,3)+3]%8</p><p>进行推广泛化，即f(n,m)=[f(n−1,m)+m]%n</p><ul><li>递推公式</li></ul><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/img/20200710224044asd.png" alt="image-20200710223906449" /></p><blockquote><p>提示 : 最终剩下的数字的数组下标为0；</p></blockquote><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= n; i++)&#123;</span><br><span class="line">            res = (res + m) % i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(N) ：其中 N为 迭代n次的长度。</li><li>空间复杂度 O(1) ： 变量 res 使用常数大小的额外空间。</li></ul><h3 id="其他优秀解答"><a class="markdownIt-Anchor" href="#其他优秀解答"></a> 其他优秀解答</h3><blockquote><p>解题思路</p></blockquote><p>模拟链表。纯暴力的做法，每次找到删除的那个数字，需要 O(m) 的时间复杂度，然后删除了 n−1 次。但实际上我们可以直接找到下一个要删除的位置的。假设当前删除的位置是 idx，下一个删除的数字的位置是 idx+m 。但是，由于把当前位置的数字删除了，后面的数字会前移一位，所以实际的下一个位置是 idx+m−1。由于数到末尾会从头继续数，所以最后取模一下，就是 (idx+m−1)(modn)。</p><blockquote><p>代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            idx = (idx + m - <span class="number">1</span>) % n;</span><br><span class="line">            list.remove(idx);</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目信息&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#题目信息&quot;&gt;&lt;/a&gt; 题目信息&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;题目： 剑指 Offer 62. 圆圈中最后剩下的数字&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时间： 2020-0
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://wangqiang.cool/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="动态规划" scheme="http://wangqiang.cool/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="迭代" scheme="http://wangqiang.cool/tags/%E8%BF%AD%E4%BB%A3/"/>
    
      <category term="约瑟夫环" scheme="http://wangqiang.cool/tags/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 63. 股票的最大利润</title>
    <link href="http://wangqiang.cool/2020/09/07/%E5%89%91%E6%8C%87-Offer-63-%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/"/>
    <id>http://wangqiang.cool/2020/09/07/%E5%89%91%E6%8C%87-Offer-63-%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/</id>
    <published>2020-09-07T06:35:58.000Z</published>
    <updated>2020-09-07T06:37:40.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目信息"><a class="markdownIt-Anchor" href="#题目信息"></a> 题目信息</h3><ul><li><p>题目：剑指 Offer 63. 股票的最大利润</p></li><li><p>时间： 2020-09-07</p></li><li><p>题目链接：<a href="https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/" target="_blank" rel="noopener">Leetcode</a></p></li><li><p>tag：动态规划</p></li><li><p>难易程度：中等</p></li><li><p>题目描述：</p><p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p></li></ul><p><strong>示例1:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</span><br></pre></td></tr></table></figure><p><strong>示例2:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><blockquote><p>注意</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. 0 &lt;= 数组长度 &lt;= 10^5</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><blockquote><p>本题难点</p></blockquote><p>共有 n 天，第 a 天买，第 b 天卖，则需保证 a&lt;b ；可推出交易方案数共有：(<em>n</em>−1)+(<em>n</em>−2)+⋯+2+1=<em>n</em>(<em>n</em>−1)/2种，暴力法的时间复杂度为 O(n^2)。</p><blockquote><p>具体思路</p></blockquote><p>动态规划</p><ul><li><p><strong>状态定义</strong>：设动态规划列表 dp ，dp[i] 代表以 prices[i] 为结尾的子数组的最大利润（以下简称为 前 i 日的最大利润 ）。</p></li><li><p><strong>转移方程</strong>：由于题目限定 “买卖该股票一次” ，因此前 i 日最大利润 dp[i] 等于前 i−1 日最大利润 dp[i−1] 和第 i 日卖出的最大利润中的最大值。</p><p>dp[i] = mac(dp[i -1],prices[i] - min(prices[0:i]))</p></li></ul><blockquote><p>提示:由于 dp[i] 只与 dp[i−1] , prices[i] , cost 相关，因此可使用一个变量（记为利润 profit ）代替 dp 列表。</p></blockquote><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cost = Integer.MAX_VALUE, profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> price : prices) &#123;</span><br><span class="line">            cost = Math.min(cost, price);</span><br><span class="line">            profit = Math.max(profit, price - cost);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(N) ： 其中 N为 prices列表长度，动态规划需遍历 prices。</li><li>空间复杂度 O(1) ：   变量 cost和 profit 使用常数大小的额外空间。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目信息&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#题目信息&quot;&gt;&lt;/a&gt; 题目信息&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;题目：剑指 Offer 63. 股票的最大利润&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时间： 2020-09-07
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://wangqiang.cool/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="动态规划" scheme="http://wangqiang.cool/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 64. 求1+2+…+n</title>
    <link href="http://wangqiang.cool/2020/09/07/%E5%89%91%E6%8C%87-Offer-64-%E6%B1%821-2-%E2%80%A6-n/"/>
    <id>http://wangqiang.cool/2020/09/07/%E5%89%91%E6%8C%87-Offer-64-%E6%B1%821-2-%E2%80%A6-n/</id>
    <published>2020-09-07T06:30:34.000Z</published>
    <updated>2020-09-07T06:37:17.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目信息"><a class="markdownIt-Anchor" href="#题目信息"></a> 题目信息</h3><ul><li><p>题目；剑指 Offer 64. 求1+2+…+n</p></li><li><p>时间： 2020-09-07</p></li><li><p>题目链接：<a href="https://leetcode-cn.com/problems/qiu-12n-lcof/" target="_blank" rel="noopener">Leetcode</a></p></li><li><p>tag：位运算 限制运算符号</p></li><li><p>难易程度：中等</p></li><li><p>题目描述：</p><p>求 <code>1+2+...+n</code> ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p></li></ul><p><strong>示例1:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: n = 3</span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure><p><strong>示例2:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: n = 9</span><br><span class="line">输出: 45</span><br></pre></td></tr></table></figure><blockquote><p>注意</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. 1 &lt;= n &lt;= 10000</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><blockquote><p>本题难点</p></blockquote><p>不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句</p><blockquote><p>具体思路</p></blockquote><p>逻辑运算符：</p><ul><li>if(A &amp;&amp; B)  // 若 A 为 false ，则 B 的判断不会执行（即短路），直接判定 A &amp;&amp; B 为 false</li><li>if(A || B) // 若 A 为 true ，则 B 的判断不会执行（即短路），直接判定 A || B 为 true</li></ul><p>本题需要实现 “当 n=1 时终止递归” 的需求，可通过短路效应实现</p><p>n &gt; 1 &amp;&amp; sumNums(n - 1) // 当 n = 1 时 n &gt; 1 不成立 ，此时 “短路” ，终止后续递归</p><blockquote><p>提示</p></blockquote><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> flag = n &gt; <span class="number">1</span> &amp;&amp; sumNums(n-<span class="number">1</span>)&gt;<span class="number">0</span>;</span><br><span class="line">        res += n;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(N) ： 计算 n+(n−1)+…+2+1<em>n</em>+(<em>n</em>−1)+…+2+1 需要开启 n 个递归函数。</li><li>空间复杂度 O(N) ：  递归深度达到 n，系统使用 O(n)大小的额外空间。</li></ul><h3 id="其他优秀解答"><a class="markdownIt-Anchor" href="#其他优秀解答"></a> 其他优秀解答</h3><blockquote><p>解题思路</p></blockquote><p>平均计算、迭代、递归</p><blockquote><p>代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span> + n) * n / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        res += i;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    n += sumNums(n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目信息&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#题目信息&quot;&gt;&lt;/a&gt; 题目信息&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;题目；剑指 Offer 64. 求1+2+…+n&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时间： 2020-09-0
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://wangqiang.cool/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="限制运算符号" scheme="http://wangqiang.cool/tags/%E9%99%90%E5%88%B6%E8%BF%90%E7%AE%97%E7%AC%A6%E5%8F%B7/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 65. 不用加减乘除做加法</title>
    <link href="http://wangqiang.cool/2020/09/07/%E5%89%91%E6%8C%87-Offer-65-%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95/"/>
    <id>http://wangqiang.cool/2020/09/07/%E5%89%91%E6%8C%87-Offer-65-%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95/</id>
    <published>2020-09-07T06:28:41.000Z</published>
    <updated>2020-09-07T06:37:24.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目信息"><a class="markdownIt-Anchor" href="#题目信息"></a> 题目信息</h3><ul><li><p>题目：剑指 Offer 65. 不用加减乘除做加法</p></li><li><p>时间： 2020-09-07</p></li><li><p>题目链接：<a href="https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/" target="_blank" rel="noopener">Leetcode</a></p></li><li><p>tag： 位运算 限制运算符号</p></li><li><p>难易程度：中等</p></li><li><p>题目描述：</p><p>写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。</p></li></ul><p><strong>示例1:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: a = 1, b = 1</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><blockquote><p>注意</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. a, b 均可能是负数或 0</span><br><span class="line">2. 结果不会溢出 32 位整数</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><blockquote><p>本题难点</p></blockquote><p>求和不使用 “+”、“-”、“*”、“/” 四则运算符号。</p><blockquote><p>具体思路</p></blockquote><p>位运算</p><p>设两数字的二进制形式 a,b ，其求和 s=a+b ，a(i) 代表 a 的二进制第 i 位，则分为以下四种情况：</p><table><thead><tr><th style="text-align:center">a(i)</th><th style="text-align:center">b(i)</th><th style="text-align:center">无进位和n(i)</th><th style="text-align:center">进位和c(i)</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr></tbody></table><p><strong>无进位和</strong> 与 <strong>异或运算</strong> 规律相同</p><p><strong>进位</strong> 和 <strong>与运算</strong> 规律相同（并需左移一位）</p><p>即可将 s = a+b 转化为： s = 非进位和 n + 进位 c</p><p>循环求 n和 c ，直至进位 c=0；此时 s=n，返回 n即可。</p><blockquote><p>提示</p></blockquote><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(b != <span class="number">0</span>)&#123;</span><br><span class="line">            c = (a &amp; b) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            a ^= b;</span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(1) ： 最差情况下（例如 a= 0x7fffffff , b=1 时），需循环 31 次，使用 O(1) 时间；每轮中的常数次位操作使用 O(1) 时间。</li><li>空间复杂度 O(1) ： 使用常数大小的额外空间。</li></ul><h3 id="其他优秀解答"><a class="markdownIt-Anchor" href="#其他优秀解答"></a> 其他优秀解答</h3><blockquote><p>解题思路</p></blockquote><p>递归法，把a+b转换成非进位和+进位，由于不能用加法，因此要一直转换直到第二个加数变成0。</p><blockquote><p>代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 转换成非进位和 + 进位</span></span><br><span class="line">        <span class="keyword">return</span> add(a ^ b, (a &amp; b) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目信息&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#题目信息&quot;&gt;&lt;/a&gt; 题目信息&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;题目：剑指 Offer 65. 不用加减乘除做加法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时间： 2020-09-
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://wangqiang.cool/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="限制运算符号" scheme="http://wangqiang.cool/tags/%E9%99%90%E5%88%B6%E8%BF%90%E7%AE%97%E7%AC%A6%E5%8F%B7/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 66. 构建乘积数组</title>
    <link href="http://wangqiang.cool/2020/09/07/%E5%89%91%E6%8C%87-Offer-66-%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84/"/>
    <id>http://wangqiang.cool/2020/09/07/%E5%89%91%E6%8C%87-Offer-66-%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84/</id>
    <published>2020-09-07T06:18:12.000Z</published>
    <updated>2020-09-07T06:37:31.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目信息"><a class="markdownIt-Anchor" href="#题目信息"></a> 题目信息</h3><ul><li><p>题目：剑指 Offer 66. 构建乘积数组</p></li><li><p>时间： 2020-09-07</p></li><li><p>题目链接：<a href="https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/" target="_blank" rel="noopener">Leetcode</a></p></li><li><p>tag：  限制运算符号</p></li><li><p>难易程度：简单</p></li><li><p>题目描述：</p><p>给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B 中的元素 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。</p></li></ul><p><strong>示例:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: [120,60,40,30,24]</span><br></pre></td></tr></table></figure><blockquote><p>注意</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 所有元素乘积之和不会溢出 32 位整数</span><br><span class="line">2. a.length <span class="tag">&lt;<span class="name">=</span> <span class="attr">100000</span></span></span><br></pre></td></tr></table></figure><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><blockquote><p>本题难点</p></blockquote><p>不能使用除法，限制运算符号。</p><blockquote><p>具体思路</p></blockquote><p>B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]</p><table><thead><tr><th>B[i]</th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>B[0] =</td><td>1</td><td>A[1]</td><td>A[2]</td><td>…</td><td>A[n-1]</td><td>A[n]</td></tr><tr><td>B[1] =</td><td>A[0]</td><td>1</td><td>A[2]</td><td>…</td><td>A[n-1]</td><td>A[n]</td></tr><tr><td>B[2] =</td><td>A[0]</td><td>A[1]</td><td>1</td><td>…</td><td>A[n-1]</td><td>A[n]</td></tr><tr><td>…</td><td>…</td><td>…</td><td>…</td><td>…</td><td>…</td><td>…</td></tr><tr><td>B[n-1] =</td><td>A[0]</td><td>A[1]</td><td>A[2]</td><td>…</td><td>1</td><td>A[n]</td></tr><tr><td>B[n] =</td><td>A[0]</td><td>A[1]</td><td>A[2]</td><td>…</td><td>A[n-1]</td><td>1</td></tr></tbody></table><p>根据表格的主对角线（全为 11 ），可将表格分为 <strong>上三角</strong> 和 <strong>下三角</strong> 两部分。分别迭代计算下三角和上三角两部分的乘积，即可 <strong>不使用除法</strong> 就获得结果。</p><blockquote><p>提示：通过两轮循环，分别计算表格中下三角和上三角的乘积。</p></blockquote><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] constructArr(<span class="keyword">int</span>[] a) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">      <span class="comment">//初始化：数组 B ，其中 B[0]=1 ；辅助变量 tmp=1 ；</span></span><br><span class="line">        <span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[a.length];</span><br><span class="line">        b[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">1</span>;</span><br><span class="line">      <span class="comment">//计算 B[i] 的 下三角 各元素的乘积，直接乘入 B[i] ；</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            b[i] = b[i - <span class="number">1</span>] * a[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//计算 B[i] 的 上三角 各元素的乘积，记为 tmp ，并乘入 B[i] </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = a.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            tmp *= a[i + <span class="number">1</span>];</span><br><span class="line">            b[i] *= tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(N) ： 其中 N为数组长度，两轮遍历数组 a，使用 O(N) 时间。</li><li>空间复杂度 O(1) ：  变量 tmp 使用常数大小额外空间（数组 b作为返回值，不计入复杂度考虑）。</li></ul><h3 id="其他优秀解答"><a class="markdownIt-Anchor" href="#其他优秀解答"></a> 其他优秀解答</h3><blockquote><p>解题思路</p></blockquote><p>对称遍历</p><ul><li>从左往右遍历累乘，结果保存在数组 left 中，此时 left[i] 表示，A[i]左边所有元素的乘积</li><li>然后从右往左遍历累乘，结果保存在数组 right中，此时right[i] 表示获取A[i]右边所有元素的乘积</li><li>最后结果数组res[i] =left[i]*right[i]</li></ul><blockquote><p>代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] constructArr(<span class="keyword">int</span>[] a) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a.length == <span class="number">0</span> || a == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = a.length;</span><br><span class="line">        <span class="keyword">int</span>[] left = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span>[] right = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        left[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        right[len-<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= len -<span class="number">1</span>; i++)&#123;</span><br><span class="line">            left[i] = a[i-<span class="number">1</span>] * left[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = len-<span class="number">2</span>; j &gt;= <span class="number">0</span>; j-- )&#123;</span><br><span class="line">            right[j] = a[j+<span class="number">1</span>] * right[j+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            res[i] = left[i] * right[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目信息&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#题目信息&quot;&gt;&lt;/a&gt; 题目信息&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;题目：剑指 Offer 66. 构建乘积数组&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时间： 2020-09-07&lt;
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://wangqiang.cool/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="限制运算符号" scheme="http://wangqiang.cool/tags/%E9%99%90%E5%88%B6%E8%BF%90%E7%AE%97%E7%AC%A6%E5%8F%B7/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 68 - I. 二叉搜索树的最近公共祖先</title>
    <link href="http://wangqiang.cool/2020/09/07/%E5%89%91%E6%8C%87-Offer-68-I-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    <id>http://wangqiang.cool/2020/09/07/%E5%89%91%E6%8C%87-Offer-68-I-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</id>
    <published>2020-09-07T06:13:47.000Z</published>
    <updated>2020-09-07T06:17:15.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目信息"><a class="markdownIt-Anchor" href="#题目信息"></a> 题目信息</h3><ul><li><p>题目： 剑指 Offer 68 - I. 二叉搜索树的最近公共祖先</p></li><li><p>时间： 2020-09-07</p></li><li><p>题目链接：<a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/" target="_blank" rel="noopener">Leetcode</a></p></li><li><p>tag：二叉树 二叉搜索树 递归 迭代</p></li><li><p>难易程度：简单</p></li><li><p>题目描述：</p><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p>最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p><p>例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5]</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     6</span><br><span class="line">   /   \</span><br><span class="line">  2     8</span><br><span class="line"> / \   / \</span><br><span class="line">0   4 7   9</span><br><span class="line">   / \</span><br><span class="line">  3   5</span><br></pre></td></tr></table></figure></li></ul><p><strong>示例1:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8</span><br><span class="line">输出: 6 </span><br><span class="line">解释: 节点 2 和节点 8 的最近公共祖先是 6。</span><br></pre></td></tr></table></figure><p><strong>示例2:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4</span><br><span class="line">输出: 2</span><br><span class="line">解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure><blockquote><p>注意</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 所有节点的值都是唯一的。</span><br><span class="line">2. p、q 为不同节点且均存在于给定的二叉搜索树中。</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><blockquote><p>本题难点</p></blockquote><p>最近公共祖先</p><blockquote><p>具体思路</p></blockquote><p><strong>祖先的定义</strong>： 若节点 p 在节点 root 的左（右）子树中，或 p=root，则称 root 是 p 的祖先。</p><p><strong>最近公共祖先的定义</strong>： 设节点 root 为节点 p,q 的某公共祖先，若其左子节点 root.left 和右子节点 root.right 都不是 p,q 的公共祖先，则称 root 是 “最近的公共祖先” 。</p><p>若 root<em>r<strong>o</strong>o**t</em> 是 p,q<em>p</em>,<em>q</em> 的 <strong>最近公共祖先</strong> ，则只可能为以下情况之一：</p><ol><li><em>p</em> 和 q<em>q</em> 在 root 的子树中，且分列 root 的 <strong>异侧</strong>（即分别在左、右子树中）；</li><li><em>p</em>=root，且 q在 root 的左或右子树中；</li><li><em>q</em>=root，且 p 在 root的左或右子树中；</li></ol><p>本题给定了两个重要条件：① 树为 二叉搜索树 ，② 树的所有节点的值都是 唯一 的。根据以上条件，可方便地判断 p,q 与 root 的子树关系，即：</p><ul><li>若 root.val&lt;p.val ，则 p 在 root<strong>右子树</strong> 中</li><li>若 root.val&gt;p.val ，则 p 在 root<strong>左子树</strong> 中</li><li>若 root.val=p.val ，则 p 和root指向同一节点</li></ul><blockquote><p>提示 ：迭代</p></blockquote><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.val &gt; p.val &amp;&amp; root.val &gt; q.val)&#123;<span class="comment">////当 p,q 都在 root 的 左子树 中，则遍历至 root.left</span></span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val &lt; p.val &amp;&amp; root.val &lt; q.val)&#123;<span class="comment">//当 p,q 都在 root 的 右子树 中，则遍历至 root.right</span></span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(N) ：  其中 N为二叉树节点数；每循环一轮排除一层，二叉搜索树的层数最小为 log⁡N（满二叉树），最大为 N（退化为链表）。</li><li>空间复杂度 O(1) ：使用常数大小的额外空间。</li></ul><h3 id="其他优秀解答"><a class="markdownIt-Anchor" href="#其他优秀解答"></a> 其他优秀解答</h3><blockquote><p>解题思路</p></blockquote><p>递归</p><ul><li>当 p,q 都在 root 的 右子树 中，则开启递归 root.right 并返回；</li><li>否则，当 p,q 都在 root 的 左子树 中，则开启递归 root.left 并返回；</li></ul><blockquote><p>代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root.val &lt; p.val &amp;&amp; root.val &lt; q.val)</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="keyword">if</span>(root.val &gt; p.val &amp;&amp; root.val &gt; q.val)</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目信息&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#题目信息&quot;&gt;&lt;/a&gt; 题目信息&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;题目： 剑指 Offer 68 - I. 二叉搜索树的最近公共祖先&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时间： 
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://wangqiang.cool/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="迭代" scheme="http://wangqiang.cool/tags/%E8%BF%AD%E4%BB%A3/"/>
    
      <category term="二叉树" scheme="http://wangqiang.cool/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="二叉搜索树" scheme="http://wangqiang.cool/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
      <category term="递归" scheme="http://wangqiang.cool/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 68 - II. 二叉树的最近公共祖先</title>
    <link href="http://wangqiang.cool/2020/09/07/%E5%89%91%E6%8C%87-Offer-68-II-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    <id>http://wangqiang.cool/2020/09/07/%E5%89%91%E6%8C%87-Offer-68-II-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</id>
    <published>2020-09-07T03:50:07.000Z</published>
    <updated>2020-09-07T06:14:05.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目信息"><a class="markdownIt-Anchor" href="#题目信息"></a> 题目信息</h3><ul><li><p>题目： 剑指 Offer 68 - II. 二叉树的最近公共祖先</p></li><li><p>时间： 2020-09-07</p></li><li><p>题目链接：<a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/" target="_blank" rel="noopener">Leetcode</a></p></li><li><p>tag：二叉树 递归 深度优先搜索</p></li><li><p>难易程度：中等</p></li><li><p>题目描述：</p><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     3</span><br><span class="line">   /   \</span><br><span class="line">  5     1</span><br><span class="line"> / \   / \</span><br><span class="line">6   2 0   8</span><br><span class="line">   / \</span><br><span class="line">  7   4</span><br></pre></td></tr></table></figure></li></ul><p><strong>示例1:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1</span><br><span class="line">输出: 3</span><br><span class="line">解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</span><br></pre></td></tr></table></figure><p><strong>示例2:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4</span><br><span class="line">输出: 5</span><br><span class="line">解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure><blockquote><p>注意</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 所有节点的值都是唯一的。</span><br><span class="line">2. p、q 为不同节点且均存在于给定的二叉树中。</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3><blockquote><p>本题难点</p></blockquote><p>一般二叉树查找最近公共祖先节点。</p><blockquote><p>具体思路</p></blockquote><p>考虑通过递归对二叉树进行后序遍历，当遇到节点 p 或 q 时返回。从底至顶回溯，当节点 p,q 在节点 root 的异侧时，节点 root 即为最近公共祖先，则向上返回 root 。</p><p><strong>递推工作</strong>：</p><ul><li>递归左子节点，返回值记为 left ；</li><li>递归右子节点，返回值记为 right ；</li></ul><p><strong>返回值</strong>：</p><ul><li>当 left 和 right 同时<strong>为空</strong> ：说明 root 的左 / 右子树中都不包含 p,q ，返回 null ；</li><li>当 left 和 right 同时<strong>不为空</strong> ：说明 p,q 分列在 root 的 异侧 （分别在 左 / 右子树），因此 root 为最近公共祖先，返回 root ；</li><li>当 <strong>left 为空</strong> ，<strong>right 不为空</strong> ：p,q 都不在 root 的左子树中，直接返回 right 。具体可分为两种情况：<ol><li><em>p</em>,<em>q</em> 其中一个在 root的 <strong>右子树</strong> 中，此时 right 指向 p（假设为 p ）；</li><li><em>p</em>,<em>q</em> 两节点都在 root 的 <strong>右子树</strong> 中，此时的 right 指向 <strong>最近公共祖先节点</strong> ；</li></ol></li><li>当 <strong>left 不为空</strong> ， <strong>right为空</strong> ：p,q 都不在 root 的右子树中，直接返回 left 。具体可分为两种情况<ol><li><em>p</em>,<em>q</em> 其中一个在 root的 <strong>左子树</strong> 中，此时 left 指向 p（假设为 p ）；</li><li><em>p</em>,<em>q</em> 两节点都在 root 的 <strong>左子树</strong> 中，此时的 left 指向 <strong>最近公共祖先节点</strong> ；</li></ol></li></ul><blockquote><p>提示</p></blockquote><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//当 root 等于 p,q ，则直接返回 root</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span> || root.val == p.val || root.val == q.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode left = lowestCommonAncestor(root.left,p,q);</span><br><span class="line">        TreeNode right = lowestCommonAncestor(root.right,p,q);</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(N) ： 其中 N为二叉树节点数；最差情况下，需要递归遍历树的所有节点。</li><li>空间复杂度 O(N) ：  最差情况下，递归深度达到 N，系统使用 O(N)大小的额外空间。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目信息&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#题目信息&quot;&gt;&lt;/a&gt; 题目信息&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;题目： 剑指 Offer 68 - II. 二叉树的最近公共祖先&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时间： 2
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://wangqiang.cool/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="二叉树" scheme="http://wangqiang.cool/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="递归" scheme="http://wangqiang.cool/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="深度优先搜索" scheme="http://wangqiang.cool/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>Typora + PicGo + Github实现图床</title>
    <link href="http://wangqiang.cool/2020/07/18/Typora%20+%20PicGo%20+%20Github%E5%AE%9E%E7%8E%B0%E5%9B%BE%E5%BA%8A/"/>
    <id>http://wangqiang.cool/2020/07/18/Typora%20+%20PicGo%20+%20Github%E5%AE%9E%E7%8E%B0%E5%9B%BE%E5%BA%8A/</id>
    <published>2020-07-18T05:24:39.000Z</published>
    <updated>2020-09-07T06:35:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h2><p>在日常记录学习笔记以及自己的想法时，都会使用到Typora这款优秀的<code>Markdown</code>编辑器，<a href="https://typora.io/" target="_blank" rel="noopener">Typora</a>编写出来的编写的排版让强迫的我也挑不出毛病，极力推荐使用，大家可自行感受写作带来的乐趣。但是在写作的过程中，最大的痛点就是粘贴的图片在本地查看文档是没有问题的，但是把文章复制到博客后，就会存在图片无法加载的情况，为此，寻求<code>google</code>帮助，解决这件麻烦事。在写这篇文章前，终于得到了解决。</p><h2 id="前期准备"><a class="markdownIt-Anchor" href="#前期准备"></a> 前期准备</h2><p>Typora：<a href="https://typora.io/" target="_blank" rel="noopener">官网链接</a>，傻瓜式安装就可以了</p><p>PicGo ：<a href="https://molunerfinn.com/PicGo/" target="_blank" rel="noopener">官网链接</a>，下载在自己能找到的地方</p><p>Github账号注册与仓库创建：作为一个互联网的搬砖师，多多少少也是知道的吧，不会的请自行<code>Google</code>，创建仓库的目的主要是用来存储照片</p><h2 id="软件设置"><a class="markdownIt-Anchor" href="#软件设置"></a> 软件设置</h2><h3 id="typora设置"><a class="markdownIt-Anchor" href="#typora设置"></a> Typora设置</h3><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/2020/07/18/822c637b26def0205359b4d2d733ca52.png" alt="20200718122954gu8y3" /></p><h3 id="picgo设置"><a class="markdownIt-Anchor" href="#picgo设置"></a> PicGo设置</h3><p>参数说明：</p><ul><li>仓库名：表示远程仓库地址，固定格式 <code>Github用户名/仓库名</code>，前期准备用到的仓库</li><li>分支名：表示分支，默认填入master，需要根据自己Github上的分支进行填写</li><li>Token：填入Github中生成的Token，下方将详细讲解Token获取</li><li>存储路径：可以自定义一个文件路径</li><li>自定义域名：建议使用<code>https:cdn.jsdelivr.net/gh/Github用户名/仓库名</code></li></ul><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/2020/07/18/e3c3a1574cb6f45bc25ca5cd756d5586.png" alt="202007181238490ya9y" /></p><h3 id="github-token生成"><a class="markdownIt-Anchor" href="#github-token生成"></a> Github Token生成</h3><p>步骤：</p><ol><li>进入Github首页</li><li>点击右上角的头像</li><li>选择Settings</li><li>在左边的选项中选择Developer settings</li><li>选择左边的Personal access tokens，点击Generate new token后会让你输入github登录密码，验证身份后进入以下页面</li><li>输入Note信息和勾选上对应的repo权限后滑动到最下方，选择Generate token</li><li>就会生成一条Token信息，生成的Token只会出现一次，切记保存</li></ol><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/2020/07/18/75a59eb5f050007a1f98ae2dff4e0cd0.png" alt="github创建Token" /></p><h2 id="测试是否能正常上传"><a class="markdownIt-Anchor" href="#测试是否能正常上传"></a> 测试是否能正常上传</h2><p>为了保证我们上传图片没有问题，可以在Typora中选择 文件 → 偏好设置 → 选择验证图片上传选项进行测试，如看到验证成功，成功上传图片并获得最新的URL则表示成功</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/2020/07/18/ce6fdc9671489711351fdadd9b9c4ac7.png" alt="20200718124545orsasdym" /></p><p>也可以直接在文档中插入图片来查看是否上传成功</p><h2 id="踩坑记录"><a class="markdownIt-Anchor" href="#踩坑记录"></a> 踩坑记录</h2><p>用了一段时间突然发现不能上传了类似下图这样。</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/2020/07/18/14f3a4d60b9742c6abc24e5a5896f5dd.png" alt="aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NvZGV0d29kb2cvQmxvZy1QaWMtUmVwb3NpdG9yeS9tYXN0ZXIvYmxvZ0ltZy9QaWNHb2dpdGh1YiVFNSU4NyVCQSVFOSU5NCU5OSVFNCVCRiVBMSVFNiU4MSVBRi5wbmc" /></p><ul><li>再次检查你的仓库名是否正确，仓库名不能出现空格！！如果一定要有空格请用 - 来代替</li><li>不能上传文件名重复的图片</li><li>文件名不要包含奇怪的字符（加号、乘号、百分号等等）</li></ul><h2 id="解决图床上传的各种问题"><a class="markdownIt-Anchor" href="#解决图床上传的各种问题"></a> 解决图床上传的各种问题</h2><p>有时候间接性还会出现上传失败的问题</p><p>查看日志发现</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/2020/07/18/7b7f823bb7f0aef19f3ee2cd0a6fd236.png" alt="20200718125526q4f5y" /></p><p>解决思路：</p><p>搭一个中间代理</p><h3 id="所需工具"><a class="markdownIt-Anchor" href="#所需工具"></a> 所需工具</h3><ul><li>VPN</li><li>google或outlook邮箱</li></ul><h3 id="解决步骤"><a class="markdownIt-Anchor" href="#解决步骤"></a> 解决步骤</h3><h4 id="进入下方网址"><a class="markdownIt-Anchor" href="#进入下方网址"></a> 进入下方网址</h4><p><a href="https://www.000webhost.com/" target="_blank" rel="noopener">https://www.000webhost.com/</a> ,浏览网页选择下方箭头所指。<br />(没有该网站账号密码没有关系，选择之后注册登录即可，当然也可以先注册登录再选择。)</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/2020/07/18/dbb2a9e0d59372fb0cb3c45db37065a7.png" alt="cd8a16b2a5ed295aa3f5b" /></p><h4 id="建立自己的网站"><a class="markdownIt-Anchor" href="#建立自己的网站"></a> 建立自己的网站</h4><p>网站用户名密码自定义设置</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/2020/07/18/ddf7871cd7f5a2cff889681578a83338.png" alt="aaaab0964503f59a7f9" /></p><h4 id="选择upload-your-site"><a class="markdownIt-Anchor" href="#选择upload-your-site"></a> 选择Upload your site</h4><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/2020/07/18/bdfeafd77cf1ec7ca35d6dceecd6fd85.png" alt="bbbb65589d4082ab" /></p><p>此时我们需要给网站上传一个up.php配置文件</p><h4 id="配置upphp"><a class="markdownIt-Anchor" href="#配置upphp"></a> 配置up.php</h4><p>项目地址：<a href="https://github.com/kjhuanhao/autoPicCdn" target="_blank" rel="noopener">https://github.com/kjhuanhao/autoPicCdn</a><br />下载此项目，修改其中的<strong>up.php</strong>文件。<br />只需修改下列代码，按提示修改即可：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="string">"REPO"</span>,<span class="string">"仓库"</span>);<span class="comment">//必须是下面用户名下的公开仓库</span></span><br><span class="line">define(<span class="string">"USER"</span>,<span class="string">"github仓库名"</span>);<span class="comment">//必须是当前GitHub用户名</span></span><br><span class="line">define(<span class="string">"MAIL"</span>,<span class="string">"yumusb@foxmail.com"</span>);<span class="comment">//</span></span><br><span class="line">define(<span class="string">"TOKEN"</span>,<span class="string">"token"</span>);<span class="comment">//https://github.com/settings/tokens 去这个页面生成一个有写权限的token（write:packages前打勾）</span></span><br></pre></td></tr></table></figure><p><strong>特别注意：token只会生成一次，且生成后不再显示，如果忘记需要重新生成，但是之前生成的就是失效。注意保存！</strong></p><p>修改完毕之后保存即可。</p><h4 id="上传upphp"><a class="markdownIt-Anchor" href="#上传upphp"></a> 上传up.php</h4><p>如图所示操作</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/2020/07/18/bc101c5cb2f4f56183582254acd7ec58.png" alt="cccccd41d47fca87a" /></p><h4 id="保存地址"><a class="markdownIt-Anchor" href="#保存地址"></a> 保存地址</h4><p>访问下列地址:<br /><a href="https://www.000webhost.com/members/website/list" target="_blank" rel="noopener">https://www.000webhost.com/members/website/list</a><br />复制下方箭头所指地址：</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/2020/07/18/d5720aac20281fc9ef7b68d059d09dae.png" alt="dddddd2652c48e1a54ac" />（注：鼠标移至该地址上方图片可选择管理网站，如果因网络不佳中途是关闭网址，可以访问上述超链接进入该网址选择管理网站，进入网站的管理界面，选择其中的File Manager可进入上传up.php的界面。）</p><h4 id="配置picgo"><a class="markdownIt-Anchor" href="#配置picgo"></a> 配置PicGo</h4><p>打开PicGo ——&gt; 选择插件设置 ——&gt; 搜索<strong>web-uploader</strong></p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ID-WangQiang/MyBlogImg@master/2020/07/18/300d8a5f0ad8a1f55d382e6b37dc0822.png" alt="qqqqqeba05a0da2" />之后点击插件模块右下角的设置样式，选择配置uploader -up -uploader</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">API地址填写刚刚复制的地址</span> <span class="string">+ /up.php</span></span><br><span class="line"><span class="attr">POST参数名填写pic</span></span><br><span class="line"><span class="attr">JSON路径填写data.url</span></span><br></pre></td></tr></table></figure><p>填写完毕之后，保存即可！</p><h4 id="自定义web图床"><a class="markdownIt-Anchor" href="#自定义web图床"></a> 自定义web图床</h4><p>上述全部设置完毕之后，在picgo上传区选择自定义图床。之后，就可以进行图片的上传了！</p><h2 id="写在最后"><a class="markdownIt-Anchor" href="#写在最后"></a> 写在最后</h2><p>这次的搭建虽然经历了一些波折，但也算搭建成功了，希望正在搭建的朋友看到我这篇文章能少走一点弯路，顺利把图床搭建起来。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#背景&quot;&gt;&lt;/a&gt; 背景&lt;/h2&gt;
&lt;p&gt;在日常记录学习笔记以及自己的想法时，都会使用到Typora这款优秀的&lt;code&gt;Markdown&lt;/code&gt;编辑器，&lt;a href=&quot;http
      
    
    </summary>
    
    
      <category term="工具" scheme="http://wangqiang.cool/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="图床" scheme="http://wangqiang.cool/tags/%E5%9B%BE%E5%BA%8A/"/>
    
  </entry>
  
  <entry>
    <title>关于Hexo博客系统的使用</title>
    <link href="http://wangqiang.cool/2020/07/14/%E5%85%B3%E4%BA%8EHexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://wangqiang.cool/2020/07/14/%E5%85%B3%E4%BA%8EHexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2020-07-14T09:35:26.000Z</published>
    <updated>2020-09-07T06:35:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。<br />这是一篇关于Hexo博客系统如何使用的文章，最基本的操作指令。</p><blockquote><p>Hexo基本指令</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Usage: hexo &lt;<span class="built_in">command</span>&gt;</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  clean     Remove generated files and cache.</span><br><span class="line">  config    Get or <span class="built_in">set</span> configurations.</span><br><span class="line">  deploy    Deploy your website.</span><br><span class="line">  douban    Generate pages from douban</span><br><span class="line">  generate  Generate static files.</span><br><span class="line">  <span class="built_in">help</span>      Get <span class="built_in">help</span> on a <span class="built_in">command</span>.</span><br><span class="line">  init      Create a new Hexo folder.</span><br><span class="line">  list      List the information of the site</span><br><span class="line">  migrate   Migrate your site from other system to Hexo.</span><br><span class="line">  new       Create a new post.</span><br><span class="line">  publish   Moves a draft post from _drafts to _posts folder.</span><br><span class="line">  render    Render files with renderer plugins.</span><br><span class="line">  server    Start the server.</span><br><span class="line">  version   Display version information.</span><br><span class="line"></span><br><span class="line">Global Options:</span><br><span class="line">  --config  Specify config file instead of using _config.yml</span><br><span class="line">  --cwd     Specify the CWD</span><br><span class="line">  --debug   Display all verbose messages <span class="keyword">in</span> the terminal</span><br><span class="line">  --draft   Display draft posts</span><br><span class="line">  --safe    Disable all plugins and scripts</span><br><span class="line">  --silent  Hide output on console</span><br></pre></td></tr></table></figure><blockquote><p>编译博客</p></blockquote><p>在项目根目录执行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">或者</span><br><span class="line">hexo g</span><br></pre></td></tr></table></figure><blockquote><p>本地运行博客</p></blockquote><p>在项目根目录执行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br><span class="line">或者</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><blockquote><p>发布博客</p></blockquote><p>在项目根目录执行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br><span class="line">或者</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><blockquote><p>发布新页面</p></blockquote><ol><li><p>项目根目录下执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page xxx</span><br></pre></td></tr></table></figure></li><li><p>在项目source目录下会产生xxx页面的文件夹，在xxx文件夹下的index.md文档中编辑页面配置</p></li><li><p>页面头部信息</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title:</span><br><span class="line">date:</span><br><span class="line">updated:</span><br><span class="line">type:</span><br><span class="line">comments:</span><br><span class="line">description:</span><br><span class="line">keywords:</span><br><span class="line">top_img:</span><br><span class="line">mathjax:</span><br><span class="line">katex:</span><br><span class="line">aside:</span><br><span class="line">aplayer：</span><br><span class="line">highlight_shrink：</span><br><span class="line">---</span><br></pre></td></tr></table></figure><table><thead><tr><th>写法</th><th>解释</th></tr></thead><tbody><tr><td>title</td><td>【必需】页面标题</td></tr><tr><td>date</td><td>【必需】页面创建日期</td></tr><tr><td>type</td><td>【必需】标籤、分类和友情链接三个页面需要配置</td></tr><tr><td>updated</td><td>【可选】页面更新日期</td></tr><tr><td>description</td><td>【可选】文章描述</td></tr><tr><td>keywords</td><td>【可选】文章关键字</td></tr><tr><td>comments</td><td>【可选】显示页面评论模块(默认 true)</td></tr><tr><td>top_img</td><td>【可选】页面顶部图片</td></tr><tr><td>comments</td><td>【可选】显示文章评论模块(默认 true)</td></tr><tr><td>mathjax</td><td>【可选】显示mathjax(当设置mathjax的per_page: false时，才需要配置，默认 false)轉載請註明出處。</td></tr><tr><td>katex</td><td>【可选】显示katex(当设置katex的per_page: false时，才需要配置，默认 false)</td></tr><tr><td>aside</td><td>【可选】显示侧边栏 (默认 true)</td></tr><tr><td>aplayer</td><td>【可选】在需要的页面加载aplayer的js和css,请参考文章下面的音乐 配置</td></tr><tr><td>highlight_shrink</td><td>【可选】配置代码框是否展开(true/false)(默认为设置中highlight_shrink的配置)</td></tr></tbody></table></li></ol><blockquote><p>发布新文章</p></blockquote><ol><li><p>项目根目录下执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new post xxx</span><br></pre></td></tr></table></figure></li><li><p>在项目source/_posts目录下会产生xxx.md文档,在文档头部中编辑文章配置</p></li><li><p>文章头部信息</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title:</span><br><span class="line">date:</span><br><span class="line">updated:</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br><span class="line">keywords:</span><br><span class="line">description:</span><br><span class="line">top_img:</span><br><span class="line">comments：</span><br><span class="line">cover:  </span><br><span class="line">toc:  </span><br><span class="line">toc_number:</span><br><span class="line">auto_open:</span><br><span class="line">copyright:</span><br><span class="line">mathjax:</span><br><span class="line">katex:</span><br><span class="line">aplayer：</span><br><span class="line">highlight_shrink：</span><br><span class="line">---</span><br></pre></td></tr></table></figure><table><thead><tr><th>写法</th><th>解释</th></tr></thead><tbody><tr><td>title</td><td>【必需】文章标题</td></tr><tr><td>date</td><td>【必需】文章创建日期</td></tr><tr><td>updated</td><td>【可选】文章更新日期</td></tr><tr><td>tags</td><td>【可选】文章标籤</td></tr><tr><td>categories</td><td>【可选】文章分类</td></tr><tr><td>keywords</td><td>【可选】文章关键字</td></tr><tr><td>description</td><td>【可选】文章描述</td></tr><tr><td>top_img</td><td>【可选】文章顶部图片</td></tr><tr><td>cover</td><td>【可选】文章缩略图(如果没有设置top_img,文章页顶部将显示缩略图，可设为false/图片地址/留空)</td></tr><tr><td>comments</td><td>【可选】显示文章评论模块(默认 true)</td></tr><tr><td>toc</td><td>【可选】显示文章TOC(默认为设置中toc的enable配置)</td></tr><tr><td>toc_number</td><td>【可选】显示toc_number(默认为设置中toc的number配置)</td></tr><tr><td>auto_open</td><td>【可选】是否自动打开TOC(默认为设置中toc的auto_open配置)</td></tr><tr><td>copyright</td><td>【可选】显示文章版权模块(默认为设置中post_copyright的enable配置)</td></tr><tr><td>mathjax</td><td>【可选】显示mathjax(当设置mathjax的per_page: false时，才需要配置，默认 false)轉載請註明出處。</td></tr><tr><td>katex</td><td>【可选】显示katex(当设置katex的per_page: false时，才需要配置，默认 false)</td></tr><tr><td>aplayer</td><td>【可选】在需要的页面加载aplayer的js和css,请参考文章下面的音乐 配置</td></tr><tr><td>highlight_shrink</td><td>【可选】配置代码框是否展开(true/false)(默认为设置中highlight_shrink的配置)</td></tr></tbody></table></li></ol><p>更详细博客配置请参考<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a><br />更详细主题配置请参考<a href="https://demo.jerryc.me" target="_blank" rel="noopener">Butterfly</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。&lt;br /&gt;
这是一篇关于Hexo博客系统如何使用的文章，最基本的操作指令。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Hexo基
      
    
    </summary>
    
    
      <category term="工具" scheme="http://wangqiang.cool/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="博客" scheme="http://wangqiang.cool/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
</feed>
